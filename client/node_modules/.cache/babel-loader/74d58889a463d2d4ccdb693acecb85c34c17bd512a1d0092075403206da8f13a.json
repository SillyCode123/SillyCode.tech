{"ast":null,"code":"'use strict';\n\nvar __defProp = Object.defineProperty;\nvar __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, {\n  enumerable: true,\n  configurable: true,\n  writable: true,\n  value\n}) : obj[key] = value;\nvar __name = (target, value) => __defProp(target, \"name\", {\n  value,\n  configurable: true\n});\nvar __publicField = (obj, key, value) => {\n  __defNormalProp(obj, typeof key !== \"symbol\" ? key + \"\" : key, value);\n  return value;\n};\nvar __accessCheck = (obj, member, msg) => {\n  if (!member.has(obj)) throw TypeError(\"Cannot \" + msg);\n};\nvar __privateGet = (obj, member, getter) => {\n  __accessCheck(obj, member, \"read from private field\");\n  return getter ? getter.call(obj) : member.get(obj);\n};\nvar __privateAdd = (obj, member, value) => {\n  if (member.has(obj)) throw TypeError(\"Cannot add the same private member more than once\");\n  member instanceof WeakSet ? member.add(obj) : member.set(obj, value);\n};\nvar __privateSet = (obj, member, value, setter) => {\n  __accessCheck(obj, member, \"write to private field\");\n  setter ? setter.call(obj, value) : member.set(obj, value);\n  return value;\n};\nvar __privateWrapper = (obj, member, setter, getter) => ({\n  set _(value) {\n    __privateSet(obj, member, value, setter);\n  },\n  get _() {\n    return __privateGet(obj, member, getter);\n  }\n});\n\n// src/lib/Snowflake.ts\nvar ProcessId = 1n;\nvar WorkerId = 0n;\nvar _increment, _epoch;\nvar Snowflake = class {\n  constructor(epoch) {\n    __publicField(this, \"decode\", this.deconstruct);\n    __privateAdd(this, _increment, 0n);\n    __privateAdd(this, _epoch, void 0);\n    __privateSet(this, _epoch, BigInt(epoch instanceof Date ? epoch.getTime() : epoch));\n  }\n  get epoch() {\n    return __privateGet(this, _epoch);\n  }\n  generate() {\n    let {\n      increment,\n      timestamp = Date.now(),\n      workerId = WorkerId,\n      processId = ProcessId\n    } = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    if (timestamp instanceof Date) timestamp = BigInt(timestamp.getTime());else if (typeof timestamp === \"number\") timestamp = BigInt(timestamp);else if (typeof timestamp !== \"bigint\") {\n      throw new TypeError(`\"timestamp\" argument must be a number, bigint, or Date (received ${typeof timestamp})`);\n    }\n    if (typeof increment === \"bigint\" && increment >= 4095n) increment = 0n;else {\n      increment = __privateWrapper(this, _increment)._++;\n      if (__privateGet(this, _increment) >= 4095n) __privateSet(this, _increment, 0n);\n    }\n    return timestamp - __privateGet(this, _epoch) << 22n | (workerId & 0b11111n) << 17n | (processId & 0b11111n) << 12n | increment;\n  }\n  deconstruct(id) {\n    const bigIntId = BigInt(id);\n    return {\n      id: bigIntId,\n      timestamp: (bigIntId >> 22n) + __privateGet(this, _epoch),\n      workerId: bigIntId >> 17n & 0b11111n,\n      processId: bigIntId >> 12n & 0b11111n,\n      increment: bigIntId & 0b111111111111n,\n      epoch: __privateGet(this, _epoch)\n    };\n  }\n  timestampFrom(id) {\n    return Number((BigInt(id) >> 22n) + __privateGet(this, _epoch));\n  }\n  static compare(a, b) {\n    if (typeof a === \"bigint\" || typeof b === \"bigint\") {\n      if (typeof a === \"string\") a = BigInt(a);else if (typeof b === \"string\") b = BigInt(b);\n      return a === b ? 0 : a < b ? -1 : 1;\n    }\n    return a === b ? 0 : a.length < b.length ? -1 : a.length > b.length ? 1 : a < b ? -1 : 1;\n  }\n};\n__name(Snowflake, \"Snowflake\");\n_increment = new WeakMap();\n_epoch = new WeakMap();\n\n// src/lib/DiscordSnowflake.ts\nvar DiscordSnowflake = new Snowflake(1420070400000n);\n\n// src/lib/TwitterSnowflake.ts\nvar TwitterSnowflake = new Snowflake(1288834974657n);\nexports.DiscordSnowflake = DiscordSnowflake;\nexports.Snowflake = Snowflake;\nexports.TwitterSnowflake = TwitterSnowflake;\n//# sourceMappingURL=out.js.map","map":{"version":3,"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AACA;AADA;AAgBO,IAAMA,aAAN;AAAgB,IAsBfC,UAAY,QAA+B;AAjBlD;EAMAC;IAMAC;IAMCC,mBAAKH,UAAS,KAAO;IACtBG;IAKAC,YAA2B;EAC1B;EACD;IAcO,OAASC,YAAE,CAAW,YAAY;EACxC;EAA+BC,WAAsC;IAAA,IAAtC;MAAAC,SAAY;MAAAC,SAAO,GAAUC,QAAS;MAAAC;MAAAC;IAAA;IAAA,aAC5D,YAAOF,MAAwBD,YAAYI,OAAOJ,SAAS,qBAC3D,OAAOA,cAAc,UAC7BA,SAAM,GAAII,gBAAU,OACrB;MAEA,MAAI,IAAOC,8EAAuC;IAAO;IAAY,WAChEN,8CACJA,YAAY,QACZ;MAA8BA,4BAAK,KAAa;MACjD,6CAGAH,YAAS,KAAY,iBAAK;IAC3B;IAYO,gBAAyD;EAC/D;EACAU,WAAO;IAAA,MACFC;IAAA,OACJ;MACAC,YAAW;MACXR,WAAY,aAAY,OAAOH;MAC/BK,kBAAW,IAAW;MACtBC,SAAO,iBAAK;MACbJ;MACDU;IAOO;EACN;EACDC;IAqBA,OAAcC,MAAQ,QAAoD;EACzE;EACC,cAAI,CAAOC,MAAM;IAAU,WAAIA,MAAQ;MAAA,WAC9BA,MAAO,QAAM,EAAUA,IAAIR,OAAOQ,CAAC,OAC5C,IAAO,OAAMC,CAAI,KAAI,QAAQ,EAC9BA;MAEA,OAAOD,MAAMC,IAAI,IAAMD,SAAS,IAAE;IACnC;IACD;EAzHa;AAWZ;AAMAE","names":["WorkerId","_increment","constructor","__publicField","__privateAdd","__privateSet","__privateGet","generate","increment","timestamp","Date","workerId","processId","BigInt","TypeError","deconstruct","bigIntId","id","epoch","timestampFrom","Number","a","b","__name"],"sources":["J:\\Coding\\Projekts\\Web\\JavaScript\\sillcode.tech\\node_modules\\@sapphire\\snowflake\\src\\lib\\Snowflake.ts"],"sourcesContent":["const ProcessId = 1n;\nconst WorkerId = 0n;\n\n/**\n * A class for generating and deconstructing Twitter snowflakes.\n *\n * A {@link https://developer.twitter.com/en/docs/twitter-ids Twitter snowflake}\n * is a 64-bit unsigned integer with 4 fields that have a fixed epoch value.\n *\n * If we have a snowflake `266241948824764416` we can represent it as binary:\n * ```\n * 64                                          22     17     12          0\n *  000000111011000111100001101001000101000000  00001  00000  000000000000\n *           number of ms since epoch           worker  pid    increment\n * ```\n */\nexport class Snowflake {\n\t/**\n\t * Alias for {@link deconstruct}\n\t */\n\t// eslint-disable-next-line @typescript-eslint/unbound-method\n\tpublic decode = this.deconstruct;\n\n\t/**\n\t * Internal incrementor for generating snowflakes\n\t * @internal\n\t */\n\t#increment = 0n;\n\n\t/**\n\t * Internal reference of the epoch passed in the constructor\n\t * @internal\n\t */\n\t#epoch: bigint;\n\n\t/**\n\t * @param epoch the epoch to use\n\t */\n\tpublic constructor(epoch: number | bigint | Date) {\n\t\tthis.#epoch = BigInt(epoch instanceof Date ? epoch.getTime() : epoch);\n\t}\n\n\t/**\n\t * The epoch for this snowflake.\n\t */\n\tpublic get epoch(): bigint {\n\t\treturn this.#epoch;\n\t}\n\n\t/**\n\t * Generates a snowflake given an epoch and optionally a timestamp\n\t * @param options options to pass into the generator, see {@link SnowflakeGenerateOptions}\n\t *\n\t * **note** when `increment` is not provided it defaults to the private `increment` of the instance\n\t * @example\n\t * ```typescript\n\t * const epoch = new Date('2000-01-01T00:00:00.000Z');\n\t * const snowflake = new Snowflake(epoch).generate();\n\t * ```\n\t * @returns A unique snowflake\n\t */\n\tpublic generate({ increment, timestamp = Date.now(), workerId = WorkerId, processId = ProcessId }: SnowflakeGenerateOptions = {}) {\n\t\tif (timestamp instanceof Date) timestamp = BigInt(timestamp.getTime());\n\t\telse if (typeof timestamp === 'number') timestamp = BigInt(timestamp);\n\t\telse if (typeof timestamp !== 'bigint') {\n\t\t\tthrow new TypeError(`\"timestamp\" argument must be a number, bigint, or Date (received ${typeof timestamp})`);\n\t\t}\n\n\t\tif (typeof increment === 'bigint' && increment >= 4095n) increment = 0n;\n\t\telse {\n\t\t\tincrement = this.#increment++;\n\t\t\tif (this.#increment >= 4095n) this.#increment = 0n;\n\t\t}\n\n\t\t// timestamp, workerId, processId, increment\n\t\treturn ((timestamp - this.#epoch) << 22n) | ((workerId & 0b11111n) << 17n) | ((processId & 0b11111n) << 12n) | increment;\n\t}\n\n\t/**\n\t * Deconstructs a snowflake given a snowflake ID\n\t * @param id the snowflake to deconstruct\n\t * @returns a deconstructed snowflake\n\t * @example\n\t * ```typescript\n\t * const epoch = new Date('2000-01-01T00:00:00.000Z');\n\t * const snowflake = new Snowflake(epoch).deconstruct('3971046231244935168');\n\t * ```\n\t */\n\tpublic deconstruct(id: string | bigint): DeconstructedSnowflake {\n\t\tconst bigIntId = BigInt(id);\n\t\treturn {\n\t\t\tid: bigIntId,\n\t\t\ttimestamp: (bigIntId >> 22n) + this.#epoch,\n\t\t\tworkerId: (bigIntId >> 17n) & 0b11111n,\n\t\t\tprocessId: (bigIntId >> 12n) & 0b11111n,\n\t\t\tincrement: bigIntId & 0b111111111111n,\n\t\t\tepoch: this.#epoch\n\t\t};\n\t}\n\n\t/**\n\t * Retrieves the timestamp field's value from a snowflake.\n\t * @param id The snowflake to get the timestamp value from.\n\t * @returns The UNIX timestamp that is stored in `id`.\n\t */\n\tpublic timestampFrom(id: string | bigint): number {\n\t\treturn Number((BigInt(id) >> 22n) + this.#epoch);\n\t}\n\n\t/**\n\t * Returns a number indicating whether a reference snowflake comes before, or after, or is same as the given\n\t * snowflake in sort order.\n\t * @param a The first snowflake to compare.\n\t * @param b The second snowflake to compare.\n\t * @returns `-1` if `a` is older than `b`, `0` if `a` and `b` are equals, `1` if `a` is newer than `b`.\n\t * @example Sort snowflakes in ascending order\n\t * ```typescript\n\t * const ids = ['737141877803057244', '1056191128120082432', '254360814063058944'];\n\t * console.log(ids.sort((a, b) => Snowflake.compare(a, b)));\n\t * // → ['254360814063058944', '737141877803057244', '1056191128120082432'];\n\t * ```\n\t * @example Sort snowflakes in descending order\n\t * ```typescript\n\t * const ids = ['737141877803057244', '1056191128120082432', '254360814063058944'];\n\t * console.log(ids.sort((a, b) => -Snowflake.compare(a, b)));\n\t * // → ['1056191128120082432', '737141877803057244', '254360814063058944'];\n\t * ```\n\t */\n\tpublic static compare(a: string | bigint, b: string | bigint): -1 | 0 | 1 {\n\t\tif (typeof a === 'bigint' || typeof b === 'bigint') {\n\t\t\tif (typeof a === 'string') a = BigInt(a);\n\t\t\telse if (typeof b === 'string') b = BigInt(b);\n\t\t\treturn a === b ? 0 : a < b ? -1 : 1;\n\t\t}\n\n\t\treturn a === b ? 0 : a.length < b.length ? -1 : a.length > b.length ? 1 : a < b ? -1 : 1;\n\t}\n}\n\n/**\n * Options for Snowflake#generate\n */\nexport interface SnowflakeGenerateOptions {\n\t/**\n\t * Timestamp or date of the snowflake to generate\n\t * @default Date.now()\n\t */\n\ttimestamp?: number | bigint | Date;\n\n\t/**\n\t * The increment to use\n\t * @default 0n\n\t * @remark keep in mind that this bigint is auto-incremented between generate calls\n\t */\n\tincrement?: bigint;\n\n\t/**\n\t * The worker ID to use, will be truncated to 5 bits (0-31)\n\t * @default 0n\n\t */\n\tworkerId?: bigint;\n\n\t/**\n\t * The process ID to use, will be truncated to 5 bits (0-31)\n\t * @default 1n\n\t */\n\tprocessId?: bigint;\n}\n\n/**\n * Object returned by Snowflake#deconstruct\n */\nexport interface DeconstructedSnowflake {\n\t/**\n\t * The id in BigInt form\n\t */\n\tid: bigint;\n\n\t/**\n\t * The timestamp stored in the snowflake\n\t */\n\ttimestamp: bigint;\n\n\t/**\n\t * The worker id stored in the snowflake\n\t */\n\tworkerId: bigint;\n\n\t/**\n\t * The process id stored in the snowflake\n\t */\n\tprocessId: bigint;\n\n\t/**\n\t * The increment stored in the snowflake\n\t */\n\tincrement: bigint;\n\n\t/**\n\t * The epoch to use in the snowflake\n\t */\n\tepoch: bigint;\n}\n"]},"metadata":{},"sourceType":"script","externalDependencies":[]}