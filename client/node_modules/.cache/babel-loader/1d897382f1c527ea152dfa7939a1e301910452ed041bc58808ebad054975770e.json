{"ast":null,"code":"\"use strict\";\n\nvar __create = Object.create;\nvar __defProp = Object.defineProperty;\nvar __getOwnPropDesc = Object.getOwnPropertyDescriptor;\nvar __getOwnPropNames = Object.getOwnPropertyNames;\nvar __getProtoOf = Object.getPrototypeOf;\nvar __hasOwnProp = Object.prototype.hasOwnProperty;\nvar __name = (target, value) => __defProp(target, \"name\", {\n  value,\n  configurable: true\n});\nvar __export = (target, all) => {\n  for (var name in all) __defProp(target, name, {\n    get: all[name],\n    enumerable: true\n  });\n};\nvar __copyProps = (to, from, except, desc) => {\n  if (from && typeof from === \"object\" || typeof from === \"function\") {\n    for (let key of __getOwnPropNames(from)) if (!__hasOwnProp.call(to, key) && key !== except) __defProp(to, key, {\n      get: () => from[key],\n      enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable\n    });\n  }\n  return to;\n};\nvar __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(isNodeMode || !mod || !mod.__esModule ? __defProp(target, \"default\", {\n  value: mod,\n  enumerable: true\n}) : target, mod));\nvar __toCommonJS = mod => __copyProps(__defProp({}, \"__esModule\", {\n  value: true\n}), mod);\n\n// src/index.ts\nvar src_exports = {};\n__export(src_exports, {\n  ALLOWED_EXTENSIONS: () => ALLOWED_EXTENSIONS,\n  ALLOWED_SIZES: () => ALLOWED_SIZES,\n  ALLOWED_STICKER_EXTENSIONS: () => ALLOWED_STICKER_EXTENSIONS,\n  CDN: () => CDN,\n  DefaultRestOptions: () => DefaultRestOptions,\n  DefaultUserAgent: () => DefaultUserAgent,\n  DiscordAPIError: () => DiscordAPIError,\n  HTTPError: () => HTTPError,\n  REST: () => REST,\n  RESTEvents: () => RESTEvents,\n  RateLimitError: () => RateLimitError,\n  RequestManager: () => RequestManager,\n  RequestMethod: () => RequestMethod,\n  makeURLSearchParams: () => makeURLSearchParams,\n  parseResponse: () => parseResponse,\n  version: () => version\n});\nmodule.exports = __toCommonJS(src_exports);\n\n// src/lib/CDN.ts\nvar import_node_url = require(\"url\");\n\n// src/lib/utils/constants.ts\nvar import_node_process = __toESM(require(\"process\"));\nvar import_v10 = require(\"discord-api-types/v10\");\nvar import_undici = require(\"undici\");\nvar DefaultUserAgent = `DiscordBot (https://discord.js.org, 1.5.0)`;\nvar DefaultRestOptions = {\n  get agent() {\n    return new import_undici.Agent({\n      connect: {\n        timeout: 3e4\n      }\n    });\n  },\n  api: \"https://discord.com/api\",\n  authPrefix: \"Bot\",\n  cdn: \"https://cdn.discordapp.com\",\n  headers: {},\n  invalidRequestWarningInterval: 0,\n  globalRequestsPerSecond: 50,\n  offset: 50,\n  rejectOnRateLimit: null,\n  retries: 3,\n  timeout: 15e3,\n  userAgentAppendix: `Node.js ${import_node_process.default.version}`,\n  version: import_v10.APIVersion,\n  hashSweepInterval: 144e5,\n  hashLifetime: 864e5,\n  handlerSweepInterval: 36e5\n};\nvar RESTEvents = /* @__PURE__ */(RESTEvents2 => {\n  RESTEvents2[\"Debug\"] = \"restDebug\";\n  RESTEvents2[\"HandlerSweep\"] = \"handlerSweep\";\n  RESTEvents2[\"HashSweep\"] = \"hashSweep\";\n  RESTEvents2[\"InvalidRequestWarning\"] = \"invalidRequestWarning\";\n  RESTEvents2[\"RateLimited\"] = \"rateLimited\";\n  RESTEvents2[\"Response\"] = \"response\";\n  return RESTEvents2;\n})(RESTEvents || {});\nvar ALLOWED_EXTENSIONS = [\"webp\", \"png\", \"jpg\", \"jpeg\", \"gif\"];\nvar ALLOWED_STICKER_EXTENSIONS = [\"png\", \"json\"];\nvar ALLOWED_SIZES = [16, 32, 64, 128, 256, 512, 1024, 2048, 4096];\n\n// src/lib/CDN.ts\nvar CDN = class {\n  constructor() {\n    let base = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : DefaultRestOptions.cdn;\n    this.base = base;\n  }\n  appAsset(clientId, assetHash, options) {\n    return this.makeURL(`/app-assets/${clientId}/${assetHash}`, options);\n  }\n  appIcon(clientId, iconHash, options) {\n    return this.makeURL(`/app-icons/${clientId}/${iconHash}`, options);\n  }\n  avatar(id, avatarHash, options) {\n    return this.dynamicMakeURL(`/avatars/${id}/${avatarHash}`, avatarHash, options);\n  }\n  banner(id, bannerHash, options) {\n    return this.dynamicMakeURL(`/banners/${id}/${bannerHash}`, bannerHash, options);\n  }\n  channelIcon(channelId, iconHash, options) {\n    return this.makeURL(`/channel-icons/${channelId}/${iconHash}`, options);\n  }\n  defaultAvatar(discriminator) {\n    return this.makeURL(`/embed/avatars/${discriminator}`, {\n      extension: \"png\"\n    });\n  }\n  discoverySplash(guildId, splashHash, options) {\n    return this.makeURL(`/discovery-splashes/${guildId}/${splashHash}`, options);\n  }\n  emoji(emojiId, extension) {\n    return this.makeURL(`/emojis/${emojiId}`, {\n      extension\n    });\n  }\n  guildMemberAvatar(guildId, userId, avatarHash, options) {\n    return this.dynamicMakeURL(`/guilds/${guildId}/users/${userId}/avatars/${avatarHash}`, avatarHash, options);\n  }\n  guildMemberBanner(guildId, userId, bannerHash, options) {\n    return this.dynamicMakeURL(`/guilds/${guildId}/users/${userId}/banner`, bannerHash, options);\n  }\n  icon(id, iconHash, options) {\n    return this.dynamicMakeURL(`/icons/${id}/${iconHash}`, iconHash, options);\n  }\n  roleIcon(roleId, roleIconHash, options) {\n    return this.makeURL(`/role-icons/${roleId}/${roleIconHash}`, options);\n  }\n  splash(guildId, splashHash, options) {\n    return this.makeURL(`/splashes/${guildId}/${splashHash}`, options);\n  }\n  sticker(stickerId, extension) {\n    return this.makeURL(`/stickers/${stickerId}`, {\n      allowedExtensions: ALLOWED_STICKER_EXTENSIONS,\n      extension: extension ?? \"png\"\n    });\n  }\n  stickerPackBanner(bannerId, options) {\n    return this.makeURL(`/app-assets/710982414301790216/store/${bannerId}`, options);\n  }\n  teamIcon(teamId, iconHash, options) {\n    return this.makeURL(`/team-icons/${teamId}/${iconHash}`, options);\n  }\n  guildScheduledEventCover(scheduledEventId, coverHash, options) {\n    return this.makeURL(`/guild-events/${scheduledEventId}/${coverHash}`, options);\n  }\n  dynamicMakeURL(route, hash) {\n    let {\n      forceStatic = false,\n      ...options\n    } = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n    return this.makeURL(route, !forceStatic && hash.startsWith(\"a_\") ? {\n      ...options,\n      extension: \"gif\"\n    } : options);\n  }\n  makeURL(route) {\n    let {\n      allowedExtensions = ALLOWED_EXTENSIONS,\n      extension = \"webp\",\n      size\n    } = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    extension = String(extension).toLowerCase();\n    if (!allowedExtensions.includes(extension)) {\n      throw new RangeError(`Invalid extension provided: ${extension}\nMust be one of: ${allowedExtensions.join(\", \")}`);\n    }\n    if (size && !ALLOWED_SIZES.includes(size)) {\n      throw new RangeError(`Invalid size provided: ${size}\nMust be one of: ${ALLOWED_SIZES.join(\", \")}`);\n    }\n    const url = new import_node_url.URL(`${this.base}${route}.${extension}`);\n    if (size) {\n      url.searchParams.set(\"size\", String(size));\n    }\n    return url.toString();\n  }\n};\n__name(CDN, \"CDN\");\n\n// src/lib/errors/DiscordAPIError.ts\nfunction isErrorGroupWrapper(error) {\n  return Reflect.has(error, \"_errors\");\n}\n__name(isErrorGroupWrapper, \"isErrorGroupWrapper\");\nfunction isErrorResponse(error) {\n  return typeof Reflect.get(error, \"message\") === \"string\";\n}\n__name(isErrorResponse, \"isErrorResponse\");\nvar DiscordAPIError = class extends Error {\n  constructor(rawError, code, status, method, url, bodyData) {\n    super(DiscordAPIError.getMessage(rawError));\n    this.rawError = rawError;\n    this.code = code;\n    this.status = status;\n    this.method = method;\n    this.url = url;\n    this.requestBody = {\n      files: bodyData.files,\n      json: bodyData.body\n    };\n  }\n  requestBody;\n  get name() {\n    return `${DiscordAPIError.name}[${this.code}]`;\n  }\n  static getMessage(error) {\n    let flattened = \"\";\n    if (\"code\" in error) {\n      if (error.errors) {\n        flattened = [...this.flattenDiscordError(error.errors)].join(\"\\n\");\n      }\n      return error.message && flattened ? `${error.message}\n${flattened}` : error.message || flattened || \"Unknown Error\";\n    }\n    return error.error_description ?? \"No Description\";\n  }\n  static flattenDiscordError(obj) {\n    var _this = this;\n    let key = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : \"\";\n    return function* () {\n      if (isErrorResponse(obj)) {\n        return yield `${key.length ? `${key}[${obj.code}]` : `${obj.code}`}: ${obj.message}`.trim();\n      }\n      for (const [otherKey, val] of Object.entries(obj)) {\n        const nextKey = otherKey.startsWith(\"_\") ? key : key ? Number.isNaN(Number(otherKey)) ? `${key}.${otherKey}` : `${key}[${otherKey}]` : otherKey;\n        if (typeof val === \"string\") {\n          yield val;\n        } else if (isErrorGroupWrapper(val)) {\n          for (const error of val._errors) {\n            yield* _this.flattenDiscordError(error, nextKey);\n          }\n        } else {\n          yield* _this.flattenDiscordError(val, nextKey);\n        }\n      }\n    }();\n  }\n};\n__name(DiscordAPIError, \"DiscordAPIError\");\n\n// src/lib/errors/HTTPError.ts\nvar import_node_http = require(\"http\");\nvar HTTPError = class extends Error {\n  constructor(status, method, url, bodyData) {\n    super(import_node_http.STATUS_CODES[status]);\n    this.status = status;\n    this.method = method;\n    this.url = url;\n    this.requestBody = {\n      files: bodyData.files,\n      json: bodyData.body\n    };\n  }\n  requestBody;\n  name = HTTPError.name;\n};\n__name(HTTPError, \"HTTPError\");\n\n// src/lib/errors/RateLimitError.ts\nvar RateLimitError = class extends Error {\n  timeToReset;\n  limit;\n  method;\n  hash;\n  url;\n  route;\n  majorParameter;\n  global;\n  constructor(_ref) {\n    let {\n      timeToReset,\n      limit,\n      method,\n      hash,\n      url,\n      route,\n      majorParameter,\n      global\n    } = _ref;\n    super();\n    this.timeToReset = timeToReset;\n    this.limit = limit;\n    this.method = method;\n    this.hash = hash;\n    this.url = url;\n    this.route = route;\n    this.majorParameter = majorParameter;\n    this.global = global;\n  }\n  get name() {\n    return `${RateLimitError.name}[${this.route}]`;\n  }\n};\n__name(RateLimitError, \"RateLimitError\");\n\n// src/lib/RequestManager.ts\nvar import_node_buffer2 = require(\"buffer\");\nvar import_node_events = require(\"events\");\nvar import_node_timers2 = require(\"timers\");\nvar import_collection = require(\"@discordjs/collection\");\nvar import_util = require(\"@discordjs/util\");\nvar import_snowflake = require(\"@sapphire/snowflake\");\nvar import_undici4 = require(\"undici\");\n\n// src/lib/handlers/SequentialHandler.ts\nvar import_node_timers = require(\"timers\");\nvar import_promises = require(\"timers/promises\");\nvar import_async_queue = require(\"@sapphire/async-queue\");\nvar import_undici3 = require(\"undici\");\n\n// src/lib/utils/utils.ts\nvar import_node_buffer = require(\"buffer\");\nvar import_node_url2 = require(\"url\");\nvar import_node_util = require(\"util\");\nvar import_undici2 = require(\"undici\");\nfunction parseHeader(header) {\n  if (header === void 0 || typeof header === \"string\") {\n    return header;\n  }\n  return header.join(\";\");\n}\n__name(parseHeader, \"parseHeader\");\nfunction serializeSearchParam(value) {\n  switch (typeof value) {\n    case \"string\":\n      return value;\n    case \"number\":\n    case \"bigint\":\n    case \"boolean\":\n      return value.toString();\n    case \"object\":\n      if (value === null) return null;\n      if (value instanceof Date) {\n        return Number.isNaN(value.getTime()) ? null : value.toISOString();\n      }\n      if (typeof value.toString === \"function\" && value.toString !== Object.prototype.toString) return value.toString();\n      return null;\n    default:\n      return null;\n  }\n}\n__name(serializeSearchParam, \"serializeSearchParam\");\nfunction makeURLSearchParams(options) {\n  const params = new import_node_url2.URLSearchParams();\n  if (!options) return params;\n  for (const [key, value] of Object.entries(options)) {\n    const serialized = serializeSearchParam(value);\n    if (serialized !== null) params.append(key, serialized);\n  }\n  return params;\n}\n__name(makeURLSearchParams, \"makeURLSearchParams\");\nasync function parseResponse(res) {\n  const header = parseHeader(res.headers[\"content-type\"]);\n  if (header?.startsWith(\"application/json\")) {\n    return res.body.json();\n  }\n  return res.body.arrayBuffer();\n}\n__name(parseResponse, \"parseResponse\");\nfunction hasSublimit(bucketRoute, body, method) {\n  if (bucketRoute === \"/channels/:id\") {\n    if (typeof body !== \"object\" || body === null) return false;\n    if (method !== \"PATCH\" /* Patch */) return false;\n    const castedBody = body;\n    return [\"name\", \"topic\"].some(key => Reflect.has(castedBody, key));\n  }\n  return true;\n}\n__name(hasSublimit, \"hasSublimit\");\nasync function resolveBody(body) {\n  if (body == null) {\n    return null;\n  } else if (typeof body === \"string\") {\n    return body;\n  } else if (import_node_util.types.isUint8Array(body)) {\n    return body;\n  } else if (import_node_util.types.isArrayBuffer(body)) {\n    return new Uint8Array(body);\n  } else if (body instanceof import_node_url2.URLSearchParams) {\n    return body.toString();\n  } else if (body instanceof DataView) {\n    return new Uint8Array(body.buffer);\n  } else if (body instanceof import_node_buffer.Blob) {\n    return new Uint8Array(await body.arrayBuffer());\n  } else if (body instanceof import_undici2.FormData) {\n    return body;\n  } else if (body[Symbol.iterator]) {\n    const chunks = [...body];\n    const length = chunks.reduce((a, b) => a + b.length, 0);\n    const uint8 = new Uint8Array(length);\n    let lengthUsed = 0;\n    return chunks.reduce((a, b) => {\n      a.set(b, lengthUsed);\n      lengthUsed += b.length;\n      return a;\n    }, uint8);\n  } else if (body[Symbol.asyncIterator]) {\n    const chunks = [];\n    for await (const chunk of body) {\n      chunks.push(chunk);\n    }\n    return import_node_buffer.Buffer.concat(chunks);\n  }\n  throw new TypeError(`Unable to resolve body.`);\n}\n__name(resolveBody, \"resolveBody\");\nfunction shouldRetry(error) {\n  if (error.name === \"AbortError\") return true;\n  return \"code\" in error && error.code === \"ECONNRESET\" || error.message.includes(\"ECONNRESET\");\n}\n__name(shouldRetry, \"shouldRetry\");\n\n// src/lib/handlers/SequentialHandler.ts\nvar invalidCount = 0;\nvar invalidCountResetTime = null;\nvar SequentialHandler = class {\n  constructor(manager, hash, majorParameter) {\n    this.manager = manager;\n    this.hash = hash;\n    this.majorParameter = majorParameter;\n    this.id = `${hash}:${majorParameter}`;\n  }\n  id;\n  reset = -1;\n  remaining = 1;\n  limit = Number.POSITIVE_INFINITY;\n  #asyncQueue = new import_async_queue.AsyncQueue();\n  #sublimitedQueue = null;\n  #sublimitPromise = null;\n  #shiftSublimit = false;\n  get inactive() {\n    return this.#asyncQueue.remaining === 0 && (this.#sublimitedQueue === null || this.#sublimitedQueue.remaining === 0) && !this.limited;\n  }\n  get globalLimited() {\n    return this.manager.globalRemaining <= 0 && Date.now() < this.manager.globalReset;\n  }\n  get localLimited() {\n    return this.remaining <= 0 && Date.now() < this.reset;\n  }\n  get limited() {\n    return this.globalLimited || this.localLimited;\n  }\n  get timeToReset() {\n    return this.reset + this.manager.options.offset - Date.now();\n  }\n  debug(message) {\n    this.manager.emit(\"restDebug\" /* Debug */, `[REST ${this.id}] ${message}`);\n  }\n  async globalDelayFor(time) {\n    await (0, import_promises.setTimeout)(time);\n    this.manager.globalDelay = null;\n  }\n  async onRateLimit(rateLimitData) {\n    const {\n      options\n    } = this.manager;\n    if (!options.rejectOnRateLimit) return;\n    const shouldThrow = typeof options.rejectOnRateLimit === \"function\" ? await options.rejectOnRateLimit(rateLimitData) : options.rejectOnRateLimit.some(route => rateLimitData.route.startsWith(route.toLowerCase()));\n    if (shouldThrow) {\n      throw new RateLimitError(rateLimitData);\n    }\n  }\n  async queueRequest(routeId, url, options, requestData) {\n    let queue = this.#asyncQueue;\n    let queueType = 0 /* Standard */;\n    if (this.#sublimitedQueue && hasSublimit(routeId.bucketRoute, requestData.body, options.method)) {\n      queue = this.#sublimitedQueue;\n      queueType = 1 /* Sublimit */;\n    }\n\n    await queue.wait({\n      signal: requestData.signal\n    });\n    if (queueType === 0 /* Standard */) {\n      if (this.#sublimitedQueue && hasSublimit(routeId.bucketRoute, requestData.body, options.method)) {\n        queue = this.#sublimitedQueue;\n        const wait = queue.wait();\n        this.#asyncQueue.shift();\n        await wait;\n      } else if (this.#sublimitPromise) {\n        await this.#sublimitPromise.promise;\n      }\n    }\n    try {\n      return await this.runRequest(routeId, url, options, requestData);\n    } finally {\n      queue.shift();\n      if (this.#shiftSublimit) {\n        this.#shiftSublimit = false;\n        this.#sublimitedQueue?.shift();\n      }\n      if (this.#sublimitedQueue?.remaining === 0) {\n        this.#sublimitPromise?.resolve();\n        this.#sublimitedQueue = null;\n      }\n    }\n  }\n  async runRequest(routeId, url, options, requestData) {\n    let retries = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : 0;\n    while (this.limited) {\n      const isGlobal = this.globalLimited;\n      let limit2;\n      let timeout2;\n      let delay;\n      if (isGlobal) {\n        limit2 = this.manager.options.globalRequestsPerSecond;\n        timeout2 = this.manager.globalReset + this.manager.options.offset - Date.now();\n        if (!this.manager.globalDelay) {\n          this.manager.globalDelay = this.globalDelayFor(timeout2);\n        }\n        delay = this.manager.globalDelay;\n      } else {\n        limit2 = this.limit;\n        timeout2 = this.timeToReset;\n        delay = (0, import_promises.setTimeout)(timeout2);\n      }\n      const rateLimitData = {\n        timeToReset: timeout2,\n        limit: limit2,\n        method: options.method ?? \"get\",\n        hash: this.hash,\n        url,\n        route: routeId.bucketRoute,\n        majorParameter: this.majorParameter,\n        global: isGlobal\n      };\n      this.manager.emit(\"rateLimited\" /* RateLimited */, rateLimitData);\n      await this.onRateLimit(rateLimitData);\n      if (isGlobal) {\n        this.debug(`Global rate limit hit, blocking all requests for ${timeout2}ms`);\n      } else {\n        this.debug(`Waiting ${timeout2}ms for rate limit to pass`);\n      }\n      await delay;\n    }\n    if (!this.manager.globalReset || this.manager.globalReset < Date.now()) {\n      this.manager.globalReset = Date.now() + 1e3;\n      this.manager.globalRemaining = this.manager.options.globalRequestsPerSecond;\n    }\n    this.manager.globalRemaining--;\n    const method = options.method ?? \"get\";\n    const controller = new AbortController();\n    const timeout = (0, import_node_timers.setTimeout)(() => controller.abort(), this.manager.options.timeout).unref();\n    if (requestData.signal) {\n      const signal = requestData.signal;\n      if (signal.aborted) controller.abort();else signal.addEventListener(\"abort\", () => controller.abort());\n    }\n    let res;\n    try {\n      res = await (0, import_undici3.request)(url, {\n        ...options,\n        signal: controller.signal\n      });\n    } catch (error) {\n      if (!(error instanceof Error)) throw error;\n      if (shouldRetry(error) && retries !== this.manager.options.retries) {\n        return await this.runRequest(routeId, url, options, requestData, ++retries);\n      }\n      throw error;\n    } finally {\n      (0, import_node_timers.clearTimeout)(timeout);\n    }\n    if (this.manager.listenerCount(\"response\" /* Response */)) {\n      this.manager.emit(\"response\" /* Response */, {\n        method,\n        path: routeId.original,\n        route: routeId.bucketRoute,\n        options,\n        data: requestData,\n        retries\n      }, {\n        ...res\n      });\n    }\n    const status = res.statusCode;\n    let retryAfter = 0;\n    const limit = parseHeader(res.headers[\"x-ratelimit-limit\"]);\n    const remaining = parseHeader(res.headers[\"x-ratelimit-remaining\"]);\n    const reset = parseHeader(res.headers[\"x-ratelimit-reset-after\"]);\n    const hash = parseHeader(res.headers[\"x-ratelimit-bucket\"]);\n    const retry = parseHeader(res.headers[\"retry-after\"]);\n    this.limit = limit ? Number(limit) : Number.POSITIVE_INFINITY;\n    this.remaining = remaining ? Number(remaining) : 1;\n    this.reset = reset ? Number(reset) * 1e3 + Date.now() + this.manager.options.offset : Date.now();\n    if (retry) retryAfter = Number(retry) * 1e3 + this.manager.options.offset;\n    if (hash && hash !== this.hash) {\n      this.debug([\"Received bucket hash update\", `  Old Hash  : ${this.hash}`, `  New Hash  : ${hash}`].join(\"\\n\"));\n      this.manager.hashes.set(`${method}:${routeId.bucketRoute}`, {\n        value: hash,\n        lastAccess: Date.now()\n      });\n    } else if (hash) {\n      const hashData = this.manager.hashes.get(`${method}:${routeId.bucketRoute}`);\n      if (hashData) {\n        hashData.lastAccess = Date.now();\n      }\n    }\n    let sublimitTimeout = null;\n    if (retryAfter > 0) {\n      if (res.headers[\"x-ratelimit-global\"] !== void 0) {\n        this.manager.globalRemaining = 0;\n        this.manager.globalReset = Date.now() + retryAfter;\n      } else if (!this.localLimited) {\n        sublimitTimeout = retryAfter;\n      }\n    }\n    if (status === 401 || status === 403 || status === 429) {\n      if (!invalidCountResetTime || invalidCountResetTime < Date.now()) {\n        invalidCountResetTime = Date.now() + 1e3 * 60 * 10;\n        invalidCount = 0;\n      }\n      invalidCount++;\n      const emitInvalid = this.manager.options.invalidRequestWarningInterval > 0 && invalidCount % this.manager.options.invalidRequestWarningInterval === 0;\n      if (emitInvalid) {\n        this.manager.emit(\"invalidRequestWarning\" /* InvalidRequestWarning */, {\n          count: invalidCount,\n          remainingTime: invalidCountResetTime - Date.now()\n        });\n      }\n    }\n    if (status >= 200 && status < 300) {\n      return res;\n    } else if (status === 429) {\n      const isGlobal = this.globalLimited;\n      let limit2;\n      let timeout2;\n      if (isGlobal) {\n        limit2 = this.manager.options.globalRequestsPerSecond;\n        timeout2 = this.manager.globalReset + this.manager.options.offset - Date.now();\n      } else {\n        limit2 = this.limit;\n        timeout2 = this.timeToReset;\n      }\n      await this.onRateLimit({\n        timeToReset: timeout2,\n        limit: limit2,\n        method,\n        hash: this.hash,\n        url,\n        route: routeId.bucketRoute,\n        majorParameter: this.majorParameter,\n        global: isGlobal\n      });\n      this.debug([\"Encountered unexpected 429 rate limit\", `  Global         : ${isGlobal.toString()}`, `  Method         : ${method}`, `  URL            : ${url}`, `  Bucket         : ${routeId.bucketRoute}`, `  Major parameter: ${routeId.majorParameter}`, `  Hash           : ${this.hash}`, `  Limit          : ${limit2}`, `  Retry After    : ${retryAfter}ms`, `  Sublimit       : ${sublimitTimeout ? `${sublimitTimeout}ms` : \"None\"}`].join(\"\\n\"));\n      if (sublimitTimeout) {\n        const firstSublimit = !this.#sublimitedQueue;\n        if (firstSublimit) {\n          this.#sublimitedQueue = new import_async_queue.AsyncQueue();\n          void this.#sublimitedQueue.wait();\n          this.#asyncQueue.shift();\n        }\n        this.#sublimitPromise?.resolve();\n        this.#sublimitPromise = null;\n        await (0, import_promises.setTimeout)(sublimitTimeout);\n        let resolve;\n        const promise = new Promise(res2 => resolve = res2);\n        this.#sublimitPromise = {\n          promise,\n          resolve\n        };\n        if (firstSublimit) {\n          await this.#asyncQueue.wait();\n          this.#shiftSublimit = true;\n        }\n      }\n      return this.runRequest(routeId, url, options, requestData, retries);\n    } else if (status >= 500 && status < 600) {\n      if (retries !== this.manager.options.retries) {\n        return this.runRequest(routeId, url, options, requestData, ++retries);\n      }\n      throw new HTTPError(status, method, url, requestData);\n    } else {\n      if (status >= 400 && status < 500) {\n        if (status === 401 && requestData.auth) {\n          this.manager.setToken(null);\n        }\n        const data = await parseResponse(res);\n        throw new DiscordAPIError(data, \"code\" in data ? data.code : data.error, status, method, url, requestData);\n      }\n      return res;\n    }\n  }\n};\n__name(SequentialHandler, \"SequentialHandler\");\n\n// src/lib/RequestManager.ts\nvar getFileType = (0, import_util.lazy)(async () => import(\"file-type\"));\nvar RequestMethod = /* @__PURE__ */(RequestMethod2 => {\n  RequestMethod2[\"Delete\"] = \"DELETE\";\n  RequestMethod2[\"Get\"] = \"GET\";\n  RequestMethod2[\"Patch\"] = \"PATCH\";\n  RequestMethod2[\"Post\"] = \"POST\";\n  RequestMethod2[\"Put\"] = \"PUT\";\n  return RequestMethod2;\n})(RequestMethod || {});\nvar RequestManager = class extends import_node_events.EventEmitter {\n  agent = null;\n  globalRemaining;\n  globalDelay = null;\n  globalReset = -1;\n  hashes = new import_collection.Collection();\n  handlers = new import_collection.Collection();\n  #token = null;\n  hashTimer;\n  handlerTimer;\n  options;\n  constructor(options) {\n    super();\n    this.options = {\n      ...DefaultRestOptions,\n      ...options\n    };\n    this.options.offset = Math.max(0, this.options.offset);\n    this.globalRemaining = this.options.globalRequestsPerSecond;\n    this.agent = options.agent ?? null;\n    this.setupSweepers();\n  }\n  setupSweepers() {\n    const validateMaxInterval = /* @__PURE__ */__name(interval => {\n      if (interval > 144e5) {\n        throw new Error(\"Cannot set an interval greater than 4 hours\");\n      }\n    }, \"validateMaxInterval\");\n    if (this.options.hashSweepInterval !== 0 && this.options.hashSweepInterval !== Number.POSITIVE_INFINITY) {\n      validateMaxInterval(this.options.hashSweepInterval);\n      this.hashTimer = (0, import_node_timers2.setInterval)(() => {\n        const sweptHashes = new import_collection.Collection();\n        const currentDate = Date.now();\n        this.hashes.sweep((val, key) => {\n          if (val.lastAccess === -1) return false;\n          const shouldSweep = Math.floor(currentDate - val.lastAccess) > this.options.hashLifetime;\n          if (shouldSweep) {\n            sweptHashes.set(key, val);\n          }\n          this.emit(\"restDebug\" /* Debug */, `Hash ${val.value} for ${key} swept due to lifetime being exceeded`);\n          return shouldSweep;\n        });\n        this.emit(\"hashSweep\" /* HashSweep */, sweptHashes);\n      }, this.options.hashSweepInterval).unref();\n    }\n    if (this.options.handlerSweepInterval !== 0 && this.options.handlerSweepInterval !== Number.POSITIVE_INFINITY) {\n      validateMaxInterval(this.options.handlerSweepInterval);\n      this.handlerTimer = (0, import_node_timers2.setInterval)(() => {\n        const sweptHandlers = new import_collection.Collection();\n        this.handlers.sweep((val, key) => {\n          const {\n            inactive\n          } = val;\n          if (inactive) {\n            sweptHandlers.set(key, val);\n          }\n          this.emit(\"restDebug\" /* Debug */, `Handler ${val.id} for ${key} swept due to being inactive`);\n          return inactive;\n        });\n        this.emit(\"handlerSweep\" /* HandlerSweep */, sweptHandlers);\n      }, this.options.handlerSweepInterval).unref();\n    }\n  }\n  setAgent(agent) {\n    this.agent = agent;\n    return this;\n  }\n  setToken(token) {\n    this.#token = token;\n    return this;\n  }\n  async queueRequest(request2) {\n    const routeId = RequestManager.generateRouteData(request2.fullRoute, request2.method);\n    const hash = this.hashes.get(`${request2.method}:${routeId.bucketRoute}`) ?? {\n      value: `Global(${request2.method}:${routeId.bucketRoute})`,\n      lastAccess: -1\n    };\n    const handler = this.handlers.get(`${hash.value}:${routeId.majorParameter}`) ?? this.createHandler(hash.value, routeId.majorParameter);\n    const {\n      url,\n      fetchOptions\n    } = await this.resolveRequest(request2);\n    return handler.queueRequest(routeId, url, fetchOptions, {\n      body: request2.body,\n      files: request2.files,\n      auth: request2.auth !== false,\n      signal: request2.signal\n    });\n  }\n  createHandler(hash, majorParameter) {\n    const queue = new SequentialHandler(this, hash, majorParameter);\n    this.handlers.set(queue.id, queue);\n    return queue;\n  }\n  async resolveRequest(request2) {\n    const {\n      options\n    } = this;\n    let query = \"\";\n    if (request2.query) {\n      const resolvedQuery = request2.query.toString();\n      if (resolvedQuery !== \"\") {\n        query = `?${resolvedQuery}`;\n      }\n    }\n    const headers = {\n      ...this.options.headers,\n      \"User-Agent\": `${DefaultUserAgent} ${options.userAgentAppendix}`.trim()\n    };\n    if (request2.auth !== false) {\n      if (!this.#token) {\n        throw new Error(\"Expected token to be set for this request, but none was present\");\n      }\n      headers.Authorization = `${request2.authPrefix ?? this.options.authPrefix} ${this.#token}`;\n    }\n    if (request2.reason?.length) {\n      headers[\"X-Audit-Log-Reason\"] = encodeURIComponent(request2.reason);\n    }\n    const url = `${options.api}${request2.versioned === false ? \"\" : `/v${options.version}`}${request2.fullRoute}${query}`;\n    let finalBody;\n    let additionalHeaders = {};\n    if (request2.files?.length) {\n      const formData = new import_undici4.FormData();\n      for (const [index, file] of request2.files.entries()) {\n        const fileKey = file.key ?? `files[${index}]`;\n        if (import_node_buffer2.Buffer.isBuffer(file.data)) {\n          const {\n            fileTypeFromBuffer\n          } = await getFileType();\n          const contentType = file.contentType ?? (await fileTypeFromBuffer(file.data))?.mime;\n          formData.append(fileKey, new import_node_buffer2.Blob([file.data], {\n            type: contentType\n          }), file.name);\n        } else {\n          formData.append(fileKey, new import_node_buffer2.Blob([`${file.data}`], {\n            type: file.contentType\n          }), file.name);\n        }\n      }\n      if (request2.body != null) {\n        if (request2.appendToFormData) {\n          for (const [key, value] of Object.entries(request2.body)) {\n            formData.append(key, value);\n          }\n        } else {\n          formData.append(\"payload_json\", JSON.stringify(request2.body));\n        }\n      }\n      finalBody = formData;\n    } else if (request2.body != null) {\n      if (request2.passThroughBody) {\n        finalBody = request2.body;\n      } else {\n        finalBody = JSON.stringify(request2.body);\n        additionalHeaders = {\n          \"Content-Type\": \"application/json\"\n        };\n      }\n    }\n    finalBody = await resolveBody(finalBody);\n    const fetchOptions = {\n      headers: {\n        ...request2.headers,\n        ...additionalHeaders,\n        ...headers\n      },\n      method: request2.method.toUpperCase()\n    };\n    if (finalBody !== void 0) {\n      fetchOptions.body = finalBody;\n    }\n    fetchOptions.dispatcher = request2.dispatcher ?? this.agent ?? void 0;\n    return {\n      url,\n      fetchOptions\n    };\n  }\n  clearHashSweeper() {\n    (0, import_node_timers2.clearInterval)(this.hashTimer);\n  }\n  clearHandlerSweeper() {\n    (0, import_node_timers2.clearInterval)(this.handlerTimer);\n  }\n  static generateRouteData(endpoint, method) {\n    const majorIdMatch = /^\\/(?:channels|guilds|webhooks)\\/(\\d{16,19})/.exec(endpoint);\n    const majorId = majorIdMatch?.[1] ?? \"global\";\n    const baseRoute = endpoint.replaceAll(/\\d{16,19}/g, \":id\").replace(/\\/reactions\\/(.*)/, \"/reactions/:reaction\");\n    let exceptions = \"\";\n    if (method === \"DELETE\" /* Delete */ && baseRoute === \"/channels/:id/messages/:id\") {\n      const id = /\\d{16,19}$/.exec(endpoint)[0];\n      const timestamp = import_snowflake.DiscordSnowflake.timestampFrom(id);\n      if (Date.now() - timestamp > 1e3 * 60 * 60 * 24 * 14) {\n        exceptions += \"/Delete Old Message\";\n      }\n    }\n    return {\n      majorParameter: majorId,\n      bucketRoute: baseRoute + exceptions,\n      original: endpoint\n    };\n  }\n};\n__name(RequestManager, \"RequestManager\");\n\n// src/lib/REST.ts\nvar import_node_events2 = require(\"events\");\nvar REST = class extends import_node_events2.EventEmitter {\n  cdn;\n  requestManager;\n  constructor() {\n    let options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    super();\n    this.cdn = new CDN(options.cdn ?? DefaultRestOptions.cdn);\n    this.requestManager = new RequestManager(options).on(\"restDebug\" /* Debug */, this.emit.bind(this, \"restDebug\" /* Debug */)).on(\"rateLimited\" /* RateLimited */, this.emit.bind(this, \"rateLimited\" /* RateLimited */)).on(\"invalidRequestWarning\" /* InvalidRequestWarning */, this.emit.bind(this, \"invalidRequestWarning\" /* InvalidRequestWarning */)).on(\"hashSweep\" /* HashSweep */, this.emit.bind(this, \"hashSweep\" /* HashSweep */));\n    this.on(\"newListener\", (name, listener) => {\n      if (name === \"response\" /* Response */) this.requestManager.on(name, listener);\n    });\n    this.on(\"removeListener\", (name, listener) => {\n      if (name === \"response\" /* Response */) this.requestManager.off(name, listener);\n    });\n  }\n  getAgent() {\n    return this.requestManager.agent;\n  }\n  setAgent(agent) {\n    this.requestManager.setAgent(agent);\n    return this;\n  }\n  setToken(token) {\n    this.requestManager.setToken(token);\n    return this;\n  }\n  async get(fullRoute) {\n    let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    return this.request({\n      ...options,\n      fullRoute,\n      method: \"GET\" /* Get */\n    });\n  }\n\n  async delete(fullRoute) {\n    let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    return this.request({\n      ...options,\n      fullRoute,\n      method: \"DELETE\" /* Delete */\n    });\n  }\n\n  async post(fullRoute) {\n    let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    return this.request({\n      ...options,\n      fullRoute,\n      method: \"POST\" /* Post */\n    });\n  }\n\n  async put(fullRoute) {\n    let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    return this.request({\n      ...options,\n      fullRoute,\n      method: \"PUT\" /* Put */\n    });\n  }\n\n  async patch(fullRoute) {\n    let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    return this.request({\n      ...options,\n      fullRoute,\n      method: \"PATCH\" /* Patch */\n    });\n  }\n\n  async request(options) {\n    const response = await this.raw(options);\n    return parseResponse(response);\n  }\n  async raw(options) {\n    return this.requestManager.queueRequest(options);\n  }\n};\n__name(REST, \"REST\");\n\n// src/index.ts\nvar version = \"1.5.0\";\n// Annotate the CommonJS export names for ESM import in node:\n0 && (module.exports = {\n  ALLOWED_EXTENSIONS,\n  ALLOWED_SIZES,\n  ALLOWED_STICKER_EXTENSIONS,\n  CDN,\n  DefaultRestOptions,\n  DefaultUserAgent,\n  DiscordAPIError,\n  HTTPError,\n  REST,\n  RESTEvents,\n  RateLimitError,\n  RequestManager,\n  RequestMethod,\n  makeURLSearchParams,\n  parseResponse,\n  version\n});","map":{"version":3,"mappings":"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","names":["__export","ALLOWED_EXTENSIONS","ALLOWED_SIZES","ALLOWED_STICKER_EXTENSIONS","CDN","DefaultRestOptions","DefaultUserAgent","DiscordAPIError","HTTPError","REST","RESTEvents","RateLimitError","RequestManager","RequestMethod","makeURLSearchParams","parseResponse","version","module","require","__toESM","agent","import_undici","connect","timeout","api","authPrefix","cdn","headers","invalidRequestWarningInterval","globalRequestsPerSecond","offset","rejectOnRateLimit","retries","userAgentAppendix","import_node_process","import_v10","hashSweepInterval","hashLifetime","handlerSweepInterval","constructor","base","appAsset","clientId","assetHash","options","makeURL","appIcon","iconHash","avatar","id","avatarHash","dynamicMakeURL","banner","bannerHash","channelIcon","channelId","defaultAvatar","discriminator","extension","discoverySplash","guildId","splashHash","emoji","emojiId","guildMemberAvatar","userId","guildMemberBanner","icon","roleIcon","roleId","roleIconHash","splash","sticker","stickerId","allowedExtensions","stickerPackBanner","bannerId","teamIcon","teamId","guildScheduledEventCover","scheduledEventId","coverHash","route","hash","forceStatic","startsWith","size","String","toLowerCase","includes","RangeError","join","url","import_node_url","searchParams","set","toString","__name","isErrorGroupWrapper","error","Reflect","has","isErrorResponse","get","Error","rawError","code","status","method","bodyData","getMessage","requestBody","files","json","body","name","flattened","errors","flattenDiscordError","message","error_description","obj","key","length","trim","otherKey","val","Object","entries","nextKey","Number","isNaN","_errors","import_node_http","timeToReset","limit","majorParameter","global","parseHeader","header","serializeSearchParam","value","Date","getTime","toISOString","prototype","params","import_node_url2","serialized","append","res","arrayBuffer","hasSublimit","bucketRoute","castedBody","some","resolveBody","import_node_util","isUint8Array","isArrayBuffer","Uint8Array","DataView","buffer","import_node_buffer","import_undici2","Symbol","iterator","chunks","reduce","a","b","uint8","lengthUsed","asyncIterator","chunk","push","concat","TypeError","shouldRetry","invalidCount","invalidCountResetTime","SequentialHandler","manager","reset","remaining","POSITIVE_INFINITY","import_async_queue","inactive","limited","globalLimited","globalRemaining","now","globalReset","localLimited","debug","emit","globalDelayFor","time","import_promises","globalDelay","onRateLimit","rateLimitData","shouldThrow","queueRequest","routeId","requestData","queue","queueType","wait","signal","shift","promise","runRequest","resolve","isGlobal","delay","controller","AbortController","import_node_timers","abort","unref","aborted","addEventListener","import_undici3","listenerCount","path","original","data","statusCode","retryAfter","retry","hashes","lastAccess","hashData","sublimitTimeout","emitInvalid","count","remainingTime","firstSublimit","Promise","auth","setToken","getFileType","import_util","import_node_events","import_collection","handlers","hashTimer","handlerTimer","Math","max","setupSweepers","validateMaxInterval","interval","import_node_timers2","sweptHashes","currentDate","sweep","shouldSweep","floor","sweptHandlers","setAgent","token","request","generateRouteData","fullRoute","handler","createHandler","fetchOptions","resolveRequest","query","resolvedQuery","Authorization","reason","encodeURIComponent","versioned","finalBody","additionalHeaders","formData","import_undici4","index","file","fileKey","import_node_buffer2","isBuffer","fileTypeFromBuffer","contentType","mime","type","appendToFormData","JSON","stringify","passThroughBody","toUpperCase","dispatcher","clearHashSweeper","clearHandlerSweeper","endpoint","majorIdMatch","exec","majorId","baseRoute","replaceAll","replace","exceptions","timestamp","import_snowflake","timestampFrom","import_node_events2","requestManager","on","bind","listener","off","getAgent","delete","post","put","patch","response","raw"],"sources":["J:\\Coding\\Projekts\\Web\\JavaScript\\sillcode.tech\\node_modules\\@discordjs\\rest\\src\\index.ts","J:\\Coding\\Projekts\\Web\\JavaScript\\sillcode.tech\\node_modules\\@discordjs\\rest\\src\\lib\\CDN.ts","J:\\Coding\\Projekts\\Web\\JavaScript\\sillcode.tech\\node_modules\\@discordjs\\rest\\src\\lib\\utils\\constants.ts","J:\\Coding\\Projekts\\Web\\JavaScript\\sillcode.tech\\node_modules\\@discordjs\\rest\\src\\lib\\errors\\DiscordAPIError.ts","J:\\Coding\\Projekts\\Web\\JavaScript\\sillcode.tech\\node_modules\\@discordjs\\rest\\src\\lib\\errors\\HTTPError.ts","J:\\Coding\\Projekts\\Web\\JavaScript\\sillcode.tech\\node_modules\\@discordjs\\rest\\src\\lib\\errors\\RateLimitError.ts","J:\\Coding\\Projekts\\Web\\JavaScript\\sillcode.tech\\node_modules\\@discordjs\\rest\\src\\lib\\RequestManager.ts","J:\\Coding\\Projekts\\Web\\JavaScript\\sillcode.tech\\node_modules\\@discordjs\\rest\\src\\lib\\handlers\\SequentialHandler.ts","J:\\Coding\\Projekts\\Web\\JavaScript\\sillcode.tech\\node_modules\\@discordjs\\rest\\src\\lib\\utils\\utils.ts","J:\\Coding\\Projekts\\Web\\JavaScript\\sillcode.tech\\node_modules\\@discordjs\\rest\\src\\lib\\REST.ts"],"sourcesContent":["export * from './lib/CDN.js';\nexport * from './lib/errors/DiscordAPIError.js';\nexport * from './lib/errors/HTTPError.js';\nexport * from './lib/errors/RateLimitError.js';\nexport * from './lib/RequestManager.js';\nexport * from './lib/REST.js';\nexport * from './lib/utils/constants.js';\nexport { makeURLSearchParams, parseResponse } from './lib/utils/utils.js';\n\n/**\n * The {@link https://github.com/discordjs/discord.js/blob/main/packages/rest/#readme | @discordjs/rest} version\n * that you are currently using.\n */\n// This needs to explicitly be `string` so it is not typed as a \"const string\" that gets injected by esbuild\n// eslint-disable-next-line @typescript-eslint/no-inferrable-types\nexport const version: string = '1.5.0';\n","/* eslint-disable jsdoc/check-param-names */\nimport { URL } from 'node:url';\nimport {\n\tALLOWED_EXTENSIONS,\n\tALLOWED_SIZES,\n\tALLOWED_STICKER_EXTENSIONS,\n\tDefaultRestOptions,\n\ttype ImageExtension,\n\ttype ImageSize,\n\ttype StickerExtension,\n} from './utils/constants.js';\n\n/**\n * The options used for image URLs\n */\nexport interface BaseImageURLOptions {\n\t/**\n\t * The extension to use for the image URL\n\t *\n\t * @defaultValue `'webp'`\n\t */\n\textension?: ImageExtension;\n\t/**\n\t * The size specified in the image URL\n\t */\n\tsize?: ImageSize;\n}\n\n/**\n * The options used for image URLs with animated content\n */\nexport interface ImageURLOptions extends BaseImageURLOptions {\n\t/**\n\t * Whether or not to prefer the static version of an image asset.\n\t */\n\tforceStatic?: boolean;\n}\n\n/**\n * The options to use when making a CDN URL\n */\nexport interface MakeURLOptions {\n\t/**\n\t * The allowed extensions that can be used\n\t */\n\tallowedExtensions?: readonly string[];\n\t/**\n\t * The extension to use for the image URL\n\t *\n\t * @defaultValue `'webp'`\n\t */\n\textension?: string | undefined;\n\t/**\n\t * The size specified in the image URL\n\t */\n\tsize?: ImageSize;\n}\n\n/**\n * The CDN link builder\n */\nexport class CDN {\n\tpublic constructor(private readonly base: string = DefaultRestOptions.cdn) {}\n\n\t/**\n\t * Generates an app asset URL for a client's asset.\n\t *\n\t * @param clientId - The client id that has the asset\n\t * @param assetHash - The hash provided by Discord for this asset\n\t * @param options - Optional options for the asset\n\t */\n\tpublic appAsset(clientId: string, assetHash: string, options?: Readonly<BaseImageURLOptions>): string {\n\t\treturn this.makeURL(`/app-assets/${clientId}/${assetHash}`, options);\n\t}\n\n\t/**\n\t * Generates an app icon URL for a client's icon.\n\t *\n\t * @param clientId - The client id that has the icon\n\t * @param iconHash - The hash provided by Discord for this icon\n\t * @param options - Optional options for the icon\n\t */\n\tpublic appIcon(clientId: string, iconHash: string, options?: Readonly<BaseImageURLOptions>): string {\n\t\treturn this.makeURL(`/app-icons/${clientId}/${iconHash}`, options);\n\t}\n\n\t/**\n\t * Generates an avatar URL, e.g. for a user or a webhook.\n\t *\n\t * @param id - The id that has the icon\n\t * @param avatarHash - The hash provided by Discord for this avatar\n\t * @param options - Optional options for the avatar\n\t */\n\tpublic avatar(id: string, avatarHash: string, options?: Readonly<ImageURLOptions>): string {\n\t\treturn this.dynamicMakeURL(`/avatars/${id}/${avatarHash}`, avatarHash, options);\n\t}\n\n\t/**\n\t * Generates a banner URL, e.g. for a user or a guild.\n\t *\n\t * @param id - The id that has the banner splash\n\t * @param bannerHash - The hash provided by Discord for this banner\n\t * @param options - Optional options for the banner\n\t */\n\tpublic banner(id: string, bannerHash: string, options?: Readonly<ImageURLOptions>): string {\n\t\treturn this.dynamicMakeURL(`/banners/${id}/${bannerHash}`, bannerHash, options);\n\t}\n\n\t/**\n\t * Generates an icon URL for a channel, e.g. a group DM.\n\t *\n\t * @param channelId - The channel id that has the icon\n\t * @param iconHash - The hash provided by Discord for this channel\n\t * @param options - Optional options for the icon\n\t */\n\tpublic channelIcon(channelId: string, iconHash: string, options?: Readonly<BaseImageURLOptions>): string {\n\t\treturn this.makeURL(`/channel-icons/${channelId}/${iconHash}`, options);\n\t}\n\n\t/**\n\t * Generates the default avatar URL for a discriminator.\n\t *\n\t * @param discriminator - The discriminator modulo 5\n\t */\n\tpublic defaultAvatar(discriminator: number): string {\n\t\treturn this.makeURL(`/embed/avatars/${discriminator}`, { extension: 'png' });\n\t}\n\n\t/**\n\t * Generates a discovery splash URL for a guild's discovery splash.\n\t *\n\t * @param guildId - The guild id that has the discovery splash\n\t * @param splashHash - The hash provided by Discord for this splash\n\t * @param options - Optional options for the splash\n\t */\n\tpublic discoverySplash(guildId: string, splashHash: string, options?: Readonly<BaseImageURLOptions>): string {\n\t\treturn this.makeURL(`/discovery-splashes/${guildId}/${splashHash}`, options);\n\t}\n\n\t/**\n\t * Generates an emoji's URL for an emoji.\n\t *\n\t * @param emojiId - The emoji id\n\t * @param extension - The extension of the emoji\n\t */\n\tpublic emoji(emojiId: string, extension?: ImageExtension): string {\n\t\treturn this.makeURL(`/emojis/${emojiId}`, { extension });\n\t}\n\n\t/**\n\t * Generates a guild member avatar URL.\n\t *\n\t * @param guildId - The id of the guild\n\t * @param userId - The id of the user\n\t * @param avatarHash - The hash provided by Discord for this avatar\n\t * @param options - Optional options for the avatar\n\t */\n\tpublic guildMemberAvatar(\n\t\tguildId: string,\n\t\tuserId: string,\n\t\tavatarHash: string,\n\t\toptions?: Readonly<ImageURLOptions>,\n\t): string {\n\t\treturn this.dynamicMakeURL(`/guilds/${guildId}/users/${userId}/avatars/${avatarHash}`, avatarHash, options);\n\t}\n\n\t/**\n\t * Generates a guild member banner URL.\n\t *\n\t * @param guildId - The id of the guild\n\t * @param userId - The id of the user\n\t * @param bannerHash - The hash provided by Discord for this banner\n\t * @param options - Optional options for the banner\n\t */\n\tpublic guildMemberBanner(\n\t\tguildId: string,\n\t\tuserId: string,\n\t\tbannerHash: string,\n\t\toptions?: Readonly<ImageURLOptions>,\n\t): string {\n\t\treturn this.dynamicMakeURL(`/guilds/${guildId}/users/${userId}/banner`, bannerHash, options);\n\t}\n\n\t/**\n\t * Generates an icon URL, e.g. for a guild.\n\t *\n\t * @param id - The id that has the icon splash\n\t * @param iconHash - The hash provided by Discord for this icon\n\t * @param options - Optional options for the icon\n\t */\n\tpublic icon(id: string, iconHash: string, options?: Readonly<ImageURLOptions>): string {\n\t\treturn this.dynamicMakeURL(`/icons/${id}/${iconHash}`, iconHash, options);\n\t}\n\n\t/**\n\t * Generates a URL for the icon of a role\n\t *\n\t * @param roleId - The id of the role that has the icon\n\t * @param roleIconHash - The hash provided by Discord for this role icon\n\t * @param options - Optional options for the role icon\n\t */\n\tpublic roleIcon(roleId: string, roleIconHash: string, options?: Readonly<BaseImageURLOptions>): string {\n\t\treturn this.makeURL(`/role-icons/${roleId}/${roleIconHash}`, options);\n\t}\n\n\t/**\n\t * Generates a guild invite splash URL for a guild's invite splash.\n\t *\n\t * @param guildId - The guild id that has the invite splash\n\t * @param splashHash - The hash provided by Discord for this splash\n\t * @param options - Optional options for the splash\n\t */\n\tpublic splash(guildId: string, splashHash: string, options?: Readonly<BaseImageURLOptions>): string {\n\t\treturn this.makeURL(`/splashes/${guildId}/${splashHash}`, options);\n\t}\n\n\t/**\n\t * Generates a sticker URL.\n\t *\n\t * @param stickerId - The sticker id\n\t * @param extension - The extension of the sticker\n\t */\n\tpublic sticker(stickerId: string, extension?: StickerExtension): string {\n\t\treturn this.makeURL(`/stickers/${stickerId}`, {\n\t\t\tallowedExtensions: ALLOWED_STICKER_EXTENSIONS,\n\t\t\textension: extension ?? 'png', // Stickers cannot have a `.webp` extension, so we default to a `.png`\n\t\t});\n\t}\n\n\t/**\n\t * Generates a sticker pack banner URL.\n\t *\n\t * @param bannerId - The banner id\n\t * @param options - Optional options for the banner\n\t */\n\tpublic stickerPackBanner(bannerId: string, options?: Readonly<BaseImageURLOptions>): string {\n\t\treturn this.makeURL(`/app-assets/710982414301790216/store/${bannerId}`, options);\n\t}\n\n\t/**\n\t * Generates a team icon URL for a team's icon.\n\t *\n\t * @param teamId - The team id that has the icon\n\t * @param iconHash - The hash provided by Discord for this icon\n\t * @param options - Optional options for the icon\n\t */\n\tpublic teamIcon(teamId: string, iconHash: string, options?: Readonly<BaseImageURLOptions>): string {\n\t\treturn this.makeURL(`/team-icons/${teamId}/${iconHash}`, options);\n\t}\n\n\t/**\n\t * Generates a cover image for a guild scheduled event.\n\t *\n\t * @param scheduledEventId - The scheduled event id\n\t * @param coverHash - The hash provided by discord for this cover image\n\t * @param options - Optional options for the cover image\n\t */\n\tpublic guildScheduledEventCover(\n\t\tscheduledEventId: string,\n\t\tcoverHash: string,\n\t\toptions?: Readonly<BaseImageURLOptions>,\n\t): string {\n\t\treturn this.makeURL(`/guild-events/${scheduledEventId}/${coverHash}`, options);\n\t}\n\n\t/**\n\t * Constructs the URL for the resource, checking whether or not `hash` starts with `a_` if `dynamic` is set to `true`.\n\t *\n\t * @param route - The base cdn route\n\t * @param hash - The hash provided by Discord for this icon\n\t * @param options - Optional options for the link\n\t */\n\tprivate dynamicMakeURL(\n\t\troute: string,\n\t\thash: string,\n\t\t{ forceStatic = false, ...options }: Readonly<ImageURLOptions> = {},\n\t): string {\n\t\treturn this.makeURL(route, !forceStatic && hash.startsWith('a_') ? { ...options, extension: 'gif' } : options);\n\t}\n\n\t/**\n\t * Constructs the URL for the resource\n\t *\n\t * @param route - The base cdn route\n\t * @param options - The extension/size options for the link\n\t */\n\tprivate makeURL(\n\t\troute: string,\n\t\t{ allowedExtensions = ALLOWED_EXTENSIONS, extension = 'webp', size }: Readonly<MakeURLOptions> = {},\n\t): string {\n\t\t// eslint-disable-next-line no-param-reassign\n\t\textension = String(extension).toLowerCase();\n\n\t\tif (!allowedExtensions.includes(extension)) {\n\t\t\tthrow new RangeError(`Invalid extension provided: ${extension}\\nMust be one of: ${allowedExtensions.join(', ')}`);\n\t\t}\n\n\t\tif (size && !ALLOWED_SIZES.includes(size)) {\n\t\t\tthrow new RangeError(`Invalid size provided: ${size}\\nMust be one of: ${ALLOWED_SIZES.join(', ')}`);\n\t\t}\n\n\t\tconst url = new URL(`${this.base}${route}.${extension}`);\n\n\t\tif (size) {\n\t\t\turl.searchParams.set('size', String(size));\n\t\t}\n\n\t\treturn url.toString();\n\t}\n}\n","import process from 'node:process';\nimport { APIVersion } from 'discord-api-types/v10';\nimport { Agent } from 'undici';\nimport type { RESTOptions } from '../REST.js';\n\nexport const DefaultUserAgent = `DiscordBot (https://discord.js.org, 1.5.0)`;\n\nexport const DefaultRestOptions = {\n\tget agent() {\n\t\treturn new Agent({\n\t\t\tconnect: {\n\t\t\t\ttimeout: 30_000,\n\t\t\t},\n\t\t});\n\t},\n\tapi: 'https://discord.com/api',\n\tauthPrefix: 'Bot',\n\tcdn: 'https://cdn.discordapp.com',\n\theaders: {},\n\tinvalidRequestWarningInterval: 0,\n\tglobalRequestsPerSecond: 50,\n\toffset: 50,\n\trejectOnRateLimit: null,\n\tretries: 3,\n\ttimeout: 15_000,\n\tuserAgentAppendix: `Node.js ${process.version}`,\n\tversion: APIVersion,\n\thashSweepInterval: 14_400_000, // 4 Hours\n\thashLifetime: 86_400_000, // 24 Hours\n\thandlerSweepInterval: 3_600_000, // 1 Hour\n} as const satisfies Required<RESTOptions>;\n\n/**\n * The events that the REST manager emits\n */\nexport const enum RESTEvents {\n\tDebug = 'restDebug',\n\tHandlerSweep = 'handlerSweep',\n\tHashSweep = 'hashSweep',\n\tInvalidRequestWarning = 'invalidRequestWarning',\n\tRateLimited = 'rateLimited',\n\tResponse = 'response',\n}\n\nexport const ALLOWED_EXTENSIONS = ['webp', 'png', 'jpg', 'jpeg', 'gif'] as const satisfies readonly string[];\nexport const ALLOWED_STICKER_EXTENSIONS = ['png', 'json'] as const satisfies readonly string[];\nexport const ALLOWED_SIZES = [16, 32, 64, 128, 256, 512, 1_024, 2_048, 4_096] as const satisfies readonly number[];\n\nexport type ImageExtension = typeof ALLOWED_EXTENSIONS[number];\nexport type StickerExtension = typeof ALLOWED_STICKER_EXTENSIONS[number];\nexport type ImageSize = typeof ALLOWED_SIZES[number];\n","import type { InternalRequest, RawFile } from '../RequestManager.js';\n\ninterface DiscordErrorFieldInformation {\n\tcode: string;\n\tmessage: string;\n}\n\ninterface DiscordErrorGroupWrapper {\n\t_errors: DiscordError[];\n}\n\ntype DiscordError = DiscordErrorFieldInformation | DiscordErrorGroupWrapper | string | { [k: string]: DiscordError };\n\nexport interface DiscordErrorData {\n\tcode: number;\n\terrors?: DiscordError;\n\tmessage: string;\n}\n\nexport interface OAuthErrorData {\n\terror: string;\n\terror_description?: string;\n}\n\nexport interface RequestBody {\n\tfiles: RawFile[] | undefined;\n\tjson: unknown | undefined;\n}\n\nfunction isErrorGroupWrapper(error: DiscordError): error is DiscordErrorGroupWrapper {\n\treturn Reflect.has(error as Record<string, unknown>, '_errors');\n}\n\nfunction isErrorResponse(error: DiscordError): error is DiscordErrorFieldInformation {\n\treturn typeof Reflect.get(error as Record<string, unknown>, 'message') === 'string';\n}\n\n/**\n * Represents an API error returned by Discord\n */\nexport class DiscordAPIError extends Error {\n\tpublic requestBody: RequestBody;\n\n\t/**\n\t * @param rawError - The error reported by Discord\n\t * @param code - The error code reported by Discord\n\t * @param status - The status code of the response\n\t * @param method - The method of the request that erred\n\t * @param url - The url of the request that erred\n\t * @param bodyData - The unparsed data for the request that errored\n\t */\n\tpublic constructor(\n\t\tpublic rawError: DiscordErrorData | OAuthErrorData,\n\t\tpublic code: number | string,\n\t\tpublic status: number,\n\t\tpublic method: string,\n\t\tpublic url: string,\n\t\tbodyData: Pick<InternalRequest, 'body' | 'files'>,\n\t) {\n\t\tsuper(DiscordAPIError.getMessage(rawError));\n\n\t\tthis.requestBody = { files: bodyData.files, json: bodyData.body };\n\t}\n\n\t/**\n\t * The name of the error\n\t */\n\tpublic override get name(): string {\n\t\treturn `${DiscordAPIError.name}[${this.code}]`;\n\t}\n\n\tprivate static getMessage(error: DiscordErrorData | OAuthErrorData) {\n\t\tlet flattened = '';\n\t\tif ('code' in error) {\n\t\t\tif (error.errors) {\n\t\t\t\tflattened = [...this.flattenDiscordError(error.errors)].join('\\n');\n\t\t\t}\n\n\t\t\treturn error.message && flattened\n\t\t\t\t? `${error.message}\\n${flattened}`\n\t\t\t\t: error.message || flattened || 'Unknown Error';\n\t\t}\n\n\t\treturn error.error_description ?? 'No Description';\n\t}\n\n\tprivate static *flattenDiscordError(obj: DiscordError, key = ''): IterableIterator<string> {\n\t\tif (isErrorResponse(obj)) {\n\t\t\treturn yield `${key.length ? `${key}[${obj.code}]` : `${obj.code}`}: ${obj.message}`.trim();\n\t\t}\n\n\t\tfor (const [otherKey, val] of Object.entries(obj)) {\n\t\t\tconst nextKey = otherKey.startsWith('_')\n\t\t\t\t? key\n\t\t\t\t: key\n\t\t\t\t? Number.isNaN(Number(otherKey))\n\t\t\t\t\t? `${key}.${otherKey}`\n\t\t\t\t\t: `${key}[${otherKey}]`\n\t\t\t\t: otherKey;\n\n\t\t\tif (typeof val === 'string') {\n\t\t\t\tyield val;\n\t\t\t} else if (isErrorGroupWrapper(val)) {\n\t\t\t\tfor (const error of val._errors) {\n\t\t\t\t\tyield* this.flattenDiscordError(error, nextKey);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tyield* this.flattenDiscordError(val, nextKey);\n\t\t\t}\n\t\t}\n\t}\n}\n","import { STATUS_CODES } from 'node:http';\nimport type { InternalRequest } from '../RequestManager.js';\nimport type { RequestBody } from './DiscordAPIError.js';\n\n/**\n * Represents a HTTP error\n */\nexport class HTTPError extends Error {\n\tpublic requestBody: RequestBody;\n\n\tpublic override name = HTTPError.name;\n\n\t/**\n\t * @param status - The status code of the response\n\t * @param method - The method of the request that erred\n\t * @param url - The url of the request that erred\n\t * @param bodyData - The unparsed data for the request that errored\n\t */\n\tpublic constructor(\n\t\tpublic status: number,\n\t\tpublic method: string,\n\t\tpublic url: string,\n\t\tbodyData: Pick<InternalRequest, 'body' | 'files'>,\n\t) {\n\t\tsuper(STATUS_CODES[status]);\n\n\t\tthis.requestBody = { files: bodyData.files, json: bodyData.body };\n\t}\n}\n","import type { RateLimitData } from '../REST';\n\nexport class RateLimitError extends Error implements RateLimitData {\n\tpublic timeToReset: number;\n\n\tpublic limit: number;\n\n\tpublic method: string;\n\n\tpublic hash: string;\n\n\tpublic url: string;\n\n\tpublic route: string;\n\n\tpublic majorParameter: string;\n\n\tpublic global: boolean;\n\n\tpublic constructor({ timeToReset, limit, method, hash, url, route, majorParameter, global }: RateLimitData) {\n\t\tsuper();\n\t\tthis.timeToReset = timeToReset;\n\t\tthis.limit = limit;\n\t\tthis.method = method;\n\t\tthis.hash = hash;\n\t\tthis.url = url;\n\t\tthis.route = route;\n\t\tthis.majorParameter = majorParameter;\n\t\tthis.global = global;\n\t}\n\n\t/**\n\t * The name of the error\n\t */\n\tpublic override get name(): string {\n\t\treturn `${RateLimitError.name}[${this.route}]`;\n\t}\n}\n","import { Blob, Buffer } from 'node:buffer';\nimport { EventEmitter } from 'node:events';\nimport { setInterval, clearInterval } from 'node:timers';\nimport type { URLSearchParams } from 'node:url';\nimport { Collection } from '@discordjs/collection';\nimport { lazy } from '@discordjs/util';\nimport { DiscordSnowflake } from '@sapphire/snowflake';\nimport { FormData, type RequestInit, type BodyInit, type Dispatcher, type Agent } from 'undici';\nimport type { RESTOptions, RestEvents, RequestOptions } from './REST.js';\nimport type { IHandler } from './handlers/IHandler.js';\nimport { SequentialHandler } from './handlers/SequentialHandler.js';\nimport { DefaultRestOptions, DefaultUserAgent, RESTEvents } from './utils/constants.js';\nimport { resolveBody } from './utils/utils.js';\n\n// Make this a lazy dynamic import as file-type is a pure ESM package\nconst getFileType = lazy(async () => import('file-type'));\n\n/**\n * Represents a file to be added to the request\n */\nexport interface RawFile {\n\t/**\n\t * Content-Type of the file\n\t */\n\tcontentType?: string;\n\t/**\n\t * The actual data for the file\n\t */\n\tdata: Buffer | boolean | number | string;\n\t/**\n\t * An explicit key to use for key of the formdata field for this file.\n\t * When not provided, the index of the file in the files array is used in the form `files[${index}]`.\n\t * If you wish to alter the placeholder snowflake, you must provide this property in the same form (`files[${placeholder}]`)\n\t */\n\tkey?: string;\n\t/**\n\t * The name of the file\n\t */\n\tname: string;\n}\n\n/**\n * Represents possible data to be given to an endpoint\n */\nexport interface RequestData {\n\t/**\n\t * Whether to append JSON data to form data instead of `payload_json` when sending files\n\t */\n\tappendToFormData?: boolean;\n\t/**\n\t * If this request needs the `Authorization` header\n\t *\n\t * @defaultValue `true`\n\t */\n\tauth?: boolean;\n\t/**\n\t * The authorization prefix to use for this request, useful if you use this with bearer tokens\n\t *\n\t * @defaultValue `'Bot'`\n\t */\n\tauthPrefix?: 'Bearer' | 'Bot';\n\t/**\n\t * The body to send to this request.\n\t * If providing as BodyInit, set `passThroughBody: true`\n\t */\n\tbody?: BodyInit | unknown;\n\t/**\n\t * The {@link https://undici.nodejs.org/#/docs/api/Agent | Agent} to use for the request.\n\t */\n\tdispatcher?: Agent;\n\t/**\n\t * Files to be attached to this request\n\t */\n\tfiles?: RawFile[] | undefined;\n\t/**\n\t * Additional headers to add to this request\n\t */\n\theaders?: Record<string, string>;\n\t/**\n\t * Whether to pass-through the body property directly to `fetch()`.\n\t * <warn>This only applies when files is NOT present</warn>\n\t */\n\tpassThroughBody?: boolean;\n\t/**\n\t * Query string parameters to append to the called endpoint\n\t */\n\tquery?: URLSearchParams;\n\t/**\n\t * Reason to show in the audit logs\n\t */\n\treason?: string | undefined;\n\t/**\n\t * The signal to abort the queue entry or the REST call, where applicable\n\t */\n\tsignal?: AbortSignal | undefined;\n\t/**\n\t * If this request should be versioned\n\t *\n\t * @defaultValue `true`\n\t */\n\tversioned?: boolean;\n}\n\n/**\n * Possible headers for an API call\n */\nexport interface RequestHeaders {\n\tAuthorization?: string;\n\t'User-Agent': string;\n\t'X-Audit-Log-Reason'?: string;\n}\n\n/**\n * Possible API methods to be used when doing requests\n */\nexport const enum RequestMethod {\n\tDelete = 'DELETE',\n\tGet = 'GET',\n\tPatch = 'PATCH',\n\tPost = 'POST',\n\tPut = 'PUT',\n}\n\nexport type RouteLike = `/${string}`;\n\n/**\n * Internal request options\n *\n * @internal\n */\nexport interface InternalRequest extends RequestData {\n\tfullRoute: RouteLike;\n\tmethod: RequestMethod;\n}\n\nexport type HandlerRequestData = Pick<InternalRequest, 'auth' | 'body' | 'files' | 'signal'>;\n\n/**\n * Parsed route data for an endpoint\n *\n * @internal\n */\nexport interface RouteData {\n\tbucketRoute: string;\n\tmajorParameter: string;\n\toriginal: RouteLike;\n}\n\n/**\n * Represents a hash and its associated fields\n *\n * @internal\n */\nexport interface HashData {\n\tlastAccess: number;\n\tvalue: string;\n}\n\nexport interface RequestManager {\n\temit: (<K extends keyof RestEvents>(event: K, ...args: RestEvents[K]) => boolean) &\n\t\t(<S extends string | symbol>(event: Exclude<S, keyof RestEvents>, ...args: any[]) => boolean);\n\n\toff: (<K extends keyof RestEvents>(event: K, listener: (...args: RestEvents[K]) => void) => this) &\n\t\t(<S extends string | symbol>(event: Exclude<S, keyof RestEvents>, listener: (...args: any[]) => void) => this);\n\n\ton: (<K extends keyof RestEvents>(event: K, listener: (...args: RestEvents[K]) => void) => this) &\n\t\t(<S extends string | symbol>(event: Exclude<S, keyof RestEvents>, listener: (...args: any[]) => void) => this);\n\n\tonce: (<K extends keyof RestEvents>(event: K, listener: (...args: RestEvents[K]) => void) => this) &\n\t\t(<S extends string | symbol>(event: Exclude<S, keyof RestEvents>, listener: (...args: any[]) => void) => this);\n\n\tremoveAllListeners: (<K extends keyof RestEvents>(event?: K) => this) &\n\t\t(<S extends string | symbol>(event?: Exclude<S, keyof RestEvents>) => this);\n}\n\n/**\n * Represents the class that manages handlers for endpoints\n */\nexport class RequestManager extends EventEmitter {\n\t/**\n\t * The {@link https://undici.nodejs.org/#/docs/api/Agent | Agent} for all requests\n\t * performed by this manager.\n\t */\n\tpublic agent: Dispatcher | null = null;\n\n\t/**\n\t * The number of requests remaining in the global bucket\n\t */\n\tpublic globalRemaining: number;\n\n\t/**\n\t * The promise used to wait out the global rate limit\n\t */\n\tpublic globalDelay: Promise<void> | null = null;\n\n\t/**\n\t * The timestamp at which the global bucket resets\n\t */\n\tpublic globalReset = -1;\n\n\t/**\n\t * API bucket hashes that are cached from provided routes\n\t */\n\tpublic readonly hashes = new Collection<string, HashData>();\n\n\t/**\n\t * Request handlers created from the bucket hash and the major parameters\n\t */\n\tpublic readonly handlers = new Collection<string, IHandler>();\n\n\t#token: string | null = null;\n\n\tprivate hashTimer!: NodeJS.Timer;\n\n\tprivate handlerTimer!: NodeJS.Timer;\n\n\tpublic readonly options: RESTOptions;\n\n\tpublic constructor(options: Partial<RESTOptions>) {\n\t\tsuper();\n\t\tthis.options = { ...DefaultRestOptions, ...options };\n\t\tthis.options.offset = Math.max(0, this.options.offset);\n\t\tthis.globalRemaining = this.options.globalRequestsPerSecond;\n\t\tthis.agent = options.agent ?? null;\n\n\t\t// Start sweepers\n\t\tthis.setupSweepers();\n\t}\n\n\tprivate setupSweepers() {\n\t\t// eslint-disable-next-line unicorn/consistent-function-scoping\n\t\tconst validateMaxInterval = (interval: number) => {\n\t\t\tif (interval > 14_400_000) {\n\t\t\t\tthrow new Error('Cannot set an interval greater than 4 hours');\n\t\t\t}\n\t\t};\n\n\t\tif (this.options.hashSweepInterval !== 0 && this.options.hashSweepInterval !== Number.POSITIVE_INFINITY) {\n\t\t\tvalidateMaxInterval(this.options.hashSweepInterval);\n\t\t\tthis.hashTimer = setInterval(() => {\n\t\t\t\tconst sweptHashes = new Collection<string, HashData>();\n\t\t\t\tconst currentDate = Date.now();\n\n\t\t\t\t// Begin sweeping hash based on lifetimes\n\t\t\t\tthis.hashes.sweep((val, key) => {\n\t\t\t\t\t// `-1` indicates a global hash\n\t\t\t\t\tif (val.lastAccess === -1) return false;\n\n\t\t\t\t\t// Check if lifetime has been exceeded\n\t\t\t\t\tconst shouldSweep = Math.floor(currentDate - val.lastAccess) > this.options.hashLifetime;\n\n\t\t\t\t\t// Add hash to collection of swept hashes\n\t\t\t\t\tif (shouldSweep) {\n\t\t\t\t\t\t// Add to swept hashes\n\t\t\t\t\t\tsweptHashes.set(key, val);\n\t\t\t\t\t}\n\n\t\t\t\t\t// Emit debug information\n\t\t\t\t\tthis.emit(RESTEvents.Debug, `Hash ${val.value} for ${key} swept due to lifetime being exceeded`);\n\n\t\t\t\t\treturn shouldSweep;\n\t\t\t\t});\n\n\t\t\t\t// Fire event\n\t\t\t\tthis.emit(RESTEvents.HashSweep, sweptHashes);\n\t\t\t}, this.options.hashSweepInterval).unref();\n\t\t}\n\n\t\tif (this.options.handlerSweepInterval !== 0 && this.options.handlerSweepInterval !== Number.POSITIVE_INFINITY) {\n\t\t\tvalidateMaxInterval(this.options.handlerSweepInterval);\n\t\t\tthis.handlerTimer = setInterval(() => {\n\t\t\t\tconst sweptHandlers = new Collection<string, IHandler>();\n\n\t\t\t\t// Begin sweeping handlers based on activity\n\t\t\t\tthis.handlers.sweep((val, key) => {\n\t\t\t\t\tconst { inactive } = val;\n\n\t\t\t\t\t// Collect inactive handlers\n\t\t\t\t\tif (inactive) {\n\t\t\t\t\t\tsweptHandlers.set(key, val);\n\t\t\t\t\t}\n\n\t\t\t\t\tthis.emit(RESTEvents.Debug, `Handler ${val.id} for ${key} swept due to being inactive`);\n\t\t\t\t\treturn inactive;\n\t\t\t\t});\n\n\t\t\t\t// Fire event\n\t\t\t\tthis.emit(RESTEvents.HandlerSweep, sweptHandlers);\n\t\t\t}, this.options.handlerSweepInterval).unref();\n\t\t}\n\t}\n\n\t/**\n\t * Sets the default agent to use for requests performed by this manager\n\t *\n\t * @param agent - The agent to use\n\t */\n\tpublic setAgent(agent: Dispatcher) {\n\t\tthis.agent = agent;\n\t\treturn this;\n\t}\n\n\t/**\n\t * Sets the authorization token that should be used for requests\n\t *\n\t * @param token - The authorization token to use\n\t */\n\tpublic setToken(token: string) {\n\t\tthis.#token = token;\n\t\treturn this;\n\t}\n\n\t/**\n\t * Queues a request to be sent\n\t *\n\t * @param request - All the information needed to make a request\n\t * @returns The response from the api request\n\t */\n\tpublic async queueRequest(request: InternalRequest): Promise<Dispatcher.ResponseData> {\n\t\t// Generalize the endpoint to its route data\n\t\tconst routeId = RequestManager.generateRouteData(request.fullRoute, request.method);\n\t\t// Get the bucket hash for the generic route, or point to a global route otherwise\n\t\tconst hash = this.hashes.get(`${request.method}:${routeId.bucketRoute}`) ?? {\n\t\t\tvalue: `Global(${request.method}:${routeId.bucketRoute})`,\n\t\t\tlastAccess: -1,\n\t\t};\n\n\t\t// Get the request handler for the obtained hash, with its major parameter\n\t\tconst handler =\n\t\t\tthis.handlers.get(`${hash.value}:${routeId.majorParameter}`) ??\n\t\t\tthis.createHandler(hash.value, routeId.majorParameter);\n\n\t\t// Resolve the request into usable fetch options\n\t\tconst { url, fetchOptions } = await this.resolveRequest(request);\n\n\t\t// Queue the request\n\t\treturn handler.queueRequest(routeId, url, fetchOptions, {\n\t\t\tbody: request.body,\n\t\t\tfiles: request.files,\n\t\t\tauth: request.auth !== false,\n\t\t\tsignal: request.signal,\n\t\t});\n\t}\n\n\t/**\n\t * Creates a new rate limit handler from a hash, based on the hash and the major parameter\n\t *\n\t * @param hash - The hash for the route\n\t * @param majorParameter - The major parameter for this handler\n\t * @internal\n\t */\n\tprivate createHandler(hash: string, majorParameter: string) {\n\t\t// Create the async request queue to handle requests\n\t\tconst queue = new SequentialHandler(this, hash, majorParameter);\n\t\t// Save the queue based on its id\n\t\tthis.handlers.set(queue.id, queue);\n\n\t\treturn queue;\n\t}\n\n\t/**\n\t * Formats the request data to a usable format for fetch\n\t *\n\t * @param request - The request data\n\t */\n\tprivate async resolveRequest(request: InternalRequest): Promise<{ fetchOptions: RequestOptions; url: string }> {\n\t\tconst { options } = this;\n\n\t\tlet query = '';\n\n\t\t// If a query option is passed, use it\n\t\tif (request.query) {\n\t\t\tconst resolvedQuery = request.query.toString();\n\t\t\tif (resolvedQuery !== '') {\n\t\t\t\tquery = `?${resolvedQuery}`;\n\t\t\t}\n\t\t}\n\n\t\t// Create the required headers\n\t\tconst headers: RequestHeaders = {\n\t\t\t...this.options.headers,\n\t\t\t'User-Agent': `${DefaultUserAgent} ${options.userAgentAppendix}`.trim(),\n\t\t};\n\n\t\t// If this request requires authorization (allowing non-\"authorized\" requests for webhooks)\n\t\tif (request.auth !== false) {\n\t\t\t// If we haven't received a token, throw an error\n\t\t\tif (!this.#token) {\n\t\t\t\tthrow new Error('Expected token to be set for this request, but none was present');\n\t\t\t}\n\n\t\t\theaders.Authorization = `${request.authPrefix ?? this.options.authPrefix} ${this.#token}`;\n\t\t}\n\n\t\t// If a reason was set, set it's appropriate header\n\t\tif (request.reason?.length) {\n\t\t\theaders['X-Audit-Log-Reason'] = encodeURIComponent(request.reason);\n\t\t}\n\n\t\t// Format the full request URL (api base, optional version, endpoint, optional querystring)\n\t\tconst url = `${options.api}${request.versioned === false ? '' : `/v${options.version}`}${\n\t\t\trequest.fullRoute\n\t\t}${query}`;\n\n\t\tlet finalBody: RequestInit['body'];\n\t\tlet additionalHeaders: Record<string, string> = {};\n\n\t\tif (request.files?.length) {\n\t\t\tconst formData = new FormData();\n\n\t\t\t// Attach all files to the request\n\t\t\tfor (const [index, file] of request.files.entries()) {\n\t\t\t\tconst fileKey = file.key ?? `files[${index}]`;\n\n\t\t\t\t// https://developer.mozilla.org/en-US/docs/Web/API/FormData/append#parameters\n\t\t\t\t// FormData.append only accepts a string or Blob.\n\t\t\t\t// https://developer.mozilla.org/en-US/docs/Web/API/Blob/Blob#parameters\n\t\t\t\t// The Blob constructor accepts TypedArray/ArrayBuffer, strings, and Blobs.\n\t\t\t\tif (Buffer.isBuffer(file.data)) {\n\t\t\t\t\t// Try to infer the content type from the buffer if one isn't passed\n\t\t\t\t\tconst { fileTypeFromBuffer } = await getFileType();\n\t\t\t\t\tconst contentType = file.contentType ?? (await fileTypeFromBuffer(file.data))?.mime;\n\t\t\t\t\tformData.append(fileKey, new Blob([file.data], { type: contentType }), file.name);\n\t\t\t\t} else {\n\t\t\t\t\tformData.append(fileKey, new Blob([`${file.data}`], { type: file.contentType }), file.name);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// If a JSON body was added as well, attach it to the form data, using payload_json unless otherwise specified\n\t\t\t// eslint-disable-next-line no-eq-null, eqeqeq\n\t\t\tif (request.body != null) {\n\t\t\t\tif (request.appendToFormData) {\n\t\t\t\t\tfor (const [key, value] of Object.entries(request.body as Record<string, unknown>)) {\n\t\t\t\t\t\tformData.append(key, value);\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tformData.append('payload_json', JSON.stringify(request.body));\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Set the final body to the form data\n\t\t\tfinalBody = formData;\n\n\t\t\t// eslint-disable-next-line no-eq-null, eqeqeq\n\t\t} else if (request.body != null) {\n\t\t\tif (request.passThroughBody) {\n\t\t\t\tfinalBody = request.body as BodyInit;\n\t\t\t} else {\n\t\t\t\t// Stringify the JSON data\n\t\t\t\tfinalBody = JSON.stringify(request.body);\n\t\t\t\t// Set the additional headers to specify the content-type\n\t\t\t\tadditionalHeaders = { 'Content-Type': 'application/json' };\n\t\t\t}\n\t\t}\n\n\t\tfinalBody = await resolveBody(finalBody);\n\n\t\tconst fetchOptions: RequestOptions = {\n\t\t\theaders: { ...request.headers, ...additionalHeaders, ...headers } as Record<string, string>,\n\t\t\tmethod: request.method.toUpperCase() as Dispatcher.HttpMethod,\n\t\t};\n\n\t\tif (finalBody !== undefined) {\n\t\t\tfetchOptions.body = finalBody as Exclude<RequestOptions['body'], undefined>;\n\t\t}\n\n\t\t// Prioritize setting an agent per request, use the agent for this instance otherwise.\n\t\tfetchOptions.dispatcher = request.dispatcher ?? this.agent ?? undefined!;\n\n\t\treturn { url, fetchOptions };\n\t}\n\n\t/**\n\t * Stops the hash sweeping interval\n\t */\n\tpublic clearHashSweeper() {\n\t\tclearInterval(this.hashTimer);\n\t}\n\n\t/**\n\t * Stops the request handler sweeping interval\n\t */\n\tpublic clearHandlerSweeper() {\n\t\tclearInterval(this.handlerTimer);\n\t}\n\n\t/**\n\t * Generates route data for an endpoint:method\n\t *\n\t * @param endpoint - The raw endpoint to generalize\n\t * @param method - The HTTP method this endpoint is called without\n\t * @internal\n\t */\n\tprivate static generateRouteData(endpoint: RouteLike, method: RequestMethod): RouteData {\n\t\tconst majorIdMatch = /^\\/(?:channels|guilds|webhooks)\\/(\\d{16,19})/.exec(endpoint);\n\n\t\t// Get the major id for this route - global otherwise\n\t\tconst majorId = majorIdMatch?.[1] ?? 'global';\n\n\t\tconst baseRoute = endpoint\n\t\t\t// Strip out all ids\n\t\t\t.replaceAll(/\\d{16,19}/g, ':id')\n\t\t\t// Strip out reaction as they fall under the same bucket\n\t\t\t.replace(/\\/reactions\\/(.*)/, '/reactions/:reaction');\n\n\t\tlet exceptions = '';\n\n\t\t// Hard-Code Old Message Deletion Exception (2 week+ old messages are a different bucket)\n\t\t// https://github.com/discord/discord-api-docs/issues/1295\n\t\tif (method === RequestMethod.Delete && baseRoute === '/channels/:id/messages/:id') {\n\t\t\tconst id = /\\d{16,19}$/.exec(endpoint)![0]!;\n\t\t\tconst timestamp = DiscordSnowflake.timestampFrom(id);\n\t\t\tif (Date.now() - timestamp > 1_000 * 60 * 60 * 24 * 14) {\n\t\t\t\texceptions += '/Delete Old Message';\n\t\t\t}\n\t\t}\n\n\t\treturn {\n\t\t\tmajorParameter: majorId,\n\t\t\tbucketRoute: baseRoute + exceptions,\n\t\t\toriginal: endpoint,\n\t\t};\n\t}\n}\n","import { setTimeout, clearTimeout } from 'node:timers';\nimport { setTimeout as sleep } from 'node:timers/promises';\nimport { AsyncQueue } from '@sapphire/async-queue';\nimport { request, type Dispatcher } from 'undici';\nimport type { RateLimitData, RequestOptions } from '../REST';\nimport type { HandlerRequestData, RequestManager, RouteData } from '../RequestManager';\nimport { DiscordAPIError, type DiscordErrorData, type OAuthErrorData } from '../errors/DiscordAPIError.js';\nimport { HTTPError } from '../errors/HTTPError.js';\nimport { RateLimitError } from '../errors/RateLimitError.js';\nimport { RESTEvents } from '../utils/constants.js';\nimport { hasSublimit, parseHeader, parseResponse, shouldRetry } from '../utils/utils.js';\nimport type { IHandler } from './IHandler.js';\n\n/**\n * Invalid request limiting is done on a per-IP basis, not a per-token basis.\n * The best we can do is track invalid counts process-wide (on the theory that\n * users could have multiple bots run from one process) rather than per-bot.\n * Therefore, store these at file scope here rather than in the client's\n * RESTManager object.\n */\nlet invalidCount = 0;\nlet invalidCountResetTime: number | null = null;\n\nconst enum QueueType {\n\tStandard,\n\tSublimit,\n}\n\n/**\n * The structure used to handle requests for a given bucket\n */\nexport class SequentialHandler implements IHandler {\n\t/**\n\t * {@inheritDoc IHandler.id}\n\t */\n\tpublic readonly id: string;\n\n\t/**\n\t * The time this rate limit bucket will reset\n\t */\n\tprivate reset = -1;\n\n\t/**\n\t * The remaining requests that can be made before we are rate limited\n\t */\n\tprivate remaining = 1;\n\n\t/**\n\t * The total number of requests that can be made before we are rate limited\n\t */\n\tprivate limit = Number.POSITIVE_INFINITY;\n\n\t/**\n\t * The interface used to sequence async requests sequentially\n\t */\n\t#asyncQueue = new AsyncQueue();\n\n\t/**\n\t * The interface used to sequence sublimited async requests sequentially\n\t */\n\t#sublimitedQueue: AsyncQueue | null = null;\n\n\t/**\n\t * A promise wrapper for when the sublimited queue is finished being processed or null when not being processed\n\t */\n\t#sublimitPromise: { promise: Promise<void>; resolve(): void } | null = null;\n\n\t/**\n\t * Whether the sublimit queue needs to be shifted in the finally block\n\t */\n\t#shiftSublimit = false;\n\n\t/**\n\t * @param manager - The request manager\n\t * @param hash - The hash that this RequestHandler handles\n\t * @param majorParameter - The major parameter for this handler\n\t */\n\tpublic constructor(\n\t\tprivate readonly manager: RequestManager,\n\t\tprivate readonly hash: string,\n\t\tprivate readonly majorParameter: string,\n\t) {\n\t\tthis.id = `${hash}:${majorParameter}`;\n\t}\n\n\t/**\n\t * {@inheritDoc IHandler.inactive}\n\t */\n\tpublic get inactive(): boolean {\n\t\treturn (\n\t\t\tthis.#asyncQueue.remaining === 0 &&\n\t\t\t(this.#sublimitedQueue === null || this.#sublimitedQueue.remaining === 0) &&\n\t\t\t!this.limited\n\t\t);\n\t}\n\n\t/**\n\t * If the rate limit bucket is currently limited by the global limit\n\t */\n\tprivate get globalLimited(): boolean {\n\t\treturn this.manager.globalRemaining <= 0 && Date.now() < this.manager.globalReset;\n\t}\n\n\t/**\n\t * If the rate limit bucket is currently limited by its limit\n\t */\n\tprivate get localLimited(): boolean {\n\t\treturn this.remaining <= 0 && Date.now() < this.reset;\n\t}\n\n\t/**\n\t * If the rate limit bucket is currently limited\n\t */\n\tprivate get limited(): boolean {\n\t\treturn this.globalLimited || this.localLimited;\n\t}\n\n\t/**\n\t * The time until queued requests can continue\n\t */\n\tprivate get timeToReset(): number {\n\t\treturn this.reset + this.manager.options.offset - Date.now();\n\t}\n\n\t/**\n\t * Emits a debug message\n\t *\n\t * @param message - The message to debug\n\t */\n\tprivate debug(message: string) {\n\t\tthis.manager.emit(RESTEvents.Debug, `[REST ${this.id}] ${message}`);\n\t}\n\n\t/**\n\t * Delay all requests for the specified amount of time, handling global rate limits\n\t *\n\t * @param time - The amount of time to delay all requests for\n\t */\n\tprivate async globalDelayFor(time: number): Promise<void> {\n\t\tawait sleep(time);\n\t\tthis.manager.globalDelay = null;\n\t}\n\n\t/*\n\t * Determines whether the request should be queued or whether a RateLimitError should be thrown\n\t */\n\tprivate async onRateLimit(rateLimitData: RateLimitData) {\n\t\tconst { options } = this.manager;\n\t\tif (!options.rejectOnRateLimit) return;\n\n\t\tconst shouldThrow =\n\t\t\ttypeof options.rejectOnRateLimit === 'function'\n\t\t\t\t? await options.rejectOnRateLimit(rateLimitData)\n\t\t\t\t: options.rejectOnRateLimit.some((route) => rateLimitData.route.startsWith(route.toLowerCase()));\n\t\tif (shouldThrow) {\n\t\t\tthrow new RateLimitError(rateLimitData);\n\t\t}\n\t}\n\n\t/**\n\t * {@inheritDoc IHandler.queueRequest}\n\t */\n\tpublic async queueRequest(\n\t\trouteId: RouteData,\n\t\turl: string,\n\t\toptions: RequestOptions,\n\t\trequestData: HandlerRequestData,\n\t): Promise<Dispatcher.ResponseData> {\n\t\tlet queue = this.#asyncQueue;\n\t\tlet queueType = QueueType.Standard;\n\t\t// Separate sublimited requests when already sublimited\n\t\tif (this.#sublimitedQueue && hasSublimit(routeId.bucketRoute, requestData.body, options.method)) {\n\t\t\tqueue = this.#sublimitedQueue!;\n\t\t\tqueueType = QueueType.Sublimit;\n\t\t}\n\n\t\t// Wait for any previous requests to be completed before this one is run\n\t\tawait queue.wait({ signal: requestData.signal });\n\t\t// This set handles retroactively sublimiting requests\n\t\tif (queueType === QueueType.Standard) {\n\t\t\tif (this.#sublimitedQueue && hasSublimit(routeId.bucketRoute, requestData.body, options.method)) {\n\t\t\t\t/**\n\t\t\t\t * Remove the request from the standard queue, it should never be possible to get here while processing the\n\t\t\t\t * sublimit queue so there is no need to worry about shifting the wrong request\n\t\t\t\t */\n\t\t\t\tqueue = this.#sublimitedQueue!;\n\t\t\t\tconst wait = queue.wait();\n\t\t\t\tthis.#asyncQueue.shift();\n\t\t\t\tawait wait;\n\t\t\t} else if (this.#sublimitPromise) {\n\t\t\t\t// Stall requests while the sublimit queue gets processed\n\t\t\t\tawait this.#sublimitPromise.promise;\n\t\t\t}\n\t\t}\n\n\t\ttry {\n\t\t\t// Make the request, and return the results\n\t\t\treturn await this.runRequest(routeId, url, options, requestData);\n\t\t} finally {\n\t\t\t// Allow the next request to fire\n\t\t\tqueue.shift();\n\t\t\tif (this.#shiftSublimit) {\n\t\t\t\tthis.#shiftSublimit = false;\n\t\t\t\tthis.#sublimitedQueue?.shift();\n\t\t\t}\n\n\t\t\t// If this request is the last request in a sublimit\n\t\t\tif (this.#sublimitedQueue?.remaining === 0) {\n\t\t\t\tthis.#sublimitPromise?.resolve();\n\t\t\t\tthis.#sublimitedQueue = null;\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * The method that actually makes the request to the api, and updates info about the bucket accordingly\n\t *\n\t * @param routeId - The generalized api route with literal ids for major parameters\n\t * @param url - The fully resolved url to make the request to\n\t * @param options - The fetch options needed to make the request\n\t * @param requestData - Extra data from the user's request needed for errors and additional processing\n\t * @param retries - The number of retries this request has already attempted (recursion)\n\t */\n\tprivate async runRequest(\n\t\trouteId: RouteData,\n\t\turl: string,\n\t\toptions: RequestOptions,\n\t\trequestData: HandlerRequestData,\n\t\tretries = 0,\n\t): Promise<Dispatcher.ResponseData> {\n\t\t/*\n\t\t * After calculations have been done, pre-emptively stop further requests\n\t\t * Potentially loop until this task can run if e.g. the global rate limit is hit twice\n\t\t */\n\t\twhile (this.limited) {\n\t\t\tconst isGlobal = this.globalLimited;\n\t\t\tlet limit: number;\n\t\t\tlet timeout: number;\n\t\t\tlet delay: Promise<void>;\n\n\t\t\tif (isGlobal) {\n\t\t\t\t// Set RateLimitData based on the global limit\n\t\t\t\tlimit = this.manager.options.globalRequestsPerSecond;\n\t\t\t\ttimeout = this.manager.globalReset + this.manager.options.offset - Date.now();\n\t\t\t\t// If this is the first task to reach the global timeout, set the global delay\n\t\t\t\tif (!this.manager.globalDelay) {\n\t\t\t\t\t// The global delay function clears the global delay state when it is resolved\n\t\t\t\t\tthis.manager.globalDelay = this.globalDelayFor(timeout);\n\t\t\t\t}\n\n\t\t\t\tdelay = this.manager.globalDelay;\n\t\t\t} else {\n\t\t\t\t// Set RateLimitData based on the route-specific limit\n\t\t\t\tlimit = this.limit;\n\t\t\t\ttimeout = this.timeToReset;\n\t\t\t\tdelay = sleep(timeout);\n\t\t\t}\n\n\t\t\tconst rateLimitData: RateLimitData = {\n\t\t\t\ttimeToReset: timeout,\n\t\t\t\tlimit,\n\t\t\t\tmethod: options.method ?? 'get',\n\t\t\t\thash: this.hash,\n\t\t\t\turl,\n\t\t\t\troute: routeId.bucketRoute,\n\t\t\t\tmajorParameter: this.majorParameter,\n\t\t\t\tglobal: isGlobal,\n\t\t\t};\n\t\t\t// Let library users know they have hit a rate limit\n\t\t\tthis.manager.emit(RESTEvents.RateLimited, rateLimitData);\n\t\t\t// Determine whether a RateLimitError should be thrown\n\t\t\tawait this.onRateLimit(rateLimitData);\n\t\t\t// When not erroring, emit debug for what is happening\n\t\t\tif (isGlobal) {\n\t\t\t\tthis.debug(`Global rate limit hit, blocking all requests for ${timeout}ms`);\n\t\t\t} else {\n\t\t\t\tthis.debug(`Waiting ${timeout}ms for rate limit to pass`);\n\t\t\t}\n\n\t\t\t// Wait the remaining time left before the rate limit resets\n\t\t\tawait delay;\n\t\t}\n\n\t\t// As the request goes out, update the global usage information\n\t\tif (!this.manager.globalReset || this.manager.globalReset < Date.now()) {\n\t\t\tthis.manager.globalReset = Date.now() + 1_000;\n\t\t\tthis.manager.globalRemaining = this.manager.options.globalRequestsPerSecond;\n\t\t}\n\n\t\tthis.manager.globalRemaining--;\n\n\t\tconst method = options.method ?? 'get';\n\n\t\tconst controller = new AbortController();\n\t\tconst timeout = setTimeout(() => controller.abort(), this.manager.options.timeout).unref();\n\t\tif (requestData.signal) {\n\t\t\t// The type polyfill is required because Node.js's types are incomplete.\n\t\t\tconst signal = requestData.signal as PolyFillAbortSignal;\n\t\t\t// If the user signal was aborted, abort the controller, else abort the local signal.\n\t\t\t// The reason why we don't re-use the user's signal, is because users may use the same signal for multiple\n\t\t\t// requests, and we do not want to cause unexpected side-effects.\n\t\t\tif (signal.aborted) controller.abort();\n\t\t\telse signal.addEventListener('abort', () => controller.abort());\n\t\t}\n\n\t\tlet res: Dispatcher.ResponseData;\n\t\ttry {\n\t\t\tres = await request(url, { ...options, signal: controller.signal });\n\t\t} catch (error: unknown) {\n\t\t\tif (!(error instanceof Error)) throw error;\n\t\t\t// Retry the specified number of times if needed\n\t\t\tif (shouldRetry(error) && retries !== this.manager.options.retries) {\n\t\t\t\t// eslint-disable-next-line no-param-reassign\n\t\t\t\treturn await this.runRequest(routeId, url, options, requestData, ++retries);\n\t\t\t}\n\n\t\t\tthrow error;\n\t\t} finally {\n\t\t\tclearTimeout(timeout);\n\t\t}\n\n\t\tif (this.manager.listenerCount(RESTEvents.Response)) {\n\t\t\tthis.manager.emit(\n\t\t\t\tRESTEvents.Response,\n\t\t\t\t{\n\t\t\t\t\tmethod,\n\t\t\t\t\tpath: routeId.original,\n\t\t\t\t\troute: routeId.bucketRoute,\n\t\t\t\t\toptions,\n\t\t\t\t\tdata: requestData,\n\t\t\t\t\tretries,\n\t\t\t\t},\n\t\t\t\t{ ...res },\n\t\t\t);\n\t\t}\n\n\t\tconst status = res.statusCode;\n\t\tlet retryAfter = 0;\n\n\t\tconst limit = parseHeader(res.headers['x-ratelimit-limit']);\n\t\tconst remaining = parseHeader(res.headers['x-ratelimit-remaining']);\n\t\tconst reset = parseHeader(res.headers['x-ratelimit-reset-after']);\n\t\tconst hash = parseHeader(res.headers['x-ratelimit-bucket']);\n\t\tconst retry = parseHeader(res.headers['retry-after']);\n\n\t\t// Update the total number of requests that can be made before the rate limit resets\n\t\tthis.limit = limit ? Number(limit) : Number.POSITIVE_INFINITY;\n\t\t// Update the number of remaining requests that can be made before the rate limit resets\n\t\tthis.remaining = remaining ? Number(remaining) : 1;\n\t\t// Update the time when this rate limit resets (reset-after is in seconds)\n\t\tthis.reset = reset ? Number(reset) * 1_000 + Date.now() + this.manager.options.offset : Date.now();\n\n\t\t// Amount of time in milliseconds until we should retry if rate limited (globally or otherwise)\n\t\tif (retry) retryAfter = Number(retry) * 1_000 + this.manager.options.offset;\n\n\t\t// Handle buckets via the hash header retroactively\n\t\tif (hash && hash !== this.hash) {\n\t\t\t// Let library users know when rate limit buckets have been updated\n\t\t\tthis.debug(['Received bucket hash update', `  Old Hash  : ${this.hash}`, `  New Hash  : ${hash}`].join('\\n'));\n\t\t\t// This queue will eventually be eliminated via attrition\n\t\t\tthis.manager.hashes.set(`${method}:${routeId.bucketRoute}`, { value: hash, lastAccess: Date.now() });\n\t\t} else if (hash) {\n\t\t\t// Handle the case where hash value doesn't change\n\t\t\t// Fetch the hash data from the manager\n\t\t\tconst hashData = this.manager.hashes.get(`${method}:${routeId.bucketRoute}`);\n\n\t\t\t// When fetched, update the last access of the hash\n\t\t\tif (hashData) {\n\t\t\t\thashData.lastAccess = Date.now();\n\t\t\t}\n\t\t}\n\n\t\t// Handle retryAfter, which means we have actually hit a rate limit\n\t\tlet sublimitTimeout: number | null = null;\n\t\tif (retryAfter > 0) {\n\t\t\tif (res.headers['x-ratelimit-global'] !== undefined) {\n\t\t\t\tthis.manager.globalRemaining = 0;\n\t\t\t\tthis.manager.globalReset = Date.now() + retryAfter;\n\t\t\t} else if (!this.localLimited) {\n\t\t\t\t/*\n\t\t\t\t * This is a sublimit (e.g. 2 channel name changes/10 minutes) since the headers don't indicate a\n\t\t\t\t * route-wide rate limit. Don't update remaining or reset to avoid rate limiting the whole\n\t\t\t\t * endpoint, just set a reset time on the request itself to avoid retrying too soon.\n\t\t\t\t */\n\t\t\t\tsublimitTimeout = retryAfter;\n\t\t\t}\n\t\t}\n\n\t\t// Count the invalid requests\n\t\tif (status === 401 || status === 403 || status === 429) {\n\t\t\tif (!invalidCountResetTime || invalidCountResetTime < Date.now()) {\n\t\t\t\tinvalidCountResetTime = Date.now() + 1_000 * 60 * 10;\n\t\t\t\tinvalidCount = 0;\n\t\t\t}\n\n\t\t\tinvalidCount++;\n\n\t\t\tconst emitInvalid =\n\t\t\t\tthis.manager.options.invalidRequestWarningInterval > 0 &&\n\t\t\t\tinvalidCount % this.manager.options.invalidRequestWarningInterval === 0;\n\t\t\tif (emitInvalid) {\n\t\t\t\t// Let library users know periodically about invalid requests\n\t\t\t\tthis.manager.emit(RESTEvents.InvalidRequestWarning, {\n\t\t\t\t\tcount: invalidCount,\n\t\t\t\t\tremainingTime: invalidCountResetTime - Date.now(),\n\t\t\t\t});\n\t\t\t}\n\t\t}\n\n\t\tif (status >= 200 && status < 300) {\n\t\t\treturn res;\n\t\t} else if (status === 429) {\n\t\t\t// A rate limit was hit - this may happen if the route isn't associated with an official bucket hash yet, or when first globally rate limited\n\t\t\tconst isGlobal = this.globalLimited;\n\t\t\tlet limit: number;\n\t\t\tlet timeout: number;\n\n\t\t\tif (isGlobal) {\n\t\t\t\t// Set RateLimitData based on the global limit\n\t\t\t\tlimit = this.manager.options.globalRequestsPerSecond;\n\t\t\t\ttimeout = this.manager.globalReset + this.manager.options.offset - Date.now();\n\t\t\t} else {\n\t\t\t\t// Set RateLimitData based on the route-specific limit\n\t\t\t\tlimit = this.limit;\n\t\t\t\ttimeout = this.timeToReset;\n\t\t\t}\n\n\t\t\tawait this.onRateLimit({\n\t\t\t\ttimeToReset: timeout,\n\t\t\t\tlimit,\n\t\t\t\tmethod,\n\t\t\t\thash: this.hash,\n\t\t\t\turl,\n\t\t\t\troute: routeId.bucketRoute,\n\t\t\t\tmajorParameter: this.majorParameter,\n\t\t\t\tglobal: isGlobal,\n\t\t\t});\n\t\t\tthis.debug(\n\t\t\t\t[\n\t\t\t\t\t'Encountered unexpected 429 rate limit',\n\t\t\t\t\t`  Global         : ${isGlobal.toString()}`,\n\t\t\t\t\t`  Method         : ${method}`,\n\t\t\t\t\t`  URL            : ${url}`,\n\t\t\t\t\t`  Bucket         : ${routeId.bucketRoute}`,\n\t\t\t\t\t`  Major parameter: ${routeId.majorParameter}`,\n\t\t\t\t\t`  Hash           : ${this.hash}`,\n\t\t\t\t\t`  Limit          : ${limit}`,\n\t\t\t\t\t`  Retry After    : ${retryAfter}ms`,\n\t\t\t\t\t`  Sublimit       : ${sublimitTimeout ? `${sublimitTimeout}ms` : 'None'}`,\n\t\t\t\t].join('\\n'),\n\t\t\t);\n\t\t\t// If caused by a sublimit, wait it out here so other requests on the route can be handled\n\t\t\tif (sublimitTimeout) {\n\t\t\t\t// Normally the sublimit queue will not exist, however, if a sublimit is hit while in the sublimit queue, it will\n\t\t\t\tconst firstSublimit = !this.#sublimitedQueue;\n\t\t\t\tif (firstSublimit) {\n\t\t\t\t\tthis.#sublimitedQueue = new AsyncQueue();\n\t\t\t\t\tvoid this.#sublimitedQueue.wait();\n\t\t\t\t\tthis.#asyncQueue.shift();\n\t\t\t\t}\n\n\t\t\t\tthis.#sublimitPromise?.resolve();\n\t\t\t\tthis.#sublimitPromise = null;\n\t\t\t\tawait sleep(sublimitTimeout);\n\t\t\t\tlet resolve: () => void;\n\t\t\t\t// eslint-disable-next-line promise/param-names, no-promise-executor-return\n\t\t\t\tconst promise = new Promise<void>((res) => (resolve = res));\n\t\t\t\tthis.#sublimitPromise = { promise, resolve: resolve! };\n\t\t\t\tif (firstSublimit) {\n\t\t\t\t\t// Re-queue this request so it can be shifted by the finally\n\t\t\t\t\tawait this.#asyncQueue.wait();\n\t\t\t\t\tthis.#shiftSublimit = true;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Since this is not a server side issue, the next request should pass, so we don't bump the retries counter\n\t\t\treturn this.runRequest(routeId, url, options, requestData, retries);\n\t\t} else if (status >= 500 && status < 600) {\n\t\t\t// Retry the specified number of times for possible server side issues\n\t\t\tif (retries !== this.manager.options.retries) {\n\t\t\t\t// eslint-disable-next-line no-param-reassign\n\t\t\t\treturn this.runRequest(routeId, url, options, requestData, ++retries);\n\t\t\t}\n\n\t\t\t// We are out of retries, throw an error\n\t\t\tthrow new HTTPError(status, method, url, requestData);\n\t\t} else {\n\t\t\t// Handle possible malformed requests\n\t\t\tif (status >= 400 && status < 500) {\n\t\t\t\t// If we receive this status code, it means the token we had is no longer valid.\n\t\t\t\tif (status === 401 && requestData.auth) {\n\t\t\t\t\tthis.manager.setToken(null!);\n\t\t\t\t}\n\n\t\t\t\t// The request will not succeed for some reason, parse the error returned from the api\n\t\t\t\tconst data = (await parseResponse(res)) as DiscordErrorData | OAuthErrorData;\n\t\t\t\t// throw the API error\n\t\t\t\tthrow new DiscordAPIError(data, 'code' in data ? data.code : data.error, status, method, url, requestData);\n\t\t\t}\n\n\t\t\treturn res;\n\t\t}\n\t}\n}\n\ninterface PolyFillAbortSignal {\n\treadonly aborted: boolean;\n\taddEventListener(type: 'abort', listener: () => void): void;\n\tremoveEventListener(type: 'abort', listener: () => void): void;\n}\n","import { Blob, Buffer } from 'node:buffer';\nimport { URLSearchParams } from 'node:url';\nimport { types } from 'node:util';\nimport type { RESTPatchAPIChannelJSONBody } from 'discord-api-types/v10';\nimport { FormData, type Dispatcher, type RequestInit } from 'undici';\nimport type { RequestOptions } from '../REST.js';\nimport { RequestMethod } from '../RequestManager.js';\n\nexport function parseHeader(header: string[] | string | undefined): string | undefined {\n\tif (header === undefined || typeof header === 'string') {\n\t\treturn header;\n\t}\n\n\treturn header.join(';');\n}\n\nfunction serializeSearchParam(value: unknown): string | null {\n\tswitch (typeof value) {\n\t\tcase 'string':\n\t\t\treturn value;\n\t\tcase 'number':\n\t\tcase 'bigint':\n\t\tcase 'boolean':\n\t\t\treturn value.toString();\n\t\tcase 'object':\n\t\t\tif (value === null) return null;\n\t\t\tif (value instanceof Date) {\n\t\t\t\treturn Number.isNaN(value.getTime()) ? null : value.toISOString();\n\t\t\t}\n\n\t\t\t// eslint-disable-next-line @typescript-eslint/no-base-to-string\n\t\t\tif (typeof value.toString === 'function' && value.toString !== Object.prototype.toString) return value.toString();\n\t\t\treturn null;\n\t\tdefault:\n\t\t\treturn null;\n\t}\n}\n\n/**\n * Creates and populates an URLSearchParams instance from an object, stripping\n * out null and undefined values, while also coercing non-strings to strings.\n *\n * @param options - The options to use\n * @returns A populated URLSearchParams instance\n */\nexport function makeURLSearchParams<T extends object>(options?: Readonly<T>) {\n\tconst params = new URLSearchParams();\n\tif (!options) return params;\n\n\tfor (const [key, value] of Object.entries(options)) {\n\t\tconst serialized = serializeSearchParam(value);\n\t\tif (serialized !== null) params.append(key, serialized);\n\t}\n\n\treturn params;\n}\n\n/**\n * Converts the response to usable data\n *\n * @param res - The fetch response\n */\nexport async function parseResponse(res: Dispatcher.ResponseData): Promise<unknown> {\n\tconst header = parseHeader(res.headers['content-type']);\n\tif (header?.startsWith('application/json')) {\n\t\treturn res.body.json();\n\t}\n\n\treturn res.body.arrayBuffer();\n}\n\n/**\n * Check whether a request falls under a sublimit\n *\n * @param bucketRoute - The buckets route identifier\n * @param body - The options provided as JSON data\n * @param method - The HTTP method that will be used to make the request\n * @returns Whether the request falls under a sublimit\n */\nexport function hasSublimit(bucketRoute: string, body?: unknown, method?: string): boolean {\n\t// TODO: Update for new sublimits\n\t// Currently known sublimits:\n\t// Editing channel `name` or `topic`\n\tif (bucketRoute === '/channels/:id') {\n\t\tif (typeof body !== 'object' || body === null) return false;\n\t\t// This should never be a POST body, but just in case\n\t\tif (method !== RequestMethod.Patch) return false;\n\t\tconst castedBody = body as RESTPatchAPIChannelJSONBody;\n\t\treturn ['name', 'topic'].some((key) => Reflect.has(castedBody, key));\n\t}\n\n\t// If we are checking if a request has a sublimit on a route not checked above, sublimit all requests to avoid a flood of 429s\n\treturn true;\n}\n\nexport async function resolveBody(body: RequestInit['body']): Promise<RequestOptions['body']> {\n\t// eslint-disable-next-line no-eq-null, eqeqeq\n\tif (body == null) {\n\t\treturn null;\n\t} else if (typeof body === 'string') {\n\t\treturn body;\n\t} else if (types.isUint8Array(body)) {\n\t\treturn body;\n\t} else if (types.isArrayBuffer(body)) {\n\t\treturn new Uint8Array(body);\n\t} else if (body instanceof URLSearchParams) {\n\t\treturn body.toString();\n\t} else if (body instanceof DataView) {\n\t\treturn new Uint8Array(body.buffer);\n\t} else if (body instanceof Blob) {\n\t\treturn new Uint8Array(await body.arrayBuffer());\n\t} else if (body instanceof FormData) {\n\t\treturn body;\n\t} else if ((body as Iterable<Uint8Array>)[Symbol.iterator]) {\n\t\tconst chunks = [...(body as Iterable<Uint8Array>)];\n\t\tconst length = chunks.reduce((a, b) => a + b.length, 0);\n\n\t\tconst uint8 = new Uint8Array(length);\n\t\tlet lengthUsed = 0;\n\n\t\treturn chunks.reduce((a, b) => {\n\t\t\ta.set(b, lengthUsed);\n\t\t\tlengthUsed += b.length;\n\t\t\treturn a;\n\t\t}, uint8);\n\t} else if ((body as AsyncIterable<Uint8Array>)[Symbol.asyncIterator]) {\n\t\tconst chunks: Uint8Array[] = [];\n\n\t\tfor await (const chunk of body as AsyncIterable<Uint8Array>) {\n\t\t\tchunks.push(chunk);\n\t\t}\n\n\t\treturn Buffer.concat(chunks);\n\t}\n\n\tthrow new TypeError(`Unable to resolve body.`);\n}\n\n/**\n * Check whether an error indicates that a retry can be attempted\n *\n * @param error - The error thrown by the network request\n * @returns Whether the error indicates a retry should be attempted\n */\nexport function shouldRetry(error: Error | NodeJS.ErrnoException) {\n\t// Retry for possible timed out requests\n\tif (error.name === 'AbortError') return true;\n\t// Downlevel ECONNRESET to retry as it may be recoverable\n\treturn ('code' in error && error.code === 'ECONNRESET') || error.message.includes('ECONNRESET');\n}\n","import { EventEmitter } from 'node:events';\nimport type { Collection } from '@discordjs/collection';\nimport type { request, Dispatcher } from 'undici';\nimport { CDN } from './CDN.js';\nimport {\n\tRequestManager,\n\tRequestMethod,\n\ttype HashData,\n\ttype HandlerRequestData,\n\ttype InternalRequest,\n\ttype RequestData,\n\ttype RouteLike,\n} from './RequestManager.js';\nimport type { IHandler } from './handlers/IHandler.js';\nimport { DefaultRestOptions, RESTEvents } from './utils/constants.js';\nimport { parseResponse } from './utils/utils.js';\n\n/**\n * Options to be passed when creating the REST instance\n */\nexport interface RESTOptions {\n\t/**\n\t * The agent to set globally\n\t */\n\tagent: Dispatcher;\n\t/**\n\t * The base api path, without version\n\t *\n\t * @defaultValue `'https://discord.com/api'`\n\t */\n\tapi: string;\n\t/**\n\t * The authorization prefix to use for requests, useful if you want to use\n\t * bearer tokens\n\t *\n\t * @defaultValue `'Bot'`\n\t */\n\tauthPrefix: 'Bearer' | 'Bot';\n\t/**\n\t * The cdn path\n\t *\n\t * @defaultValue 'https://cdn.discordapp.com'\n\t */\n\tcdn: string;\n\t/**\n\t * How many requests to allow sending per second (Infinity for unlimited, 50 for the standard global limit used by Discord)\n\t *\n\t * @defaultValue `50`\n\t */\n\tglobalRequestsPerSecond: number;\n\t/**\n\t * The amount of time in milliseconds that passes between each hash sweep. (defaults to 1h)\n\t *\n\t * @defaultValue `3_600_000`\n\t */\n\thandlerSweepInterval: number;\n\t/**\n\t * The maximum amount of time a hash can exist in milliseconds without being hit with a request (defaults to 24h)\n\t *\n\t * @defaultValue `86_400_000`\n\t */\n\thashLifetime: number;\n\t/**\n\t * The amount of time in milliseconds that passes between each hash sweep. (defaults to 4h)\n\t *\n\t * @defaultValue `14_400_000`\n\t */\n\thashSweepInterval: number;\n\t/**\n\t * Additional headers to send for all API requests\n\t *\n\t * @defaultValue `{}`\n\t */\n\theaders: Record<string, string>;\n\t/**\n\t * The number of invalid REST requests (those that return 401, 403, or 429) in a 10 minute window between emitted warnings (0 for no warnings).\n\t * That is, if set to 500, warnings will be emitted at invalid request number 500, 1000, 1500, and so on.\n\t *\n\t * @defaultValue `0`\n\t */\n\tinvalidRequestWarningInterval: number;\n\t/**\n\t * The extra offset to add to rate limits in milliseconds\n\t *\n\t * @defaultValue `50`\n\t */\n\toffset: number;\n\t/**\n\t * Determines how rate limiting and pre-emptive throttling should be handled.\n\t * When an array of strings, each element is treated as a prefix for the request route\n\t * (e.g. `/channels` to match any route starting with `/channels` such as `/channels/:id/messages`)\n\t * for which to throw {@link RateLimitError}s. All other request routes will be queued normally\n\t *\n\t * @defaultValue `null`\n\t */\n\trejectOnRateLimit: RateLimitQueueFilter | string[] | null;\n\t/**\n\t * The number of retries for errors with the 500 code, or errors\n\t * that timeout\n\t *\n\t * @defaultValue `3`\n\t */\n\tretries: number;\n\t/**\n\t * The time to wait in milliseconds before a request is aborted\n\t *\n\t * @defaultValue `15_000`\n\t */\n\ttimeout: number;\n\t/**\n\t * Extra information to add to the user agent\n\t *\n\t * @defaultValue `Node.js ${process.version}`\n\t */\n\tuserAgentAppendix: string;\n\t/**\n\t * The version of the API to use\n\t *\n\t * @defaultValue `'10'`\n\t */\n\tversion: string;\n}\n\n/**\n * Data emitted on `RESTEvents.RateLimited`\n */\nexport interface RateLimitData {\n\t/**\n\t * Whether the rate limit that was reached was the global limit\n\t */\n\tglobal: boolean;\n\t/**\n\t * The bucket hash for this request\n\t */\n\thash: string;\n\t/**\n\t * The amount of requests we can perform before locking requests\n\t */\n\tlimit: number;\n\t/**\n\t * The major parameter of the route\n\t *\n\t * For example, in `/channels/x`, this will be `x`.\n\t * If there is no major parameter (e.g: `/bot/gateway`) this will be `global`.\n\t */\n\tmajorParameter: string;\n\t/**\n\t * The HTTP method being performed\n\t */\n\tmethod: string;\n\t/**\n\t * The route being hit in this request\n\t */\n\troute: string;\n\t/**\n\t * The time, in milliseconds, until the request-lock is reset\n\t */\n\ttimeToReset: number;\n\t/**\n\t * The full URL for this request\n\t */\n\turl: string;\n}\n\n/**\n * A function that determines whether the rate limit hit should throw an Error\n */\nexport type RateLimitQueueFilter = (rateLimitData: RateLimitData) => Promise<boolean> | boolean;\n\nexport interface APIRequest {\n\t/**\n\t * The data that was used to form the body of this request\n\t */\n\tdata: HandlerRequestData;\n\t/**\n\t * The HTTP method used in this request\n\t */\n\tmethod: string;\n\t/**\n\t * Additional HTTP options for this request\n\t */\n\toptions: RequestOptions;\n\t/**\n\t * The full path used to make the request\n\t */\n\tpath: RouteLike;\n\t/**\n\t * The number of times this request has been attempted\n\t */\n\tretries: number;\n\t/**\n\t * The API route identifying the ratelimit for this request\n\t */\n\troute: string;\n}\n\nexport interface InvalidRequestWarningData {\n\t/**\n\t * Number of invalid requests that have been made in the window\n\t */\n\tcount: number;\n\t/**\n\t * Time in milliseconds remaining before the count resets\n\t */\n\tremainingTime: number;\n}\n\nexport interface RestEvents {\n\thandlerSweep: [sweptHandlers: Collection<string, IHandler>];\n\thashSweep: [sweptHashes: Collection<string, HashData>];\n\tinvalidRequestWarning: [invalidRequestInfo: InvalidRequestWarningData];\n\tnewListener: [name: string, listener: (...args: any) => void];\n\trateLimited: [rateLimitInfo: RateLimitData];\n\tremoveListener: [name: string, listener: (...args: any) => void];\n\tresponse: [request: APIRequest, response: Dispatcher.ResponseData];\n\trestDebug: [info: string];\n}\n\nexport interface REST {\n\temit: (<K extends keyof RestEvents>(event: K, ...args: RestEvents[K]) => boolean) &\n\t\t(<S extends string | symbol>(event: Exclude<S, keyof RestEvents>, ...args: any[]) => boolean);\n\n\toff: (<K extends keyof RestEvents>(event: K, listener: (...args: RestEvents[K]) => void) => this) &\n\t\t(<S extends string | symbol>(event: Exclude<S, keyof RestEvents>, listener: (...args: any[]) => void) => this);\n\n\ton: (<K extends keyof RestEvents>(event: K, listener: (...args: RestEvents[K]) => void) => this) &\n\t\t(<S extends string | symbol>(event: Exclude<S, keyof RestEvents>, listener: (...args: any[]) => void) => this);\n\n\tonce: (<K extends keyof RestEvents>(event: K, listener: (...args: RestEvents[K]) => void) => this) &\n\t\t(<S extends string | symbol>(event: Exclude<S, keyof RestEvents>, listener: (...args: any[]) => void) => this);\n\n\tremoveAllListeners: (<K extends keyof RestEvents>(event?: K) => this) &\n\t\t(<S extends string | symbol>(event?: Exclude<S, keyof RestEvents>) => this);\n}\n\nexport type RequestOptions = Exclude<Parameters<typeof request>[1], undefined>;\n\nexport class REST extends EventEmitter {\n\tpublic readonly cdn: CDN;\n\n\tpublic readonly requestManager: RequestManager;\n\n\tpublic constructor(options: Partial<RESTOptions> = {}) {\n\t\tsuper();\n\t\tthis.cdn = new CDN(options.cdn ?? DefaultRestOptions.cdn);\n\t\tthis.requestManager = new RequestManager(options)\n\t\t\t.on(RESTEvents.Debug, this.emit.bind(this, RESTEvents.Debug))\n\t\t\t.on(RESTEvents.RateLimited, this.emit.bind(this, RESTEvents.RateLimited))\n\t\t\t.on(RESTEvents.InvalidRequestWarning, this.emit.bind(this, RESTEvents.InvalidRequestWarning))\n\t\t\t.on(RESTEvents.HashSweep, this.emit.bind(this, RESTEvents.HashSweep));\n\n\t\tthis.on('newListener', (name, listener) => {\n\t\t\tif (name === RESTEvents.Response) this.requestManager.on(name, listener);\n\t\t});\n\t\tthis.on('removeListener', (name, listener) => {\n\t\t\tif (name === RESTEvents.Response) this.requestManager.off(name, listener);\n\t\t});\n\t}\n\n\t/**\n\t * Gets the agent set for this instance\n\t */\n\tpublic getAgent() {\n\t\treturn this.requestManager.agent;\n\t}\n\n\t/**\n\t * Sets the default agent to use for requests performed by this instance\n\t *\n\t * @param agent - Sets the agent to use\n\t */\n\tpublic setAgent(agent: Dispatcher) {\n\t\tthis.requestManager.setAgent(agent);\n\t\treturn this;\n\t}\n\n\t/**\n\t * Sets the authorization token that should be used for requests\n\t *\n\t * @param token - The authorization token to use\n\t */\n\tpublic setToken(token: string) {\n\t\tthis.requestManager.setToken(token);\n\t\treturn this;\n\t}\n\n\t/**\n\t * Runs a get request from the api\n\t *\n\t * @param fullRoute - The full route to query\n\t * @param options - Optional request options\n\t */\n\tpublic async get(fullRoute: RouteLike, options: RequestData = {}) {\n\t\treturn this.request({ ...options, fullRoute, method: RequestMethod.Get });\n\t}\n\n\t/**\n\t * Runs a delete request from the api\n\t *\n\t * @param fullRoute - The full route to query\n\t * @param options - Optional request options\n\t */\n\tpublic async delete(fullRoute: RouteLike, options: RequestData = {}) {\n\t\treturn this.request({ ...options, fullRoute, method: RequestMethod.Delete });\n\t}\n\n\t/**\n\t * Runs a post request from the api\n\t *\n\t * @param fullRoute - The full route to query\n\t * @param options - Optional request options\n\t */\n\tpublic async post(fullRoute: RouteLike, options: RequestData = {}) {\n\t\treturn this.request({ ...options, fullRoute, method: RequestMethod.Post });\n\t}\n\n\t/**\n\t * Runs a put request from the api\n\t *\n\t * @param fullRoute - The full route to query\n\t * @param options - Optional request options\n\t */\n\tpublic async put(fullRoute: RouteLike, options: RequestData = {}) {\n\t\treturn this.request({ ...options, fullRoute, method: RequestMethod.Put });\n\t}\n\n\t/**\n\t * Runs a patch request from the api\n\t *\n\t * @param fullRoute - The full route to query\n\t * @param options - Optional request options\n\t */\n\tpublic async patch(fullRoute: RouteLike, options: RequestData = {}) {\n\t\treturn this.request({ ...options, fullRoute, method: RequestMethod.Patch });\n\t}\n\n\t/**\n\t * Runs a request from the api\n\t *\n\t * @param options - Request options\n\t */\n\tpublic async request(options: InternalRequest) {\n\t\tconst response = await this.raw(options);\n\t\treturn parseResponse(response);\n\t}\n\n\t/**\n\t * Runs a request from the API, yielding the raw Response object\n\t *\n\t * @param options - Request options\n\t */\n\tpublic async raw(options: InternalRequest) {\n\t\treturn this.requestManager.queueRequest(options);\n\t}\n}\n"]},"metadata":{},"sourceType":"script","externalDependencies":[]}