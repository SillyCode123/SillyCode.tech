{"ast":null,"code":"'use strict';\n\nconst {\n  Collection\n} = require('@discordjs/collection');\nconst {\n  Routes\n} = require('discord-api-types/v10');\nconst CachedManager = require('./CachedManager');\nconst {\n  DiscordjsError,\n  ErrorCodes\n} = require('../errors');\nconst Invite = require('../structures/Invite');\nconst DataResolver = require('../util/DataResolver');\n\n/**\n * Manages API methods for GuildInvites and stores their cache.\n * @extends {CachedManager}\n */\nclass GuildInviteManager extends CachedManager {\n  constructor(guild, iterable) {\n    super(guild.client, Invite, iterable);\n\n    /**\n     * The guild this Manager belongs to\n     * @type {Guild}\n     */\n    this.guild = guild;\n  }\n\n  /**\n   * The cache of this Manager\n   * @type {Collection<string, Invite>}\n   * @name GuildInviteManager#cache\n   */\n\n  _add(data, cache) {\n    return super._add(data, cache, {\n      id: data.code,\n      extras: [this.guild]\n    });\n  }\n\n  /**\n   * Data that resolves to give an Invite object. This can be:\n   * * An invite code\n   * * An invite URL\n   * @typedef {string} InviteResolvable\n   */\n\n  /**\n   * Data that can be resolved to a channel that an invite can be created on. This can be:\n   * * TextChannel\n   * * VoiceChannel\n   * * NewsChannel\n   * * StageChannel\n   * * Snowflake\n   * @typedef {TextChannel|VoiceChannel|NewsChannel|StageChannel|Snowflake}\n   * GuildInvitableChannelResolvable\n   */\n\n  /**\n   * Resolves an InviteResolvable to an Invite object.\n   * @method resolve\n   * @memberof GuildInviteManager\n   * @instance\n   * @param {InviteResolvable} invite The invite resolvable to resolve\n   * @returns {?Invite}\n   */\n\n  /**\n   * Resolves an InviteResolvable to an invite code string.\n   * @method resolveId\n   * @memberof GuildInviteManager\n   * @instance\n   * @param {InviteResolvable} invite The invite resolvable to resolve\n   * @returns {?string}\n   */\n\n  /**\n   * Options used to fetch a single invite from a guild.\n   * @typedef {Object} FetchInviteOptions\n   * @property {InviteResolvable} code The invite to fetch\n   * @property {boolean} [cache=true] Whether or not to cache the fetched invite\n   * @property {boolean} [force=false] Whether to skip the cache check and request the API\n   */\n\n  /**\n   * Options used to fetch all invites from a guild.\n   * @typedef {Object} FetchInvitesOptions\n   * @property {GuildInvitableChannelResolvable} [channelId]\n   * The channel to fetch all invites from\n   * @property {boolean} [cache=true] Whether or not to cache the fetched invites\n   */\n\n  /**\n   * Fetches invite(s) from Discord.\n   * @param {InviteResolvable|FetchInviteOptions|FetchInvitesOptions} [options] Options for fetching guild invite(s)\n   * @returns {Promise<Invite|Collection<string, Invite>>}\n   * @example\n   * // Fetch all invites from a guild\n   * guild.invites.fetch()\n   *   .then(console.log)\n   *   .catch(console.error);\n   * @example\n   * // Fetch all invites from a guild without caching\n   * guild.invites.fetch({ cache: false })\n   *   .then(console.log)\n   *   .catch(console.error);\n   * @example\n   * // Fetch all invites from a channel\n   * guild.invites.fetch({ channelId: '222197033908436994' })\n   *   .then(console.log)\n   *   .catch(console.error);\n   * @example\n   * // Fetch a single invite\n   * guild.invites.fetch('bRCvFy9')\n   *   .then(console.log)\n   *   .catch(console.error);\n   * @example\n   * // Fetch a single invite without checking cache\n   * guild.invites.fetch({ code: 'bRCvFy9', force: true })\n   *   .then(console.log)\n   *   .catch(console.error)\n   * @example\n   * // Fetch a single invite without caching\n   * guild.invites.fetch({ code: 'bRCvFy9', cache: false })\n   *   .then(console.log)\n   *   .catch(console.error);\n   */\n  fetch(options) {\n    if (!options) return this._fetchMany();\n    if (typeof options === 'string') {\n      const code = DataResolver.resolveInviteCode(options);\n      if (!code) return Promise.reject(new DiscordjsError(ErrorCodes.InviteResolveCode));\n      return this._fetchSingle({\n        code,\n        cache: true\n      });\n    }\n    if (!options.code) {\n      if (options.channelId) {\n        const id = this.guild.channels.resolveId(options.channelId);\n        if (!id) return Promise.reject(new DiscordjsError(ErrorCodes.GuildChannelResolve));\n        return this._fetchChannelMany(id, options.cache);\n      }\n      if ('cache' in options) return this._fetchMany(options.cache);\n      return Promise.reject(new DiscordjsError(ErrorCodes.InviteResolveCode));\n    }\n    return this._fetchSingle({\n      ...options,\n      code: DataResolver.resolveInviteCode(options.code)\n    });\n  }\n  async _fetchSingle(_ref) {\n    let {\n      code,\n      cache,\n      force = false\n    } = _ref;\n    if (!force) {\n      const existing = this.cache.get(code);\n      if (existing) return existing;\n    }\n    const invites = await this._fetchMany(cache);\n    const invite = invites.get(code);\n    if (!invite) throw new DiscordjsError(ErrorCodes.InviteNotFound);\n    return invite;\n  }\n  async _fetchMany(cache) {\n    const data = await this.client.rest.get(Routes.guildInvites(this.guild.id));\n    return data.reduce((col, invite) => col.set(invite.code, this._add(invite, cache)), new Collection());\n  }\n  async _fetchChannelMany(channelId, cache) {\n    const data = await this.client.rest.get(Routes.channelInvites(channelId));\n    return data.reduce((col, invite) => col.set(invite.code, this._add(invite, cache)), new Collection());\n  }\n\n  /**\n   * Create an invite to the guild from the provided channel.\n   * @param {GuildInvitableChannelResolvable} channel The options for creating the invite from a channel.\n   * @param {CreateInviteOptions} [options={}] The options for creating the invite from a channel.\n   * @returns {Promise<Invite>}\n   * @example\n   * // Create an invite to a selected channel\n   * guild.invites.create('599942732013764608')\n   *   .then(console.log)\n   *   .catch(console.error);\n   */\n  async create(channel) {\n    let {\n      temporary,\n      maxAge,\n      maxUses,\n      unique,\n      targetUser,\n      targetApplication,\n      targetType,\n      reason\n    } = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    const id = this.guild.channels.resolveId(channel);\n    if (!id) throw new DiscordjsError(ErrorCodes.GuildChannelResolve);\n    const invite = await this.client.rest.post(Routes.channelInvites(id), {\n      body: {\n        temporary,\n        max_age: maxAge,\n        max_uses: maxUses,\n        unique,\n        target_user_id: this.client.users.resolveId(targetUser),\n        target_application_id: targetApplication?.id ?? targetApplication?.applicationId ?? targetApplication,\n        target_type: targetType\n      },\n      reason\n    });\n    return new Invite(this.client, invite);\n  }\n\n  /**\n   * Deletes an invite.\n   * @param {InviteResolvable} invite The invite to delete\n   * @param {string} [reason] Reason for deleting the invite\n   * @returns {Promise<void>}\n   */\n  async delete(invite, reason) {\n    const code = DataResolver.resolveInviteCode(invite);\n    await this.client.rest.delete(Routes.invite(code), {\n      reason\n    });\n  }\n}\nmodule.exports = GuildInviteManager;","map":{"version":3,"names":["Collection","require","Routes","CachedManager","DiscordjsError","ErrorCodes","Invite","DataResolver","GuildInviteManager","constructor","guild","iterable","client","_add","data","cache","id","code","extras","fetch","options","_fetchMany","resolveInviteCode","Promise","reject","InviteResolveCode","_fetchSingle","channelId","channels","resolveId","GuildChannelResolve","_fetchChannelMany","force","existing","get","invites","invite","InviteNotFound","rest","guildInvites","reduce","col","set","channelInvites","create","channel","temporary","maxAge","maxUses","unique","targetUser","targetApplication","targetType","reason","post","body","max_age","max_uses","target_user_id","users","target_application_id","applicationId","target_type","delete","module","exports"],"sources":["J:/Coding/Projekts/Web/JavaScript/sillcode.tech/node_modules/discord.js/src/managers/GuildInviteManager.js"],"sourcesContent":["'use strict';\n\nconst { Collection } = require('@discordjs/collection');\nconst { Routes } = require('discord-api-types/v10');\nconst CachedManager = require('./CachedManager');\nconst { DiscordjsError, ErrorCodes } = require('../errors');\nconst Invite = require('../structures/Invite');\nconst DataResolver = require('../util/DataResolver');\n\n/**\n * Manages API methods for GuildInvites and stores their cache.\n * @extends {CachedManager}\n */\nclass GuildInviteManager extends CachedManager {\n  constructor(guild, iterable) {\n    super(guild.client, Invite, iterable);\n\n    /**\n     * The guild this Manager belongs to\n     * @type {Guild}\n     */\n    this.guild = guild;\n  }\n\n  /**\n   * The cache of this Manager\n   * @type {Collection<string, Invite>}\n   * @name GuildInviteManager#cache\n   */\n\n  _add(data, cache) {\n    return super._add(data, cache, { id: data.code, extras: [this.guild] });\n  }\n\n  /**\n   * Data that resolves to give an Invite object. This can be:\n   * * An invite code\n   * * An invite URL\n   * @typedef {string} InviteResolvable\n   */\n\n  /**\n   * Data that can be resolved to a channel that an invite can be created on. This can be:\n   * * TextChannel\n   * * VoiceChannel\n   * * NewsChannel\n   * * StageChannel\n   * * Snowflake\n   * @typedef {TextChannel|VoiceChannel|NewsChannel|StageChannel|Snowflake}\n   * GuildInvitableChannelResolvable\n   */\n\n  /**\n   * Resolves an InviteResolvable to an Invite object.\n   * @method resolve\n   * @memberof GuildInviteManager\n   * @instance\n   * @param {InviteResolvable} invite The invite resolvable to resolve\n   * @returns {?Invite}\n   */\n\n  /**\n   * Resolves an InviteResolvable to an invite code string.\n   * @method resolveId\n   * @memberof GuildInviteManager\n   * @instance\n   * @param {InviteResolvable} invite The invite resolvable to resolve\n   * @returns {?string}\n   */\n\n  /**\n   * Options used to fetch a single invite from a guild.\n   * @typedef {Object} FetchInviteOptions\n   * @property {InviteResolvable} code The invite to fetch\n   * @property {boolean} [cache=true] Whether or not to cache the fetched invite\n   * @property {boolean} [force=false] Whether to skip the cache check and request the API\n   */\n\n  /**\n   * Options used to fetch all invites from a guild.\n   * @typedef {Object} FetchInvitesOptions\n   * @property {GuildInvitableChannelResolvable} [channelId]\n   * The channel to fetch all invites from\n   * @property {boolean} [cache=true] Whether or not to cache the fetched invites\n   */\n\n  /**\n   * Fetches invite(s) from Discord.\n   * @param {InviteResolvable|FetchInviteOptions|FetchInvitesOptions} [options] Options for fetching guild invite(s)\n   * @returns {Promise<Invite|Collection<string, Invite>>}\n   * @example\n   * // Fetch all invites from a guild\n   * guild.invites.fetch()\n   *   .then(console.log)\n   *   .catch(console.error);\n   * @example\n   * // Fetch all invites from a guild without caching\n   * guild.invites.fetch({ cache: false })\n   *   .then(console.log)\n   *   .catch(console.error);\n   * @example\n   * // Fetch all invites from a channel\n   * guild.invites.fetch({ channelId: '222197033908436994' })\n   *   .then(console.log)\n   *   .catch(console.error);\n   * @example\n   * // Fetch a single invite\n   * guild.invites.fetch('bRCvFy9')\n   *   .then(console.log)\n   *   .catch(console.error);\n   * @example\n   * // Fetch a single invite without checking cache\n   * guild.invites.fetch({ code: 'bRCvFy9', force: true })\n   *   .then(console.log)\n   *   .catch(console.error)\n   * @example\n   * // Fetch a single invite without caching\n   * guild.invites.fetch({ code: 'bRCvFy9', cache: false })\n   *   .then(console.log)\n   *   .catch(console.error);\n   */\n  fetch(options) {\n    if (!options) return this._fetchMany();\n    if (typeof options === 'string') {\n      const code = DataResolver.resolveInviteCode(options);\n      if (!code) return Promise.reject(new DiscordjsError(ErrorCodes.InviteResolveCode));\n      return this._fetchSingle({ code, cache: true });\n    }\n    if (!options.code) {\n      if (options.channelId) {\n        const id = this.guild.channels.resolveId(options.channelId);\n        if (!id) return Promise.reject(new DiscordjsError(ErrorCodes.GuildChannelResolve));\n        return this._fetchChannelMany(id, options.cache);\n      }\n\n      if ('cache' in options) return this._fetchMany(options.cache);\n      return Promise.reject(new DiscordjsError(ErrorCodes.InviteResolveCode));\n    }\n    return this._fetchSingle({\n      ...options,\n      code: DataResolver.resolveInviteCode(options.code),\n    });\n  }\n\n  async _fetchSingle({ code, cache, force = false }) {\n    if (!force) {\n      const existing = this.cache.get(code);\n      if (existing) return existing;\n    }\n\n    const invites = await this._fetchMany(cache);\n    const invite = invites.get(code);\n    if (!invite) throw new DiscordjsError(ErrorCodes.InviteNotFound);\n    return invite;\n  }\n\n  async _fetchMany(cache) {\n    const data = await this.client.rest.get(Routes.guildInvites(this.guild.id));\n    return data.reduce((col, invite) => col.set(invite.code, this._add(invite, cache)), new Collection());\n  }\n\n  async _fetchChannelMany(channelId, cache) {\n    const data = await this.client.rest.get(Routes.channelInvites(channelId));\n    return data.reduce((col, invite) => col.set(invite.code, this._add(invite, cache)), new Collection());\n  }\n\n  /**\n   * Create an invite to the guild from the provided channel.\n   * @param {GuildInvitableChannelResolvable} channel The options for creating the invite from a channel.\n   * @param {CreateInviteOptions} [options={}] The options for creating the invite from a channel.\n   * @returns {Promise<Invite>}\n   * @example\n   * // Create an invite to a selected channel\n   * guild.invites.create('599942732013764608')\n   *   .then(console.log)\n   *   .catch(console.error);\n   */\n  async create(\n    channel,\n    { temporary, maxAge, maxUses, unique, targetUser, targetApplication, targetType, reason } = {},\n  ) {\n    const id = this.guild.channels.resolveId(channel);\n    if (!id) throw new DiscordjsError(ErrorCodes.GuildChannelResolve);\n\n    const invite = await this.client.rest.post(Routes.channelInvites(id), {\n      body: {\n        temporary,\n        max_age: maxAge,\n        max_uses: maxUses,\n        unique,\n        target_user_id: this.client.users.resolveId(targetUser),\n        target_application_id: targetApplication?.id ?? targetApplication?.applicationId ?? targetApplication,\n        target_type: targetType,\n      },\n      reason,\n    });\n    return new Invite(this.client, invite);\n  }\n\n  /**\n   * Deletes an invite.\n   * @param {InviteResolvable} invite The invite to delete\n   * @param {string} [reason] Reason for deleting the invite\n   * @returns {Promise<void>}\n   */\n  async delete(invite, reason) {\n    const code = DataResolver.resolveInviteCode(invite);\n\n    await this.client.rest.delete(Routes.invite(code), { reason });\n  }\n}\n\nmodule.exports = GuildInviteManager;\n"],"mappings":"AAAA,YAAY;;AAEZ,MAAM;EAAEA;AAAW,CAAC,GAAGC,OAAO,CAAC,uBAAuB,CAAC;AACvD,MAAM;EAAEC;AAAO,CAAC,GAAGD,OAAO,CAAC,uBAAuB,CAAC;AACnD,MAAME,aAAa,GAAGF,OAAO,CAAC,iBAAiB,CAAC;AAChD,MAAM;EAAEG,cAAc;EAAEC;AAAW,CAAC,GAAGJ,OAAO,CAAC,WAAW,CAAC;AAC3D,MAAMK,MAAM,GAAGL,OAAO,CAAC,sBAAsB,CAAC;AAC9C,MAAMM,YAAY,GAAGN,OAAO,CAAC,sBAAsB,CAAC;;AAEpD;AACA;AACA;AACA;AACA,MAAMO,kBAAkB,SAASL,aAAa,CAAC;EAC7CM,WAAW,CAACC,KAAK,EAAEC,QAAQ,EAAE;IAC3B,KAAK,CAACD,KAAK,CAACE,MAAM,EAAEN,MAAM,EAAEK,QAAQ,CAAC;;IAErC;AACJ;AACA;AACA;IACI,IAAI,CAACD,KAAK,GAAGA,KAAK;EACpB;;EAEA;AACF;AACA;AACA;AACA;;EAEEG,IAAI,CAACC,IAAI,EAAEC,KAAK,EAAE;IAChB,OAAO,KAAK,CAACF,IAAI,CAACC,IAAI,EAAEC,KAAK,EAAE;MAAEC,EAAE,EAAEF,IAAI,CAACG,IAAI;MAAEC,MAAM,EAAE,CAAC,IAAI,CAACR,KAAK;IAAE,CAAC,CAAC;EACzE;;EAEA;AACF;AACA;AACA;AACA;AACA;;EAEE;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;EAEE;AACF;AACA;AACA;AACA;AACA;AACA;AACA;;EAEE;AACF;AACA;AACA;AACA;AACA;AACA;AACA;;EAEE;AACF;AACA;AACA;AACA;AACA;AACA;;EAEE;AACF;AACA;AACA;AACA;AACA;AACA;;EAEE;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACES,KAAK,CAACC,OAAO,EAAE;IACb,IAAI,CAACA,OAAO,EAAE,OAAO,IAAI,CAACC,UAAU,EAAE;IACtC,IAAI,OAAOD,OAAO,KAAK,QAAQ,EAAE;MAC/B,MAAMH,IAAI,GAAGV,YAAY,CAACe,iBAAiB,CAACF,OAAO,CAAC;MACpD,IAAI,CAACH,IAAI,EAAE,OAAOM,OAAO,CAACC,MAAM,CAAC,IAAIpB,cAAc,CAACC,UAAU,CAACoB,iBAAiB,CAAC,CAAC;MAClF,OAAO,IAAI,CAACC,YAAY,CAAC;QAAET,IAAI;QAAEF,KAAK,EAAE;MAAK,CAAC,CAAC;IACjD;IACA,IAAI,CAACK,OAAO,CAACH,IAAI,EAAE;MACjB,IAAIG,OAAO,CAACO,SAAS,EAAE;QACrB,MAAMX,EAAE,GAAG,IAAI,CAACN,KAAK,CAACkB,QAAQ,CAACC,SAAS,CAACT,OAAO,CAACO,SAAS,CAAC;QAC3D,IAAI,CAACX,EAAE,EAAE,OAAOO,OAAO,CAACC,MAAM,CAAC,IAAIpB,cAAc,CAACC,UAAU,CAACyB,mBAAmB,CAAC,CAAC;QAClF,OAAO,IAAI,CAACC,iBAAiB,CAACf,EAAE,EAAEI,OAAO,CAACL,KAAK,CAAC;MAClD;MAEA,IAAI,OAAO,IAAIK,OAAO,EAAE,OAAO,IAAI,CAACC,UAAU,CAACD,OAAO,CAACL,KAAK,CAAC;MAC7D,OAAOQ,OAAO,CAACC,MAAM,CAAC,IAAIpB,cAAc,CAACC,UAAU,CAACoB,iBAAiB,CAAC,CAAC;IACzE;IACA,OAAO,IAAI,CAACC,YAAY,CAAC;MACvB,GAAGN,OAAO;MACVH,IAAI,EAAEV,YAAY,CAACe,iBAAiB,CAACF,OAAO,CAACH,IAAI;IACnD,CAAC,CAAC;EACJ;EAEA,MAAMS,YAAY,OAAiC;IAAA,IAAhC;MAAET,IAAI;MAAEF,KAAK;MAAEiB,KAAK,GAAG;IAAM,CAAC;IAC/C,IAAI,CAACA,KAAK,EAAE;MACV,MAAMC,QAAQ,GAAG,IAAI,CAAClB,KAAK,CAACmB,GAAG,CAACjB,IAAI,CAAC;MACrC,IAAIgB,QAAQ,EAAE,OAAOA,QAAQ;IAC/B;IAEA,MAAME,OAAO,GAAG,MAAM,IAAI,CAACd,UAAU,CAACN,KAAK,CAAC;IAC5C,MAAMqB,MAAM,GAAGD,OAAO,CAACD,GAAG,CAACjB,IAAI,CAAC;IAChC,IAAI,CAACmB,MAAM,EAAE,MAAM,IAAIhC,cAAc,CAACC,UAAU,CAACgC,cAAc,CAAC;IAChE,OAAOD,MAAM;EACf;EAEA,MAAMf,UAAU,CAACN,KAAK,EAAE;IACtB,MAAMD,IAAI,GAAG,MAAM,IAAI,CAACF,MAAM,CAAC0B,IAAI,CAACJ,GAAG,CAAChC,MAAM,CAACqC,YAAY,CAAC,IAAI,CAAC7B,KAAK,CAACM,EAAE,CAAC,CAAC;IAC3E,OAAOF,IAAI,CAAC0B,MAAM,CAAC,CAACC,GAAG,EAAEL,MAAM,KAAKK,GAAG,CAACC,GAAG,CAACN,MAAM,CAACnB,IAAI,EAAE,IAAI,CAACJ,IAAI,CAACuB,MAAM,EAAErB,KAAK,CAAC,CAAC,EAAE,IAAIf,UAAU,EAAE,CAAC;EACvG;EAEA,MAAM+B,iBAAiB,CAACJ,SAAS,EAAEZ,KAAK,EAAE;IACxC,MAAMD,IAAI,GAAG,MAAM,IAAI,CAACF,MAAM,CAAC0B,IAAI,CAACJ,GAAG,CAAChC,MAAM,CAACyC,cAAc,CAAChB,SAAS,CAAC,CAAC;IACzE,OAAOb,IAAI,CAAC0B,MAAM,CAAC,CAACC,GAAG,EAAEL,MAAM,KAAKK,GAAG,CAACC,GAAG,CAACN,MAAM,CAACnB,IAAI,EAAE,IAAI,CAACJ,IAAI,CAACuB,MAAM,EAAErB,KAAK,CAAC,CAAC,EAAE,IAAIf,UAAU,EAAE,CAAC;EACvG;;EAEA;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACE,MAAM4C,MAAM,CACVC,OAAO,EAEP;IAAA,IADA;MAAEC,SAAS;MAAEC,MAAM;MAAEC,OAAO;MAAEC,MAAM;MAAEC,UAAU;MAAEC,iBAAiB;MAAEC,UAAU;MAAEC;IAAO,CAAC,uEAAG,CAAC,CAAC;IAE9F,MAAMrC,EAAE,GAAG,IAAI,CAACN,KAAK,CAACkB,QAAQ,CAACC,SAAS,CAACgB,OAAO,CAAC;IACjD,IAAI,CAAC7B,EAAE,EAAE,MAAM,IAAIZ,cAAc,CAACC,UAAU,CAACyB,mBAAmB,CAAC;IAEjE,MAAMM,MAAM,GAAG,MAAM,IAAI,CAACxB,MAAM,CAAC0B,IAAI,CAACgB,IAAI,CAACpD,MAAM,CAACyC,cAAc,CAAC3B,EAAE,CAAC,EAAE;MACpEuC,IAAI,EAAE;QACJT,SAAS;QACTU,OAAO,EAAET,MAAM;QACfU,QAAQ,EAAET,OAAO;QACjBC,MAAM;QACNS,cAAc,EAAE,IAAI,CAAC9C,MAAM,CAAC+C,KAAK,CAAC9B,SAAS,CAACqB,UAAU,CAAC;QACvDU,qBAAqB,EAAET,iBAAiB,EAAEnC,EAAE,IAAImC,iBAAiB,EAAEU,aAAa,IAAIV,iBAAiB;QACrGW,WAAW,EAAEV;MACf,CAAC;MACDC;IACF,CAAC,CAAC;IACF,OAAO,IAAI/C,MAAM,CAAC,IAAI,CAACM,MAAM,EAAEwB,MAAM,CAAC;EACxC;;EAEA;AACF;AACA;AACA;AACA;AACA;EACE,MAAM2B,MAAM,CAAC3B,MAAM,EAAEiB,MAAM,EAAE;IAC3B,MAAMpC,IAAI,GAAGV,YAAY,CAACe,iBAAiB,CAACc,MAAM,CAAC;IAEnD,MAAM,IAAI,CAACxB,MAAM,CAAC0B,IAAI,CAACyB,MAAM,CAAC7D,MAAM,CAACkC,MAAM,CAACnB,IAAI,CAAC,EAAE;MAAEoC;IAAO,CAAC,CAAC;EAChE;AACF;AAEAW,MAAM,CAACC,OAAO,GAAGzD,kBAAkB"},"metadata":{},"sourceType":"script","externalDependencies":[]}