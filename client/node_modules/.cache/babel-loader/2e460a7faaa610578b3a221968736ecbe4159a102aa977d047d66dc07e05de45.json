{"ast":null,"code":"'use strict';\n\nconst {\n  Collection\n} = require('@discordjs/collection');\nconst {\n  Routes\n} = require('discord-api-types/v10');\nconst CachedManager = require('./CachedManager');\nconst {\n  DiscordjsTypeError,\n  ErrorCodes\n} = require('../errors');\nconst MessagePayload = require('../structures/MessagePayload');\nconst {\n  Sticker\n} = require('../structures/Sticker');\n\n/**\n * Manages API methods for Guild Stickers and stores their cache.\n * @extends {CachedManager}\n */\nclass GuildStickerManager extends CachedManager {\n  constructor(guild, iterable) {\n    super(guild.client, Sticker, iterable);\n\n    /**\n     * The guild this manager belongs to\n     * @type {Guild}\n     */\n    this.guild = guild;\n  }\n\n  /**\n   * The cache of Guild Stickers\n   * @type {Collection<Snowflake, Sticker>}\n   * @name GuildStickerManager#cache\n   */\n\n  _add(data, cache) {\n    return super._add(data, cache, {\n      extras: [this.guild]\n    });\n  }\n\n  /**\n   * Options used to create a guild sticker.\n   * @typedef {Object} GuildStickerCreateOptions\n   * @property {BufferResolvable|Stream|JSONEncodable<AttachmentPayload>} file The file for the sticker\n   * @property {string} name The name for the sticker\n   * @property {string} tags The Discord name of a unicode emoji representing the sticker's expression\n   * @property {?string} [description] The description for the sticker\n   * @property {string} [reason] Reason for creating the sticker\n   */\n\n  /**\n   * Creates a new custom sticker in the guild.\n   * @param {GuildStickerCreateOptions} options Options for creating a guild sticker\n   * @returns {Promise<Sticker>} The created sticker\n   * @example\n   * // Create a new sticker from a URL\n   * guild.stickers.create({ file: 'https://i.imgur.com/w3duR07.png', name: 'rip', tags: 'headstone' })\n   *   .then(sticker => console.log(`Created new sticker with name ${sticker.name}!`))\n   *   .catch(console.error);\n   * @example\n   * // Create a new sticker from a file on your computer\n   * guild.stickers.create({ file: './memes/banana.png', name: 'banana', tags: 'banana' })\n   *   .then(sticker => console.log(`Created new sticker with name ${sticker.name}!`))\n   *   .catch(console.error);\n   */\n  async create() {\n    let {\n      file,\n      name,\n      tags,\n      description,\n      reason\n    } = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    const resolvedFile = await MessagePayload.resolveFile(file);\n    if (!resolvedFile) throw new DiscordjsTypeError(ErrorCodes.ReqResourceType);\n    file = {\n      ...resolvedFile,\n      key: 'file'\n    };\n    const body = {\n      name,\n      tags,\n      description: description ?? ''\n    };\n    const sticker = await this.client.rest.post(Routes.guildStickers(this.guild.id), {\n      appendToFormData: true,\n      body,\n      files: [file],\n      reason\n    });\n    return this.client.actions.GuildStickerCreate.handle(this.guild, sticker).sticker;\n  }\n\n  /**\n   * Data that resolves to give a Sticker object. This can be:\n   * * A Sticker object\n   * * A Snowflake\n   * @typedef {Sticker|Snowflake} StickerResolvable\n   */\n\n  /**\n   * Resolves a StickerResolvable to a Sticker object.\n   * @method resolve\n   * @memberof GuildStickerManager\n   * @instance\n   * @param {StickerResolvable} sticker The Sticker resolvable to identify\n   * @returns {?Sticker}\n   */\n\n  /**\n   * Resolves a StickerResolvable to a Sticker id string.\n   * @method resolveId\n   * @memberof GuildStickerManager\n   * @instance\n   * @param {StickerResolvable} sticker The Sticker resolvable to identify\n   * @returns {?Snowflake}\n   */\n\n  /**\n   * Edits a sticker.\n   * @param {StickerResolvable} sticker The sticker to edit\n   * @param {GuildStickerEditData} [data={}] The new data for the sticker\n   * @returns {Promise<Sticker>}\n   */\n  async edit(sticker) {\n    let data = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    const stickerId = this.resolveId(sticker);\n    if (!stickerId) throw new DiscordjsTypeError(ErrorCodes.InvalidType, 'sticker', 'StickerResolvable');\n    const d = await this.client.rest.patch(Routes.guildSticker(this.guild.id, stickerId), {\n      body: data,\n      reason: data.reason\n    });\n    const existing = this.cache.get(stickerId);\n    if (existing) {\n      const clone = existing._clone();\n      clone._patch(d);\n      return clone;\n    }\n    return this._add(d);\n  }\n\n  /**\n   * Deletes a sticker.\n   * @param {StickerResolvable} sticker The sticker to delete\n   * @param {string} [reason] Reason for deleting this sticker\n   * @returns {Promise<void>}\n   */\n  async delete(sticker, reason) {\n    sticker = this.resolveId(sticker);\n    if (!sticker) throw new DiscordjsTypeError(ErrorCodes.InvalidType, 'sticker', 'StickerResolvable');\n    await this.client.rest.delete(Routes.guildSticker(this.guild.id, sticker), {\n      reason\n    });\n  }\n\n  /**\n   * Obtains one or more stickers from Discord, or the sticker cache if they're already available.\n   * @param {Snowflake} [id] The Sticker's id\n   * @param {BaseFetchOptions} [options] Additional options for this fetch\n   * @returns {Promise<Sticker|Collection<Snowflake, Sticker>>}\n   * @example\n   * // Fetch all stickers from the guild\n   * message.guild.stickers.fetch()\n   *   .then(stickers => console.log(`There are ${stickers.size} stickers.`))\n   *   .catch(console.error);\n   * @example\n   * // Fetch a single sticker\n   * message.guild.stickers.fetch('222078108977594368')\n   *   .then(sticker => console.log(`The sticker name is: ${sticker.name}`))\n   *   .catch(console.error);\n   */\n  async fetch(id) {\n    let {\n      cache = true,\n      force = false\n    } = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    if (id) {\n      if (!force) {\n        const existing = this.cache.get(id);\n        if (existing) return existing;\n      }\n      const sticker = await this.client.rest.get(Routes.guildSticker(this.guild.id, id));\n      return this._add(sticker, cache);\n    }\n    const data = await this.client.rest.get(Routes.guildStickers(this.guild.id));\n    return new Collection(data.map(sticker => [sticker.id, this._add(sticker, cache)]));\n  }\n\n  /**\n   * Fetches the user who uploaded this sticker, if this is a guild sticker.\n   * @param {StickerResolvable} sticker The sticker to fetch the user for\n   * @returns {Promise<?User>}\n   */\n  async fetchUser(sticker) {\n    sticker = this.resolve(sticker);\n    if (!sticker) throw new DiscordjsTypeError(ErrorCodes.InvalidType, 'sticker', 'StickerResolvable');\n    const data = await this.client.rest.get(Routes.guildSticker(this.guild.id, sticker.id));\n    sticker._patch(data);\n    return sticker.user;\n  }\n}\nmodule.exports = GuildStickerManager;","map":{"version":3,"names":["Collection","require","Routes","CachedManager","DiscordjsTypeError","ErrorCodes","MessagePayload","Sticker","GuildStickerManager","constructor","guild","iterable","client","_add","data","cache","extras","create","file","name","tags","description","reason","resolvedFile","resolveFile","ReqResourceType","key","body","sticker","rest","post","guildStickers","id","appendToFormData","files","actions","GuildStickerCreate","handle","edit","stickerId","resolveId","InvalidType","d","patch","guildSticker","existing","get","clone","_clone","_patch","delete","fetch","force","map","fetchUser","resolve","user","module","exports"],"sources":["J:/Coding/Projekts/Web/JavaScript/sillcode.tech/node_modules/discord.js/src/managers/GuildStickerManager.js"],"sourcesContent":["'use strict';\n\nconst { Collection } = require('@discordjs/collection');\nconst { Routes } = require('discord-api-types/v10');\nconst CachedManager = require('./CachedManager');\nconst { DiscordjsTypeError, ErrorCodes } = require('../errors');\nconst MessagePayload = require('../structures/MessagePayload');\nconst { Sticker } = require('../structures/Sticker');\n\n/**\n * Manages API methods for Guild Stickers and stores their cache.\n * @extends {CachedManager}\n */\nclass GuildStickerManager extends CachedManager {\n  constructor(guild, iterable) {\n    super(guild.client, Sticker, iterable);\n\n    /**\n     * The guild this manager belongs to\n     * @type {Guild}\n     */\n    this.guild = guild;\n  }\n\n  /**\n   * The cache of Guild Stickers\n   * @type {Collection<Snowflake, Sticker>}\n   * @name GuildStickerManager#cache\n   */\n\n  _add(data, cache) {\n    return super._add(data, cache, { extras: [this.guild] });\n  }\n\n  /**\n   * Options used to create a guild sticker.\n   * @typedef {Object} GuildStickerCreateOptions\n   * @property {BufferResolvable|Stream|JSONEncodable<AttachmentPayload>} file The file for the sticker\n   * @property {string} name The name for the sticker\n   * @property {string} tags The Discord name of a unicode emoji representing the sticker's expression\n   * @property {?string} [description] The description for the sticker\n   * @property {string} [reason] Reason for creating the sticker\n   */\n\n  /**\n   * Creates a new custom sticker in the guild.\n   * @param {GuildStickerCreateOptions} options Options for creating a guild sticker\n   * @returns {Promise<Sticker>} The created sticker\n   * @example\n   * // Create a new sticker from a URL\n   * guild.stickers.create({ file: 'https://i.imgur.com/w3duR07.png', name: 'rip', tags: 'headstone' })\n   *   .then(sticker => console.log(`Created new sticker with name ${sticker.name}!`))\n   *   .catch(console.error);\n   * @example\n   * // Create a new sticker from a file on your computer\n   * guild.stickers.create({ file: './memes/banana.png', name: 'banana', tags: 'banana' })\n   *   .then(sticker => console.log(`Created new sticker with name ${sticker.name}!`))\n   *   .catch(console.error);\n   */\n  async create({ file, name, tags, description, reason } = {}) {\n    const resolvedFile = await MessagePayload.resolveFile(file);\n    if (!resolvedFile) throw new DiscordjsTypeError(ErrorCodes.ReqResourceType);\n    file = { ...resolvedFile, key: 'file' };\n\n    const body = { name, tags, description: description ?? '' };\n\n    const sticker = await this.client.rest.post(Routes.guildStickers(this.guild.id), {\n      appendToFormData: true,\n      body,\n      files: [file],\n      reason,\n    });\n    return this.client.actions.GuildStickerCreate.handle(this.guild, sticker).sticker;\n  }\n\n  /**\n   * Data that resolves to give a Sticker object. This can be:\n   * * A Sticker object\n   * * A Snowflake\n   * @typedef {Sticker|Snowflake} StickerResolvable\n   */\n\n  /**\n   * Resolves a StickerResolvable to a Sticker object.\n   * @method resolve\n   * @memberof GuildStickerManager\n   * @instance\n   * @param {StickerResolvable} sticker The Sticker resolvable to identify\n   * @returns {?Sticker}\n   */\n\n  /**\n   * Resolves a StickerResolvable to a Sticker id string.\n   * @method resolveId\n   * @memberof GuildStickerManager\n   * @instance\n   * @param {StickerResolvable} sticker The Sticker resolvable to identify\n   * @returns {?Snowflake}\n   */\n\n  /**\n   * Edits a sticker.\n   * @param {StickerResolvable} sticker The sticker to edit\n   * @param {GuildStickerEditData} [data={}] The new data for the sticker\n   * @returns {Promise<Sticker>}\n   */\n  async edit(sticker, data = {}) {\n    const stickerId = this.resolveId(sticker);\n    if (!stickerId) throw new DiscordjsTypeError(ErrorCodes.InvalidType, 'sticker', 'StickerResolvable');\n\n    const d = await this.client.rest.patch(Routes.guildSticker(this.guild.id, stickerId), {\n      body: data,\n      reason: data.reason,\n    });\n\n    const existing = this.cache.get(stickerId);\n    if (existing) {\n      const clone = existing._clone();\n      clone._patch(d);\n      return clone;\n    }\n    return this._add(d);\n  }\n\n  /**\n   * Deletes a sticker.\n   * @param {StickerResolvable} sticker The sticker to delete\n   * @param {string} [reason] Reason for deleting this sticker\n   * @returns {Promise<void>}\n   */\n  async delete(sticker, reason) {\n    sticker = this.resolveId(sticker);\n    if (!sticker) throw new DiscordjsTypeError(ErrorCodes.InvalidType, 'sticker', 'StickerResolvable');\n\n    await this.client.rest.delete(Routes.guildSticker(this.guild.id, sticker), { reason });\n  }\n\n  /**\n   * Obtains one or more stickers from Discord, or the sticker cache if they're already available.\n   * @param {Snowflake} [id] The Sticker's id\n   * @param {BaseFetchOptions} [options] Additional options for this fetch\n   * @returns {Promise<Sticker|Collection<Snowflake, Sticker>>}\n   * @example\n   * // Fetch all stickers from the guild\n   * message.guild.stickers.fetch()\n   *   .then(stickers => console.log(`There are ${stickers.size} stickers.`))\n   *   .catch(console.error);\n   * @example\n   * // Fetch a single sticker\n   * message.guild.stickers.fetch('222078108977594368')\n   *   .then(sticker => console.log(`The sticker name is: ${sticker.name}`))\n   *   .catch(console.error);\n   */\n  async fetch(id, { cache = true, force = false } = {}) {\n    if (id) {\n      if (!force) {\n        const existing = this.cache.get(id);\n        if (existing) return existing;\n      }\n      const sticker = await this.client.rest.get(Routes.guildSticker(this.guild.id, id));\n      return this._add(sticker, cache);\n    }\n\n    const data = await this.client.rest.get(Routes.guildStickers(this.guild.id));\n    return new Collection(data.map(sticker => [sticker.id, this._add(sticker, cache)]));\n  }\n\n  /**\n   * Fetches the user who uploaded this sticker, if this is a guild sticker.\n   * @param {StickerResolvable} sticker The sticker to fetch the user for\n   * @returns {Promise<?User>}\n   */\n  async fetchUser(sticker) {\n    sticker = this.resolve(sticker);\n    if (!sticker) throw new DiscordjsTypeError(ErrorCodes.InvalidType, 'sticker', 'StickerResolvable');\n    const data = await this.client.rest.get(Routes.guildSticker(this.guild.id, sticker.id));\n    sticker._patch(data);\n    return sticker.user;\n  }\n}\n\nmodule.exports = GuildStickerManager;\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}