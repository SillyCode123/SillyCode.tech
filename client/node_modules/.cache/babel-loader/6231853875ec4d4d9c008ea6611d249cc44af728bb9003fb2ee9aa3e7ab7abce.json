{"ast":null,"code":"'use strict';\n\nconst EventEmitter = require('node:events');\nconst {\n  setTimeout,\n  clearTimeout\n} = require('node:timers');\nconst {\n  Collection\n} = require('@discordjs/collection');\nconst {\n  DiscordjsTypeError,\n  ErrorCodes\n} = require('../../errors');\nconst {\n  flatten\n} = require('../../util/Util');\n\n/**\n * Filter to be applied to the collector.\n * @typedef {Function} CollectorFilter\n * @param {...*} args Any arguments received by the listener\n * @param {Collection} collection The items collected by this collector\n * @returns {boolean|Promise<boolean>}\n */\n\n/**\n * Options to be applied to the collector.\n * @typedef {Object} CollectorOptions\n * @property {CollectorFilter} [filter] The filter applied to this collector\n * @property {number} [time] How long to run the collector for in milliseconds\n * @property {number} [idle] How long to stop the collector after inactivity in milliseconds\n * @property {boolean} [dispose=false] Whether to dispose data when it's deleted\n */\n\n/**\n * Abstract class for defining a new Collector.\n * @extends {EventEmitter}\n * @abstract\n */\nclass Collector extends EventEmitter {\n  constructor(client) {\n    let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    super();\n\n    /**\n     * The client that instantiated this Collector\n     * @name Collector#client\n     * @type {Client}\n     * @readonly\n     */\n    Object.defineProperty(this, 'client', {\n      value: client\n    });\n\n    /**\n     * The filter applied to this collector\n     * @type {CollectorFilter}\n     * @returns {boolean|Promise<boolean>}\n     */\n    this.filter = options.filter ?? (() => true);\n\n    /**\n     * The options of this collector\n     * @type {CollectorOptions}\n     */\n    this.options = options;\n\n    /**\n     * The items collected by this collector\n     * @type {Collection}\n     */\n    this.collected = new Collection();\n\n    /**\n     * Whether this collector has finished collecting\n     * @type {boolean}\n     */\n    this.ended = false;\n\n    /**\n     * Timeout for cleanup\n     * @type {?Timeout}\n     * @private\n     */\n    this._timeout = null;\n\n    /**\n     * Timeout for cleanup due to inactivity\n     * @type {?Timeout}\n     * @private\n     */\n    this._idletimeout = null;\n\n    /**\n     * The reason the collector ended\n     * @type {string|null}\n     * @private\n     */\n    this._endReason = null;\n    if (typeof this.filter !== 'function') {\n      throw new DiscordjsTypeError(ErrorCodes.InvalidType, 'options.filter', 'function');\n    }\n    this.handleCollect = this.handleCollect.bind(this);\n    this.handleDispose = this.handleDispose.bind(this);\n    if (options.time) this._timeout = setTimeout(() => this.stop('time'), options.time).unref();\n    if (options.idle) this._idletimeout = setTimeout(() => this.stop('idle'), options.idle).unref();\n  }\n\n  /**\n   * Call this to handle an event as a collectable element. Accepts any event data as parameters.\n   * @param {...*} args The arguments emitted by the listener\n   * @returns {Promise<void>}\n   * @emits Collector#collect\n   */\n  async handleCollect() {\n    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n      args[_key] = arguments[_key];\n    }\n    const collectedId = await this.collect(...args);\n    if (collectedId) {\n      const filterResult = await this.filter(...args, this.collected);\n      if (filterResult) {\n        this.collected.set(collectedId, args[0]);\n\n        /**\n         * Emitted whenever an element is collected.\n         * @event Collector#collect\n         * @param {...*} args The arguments emitted by the listener\n         */\n        this.emit('collect', ...args);\n        if (this._idletimeout) {\n          clearTimeout(this._idletimeout);\n          this._idletimeout = setTimeout(() => this.stop('idle'), this.options.idle).unref();\n        }\n      } else {\n        /**\n         * Emitted whenever an element is not collected by the collector.\n         * @event Collector#ignore\n         * @param {...*} args The arguments emitted by the listener\n         */\n        this.emit('ignore', ...args);\n      }\n    }\n    this.checkEnd();\n  }\n\n  /**\n   * Call this to remove an element from the collection. Accepts any event data as parameters.\n   * @param {...*} args The arguments emitted by the listener\n   * @returns {Promise<void>}\n   * @emits Collector#dispose\n   */\n  async handleDispose() {\n    if (!this.options.dispose) return;\n    for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {\n      args[_key2] = arguments[_key2];\n    }\n    const dispose = this.dispose(...args);\n    if (!dispose || !(await this.filter(...args)) || !this.collected.has(dispose)) return;\n    this.collected.delete(dispose);\n\n    /**\n     * Emitted whenever an element is disposed of.\n     * @event Collector#dispose\n     * @param {...*} args The arguments emitted by the listener\n     */\n    this.emit('dispose', ...args);\n    this.checkEnd();\n  }\n\n  /**\n   * Returns a promise that resolves with the next collected element;\n   * rejects with collected elements if the collector finishes without receiving a next element\n   * @type {Promise}\n   * @readonly\n   */\n  get next() {\n    return new Promise((resolve, reject) => {\n      if (this.ended) {\n        reject(this.collected);\n        return;\n      }\n      const cleanup = () => {\n        this.removeListener('collect', onCollect);\n        this.removeListener('end', onEnd);\n      };\n      const onCollect = item => {\n        cleanup();\n        resolve(item);\n      };\n      const onEnd = () => {\n        cleanup();\n        reject(this.collected);\n      };\n      this.on('collect', onCollect);\n      this.on('end', onEnd);\n    });\n  }\n\n  /**\n   * Stops this collector and emits the `end` event.\n   * @param {string} [reason='user'] The reason this collector is ending\n   * @emits Collector#end\n   */\n  stop() {\n    let reason = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 'user';\n    if (this.ended) return;\n    if (this._timeout) {\n      clearTimeout(this._timeout);\n      this._timeout = null;\n    }\n    if (this._idletimeout) {\n      clearTimeout(this._idletimeout);\n      this._idletimeout = null;\n    }\n    this._endReason = reason;\n    this.ended = true;\n\n    /**\n     * Emitted when the collector is finished collecting.\n     * @event Collector#end\n     * @param {Collection} collected The elements collected by the collector\n     * @param {string} reason The reason the collector ended\n     */\n    this.emit('end', this.collected, reason);\n  }\n\n  /**\n   * Options used to reset the timeout and idle timer of a {@link Collector}.\n   * @typedef {Object} CollectorResetTimerOptions\n   * @property {number} [time] How long to run the collector for (in milliseconds)\n   * @property {number} [idle] How long to wait to stop the collector after inactivity (in milliseconds)\n   */\n\n  /**\n   * Resets the collector's timeout and idle timer.\n   * @param {CollectorResetTimerOptions} [options] Options for resetting\n   */\n  resetTimer() {\n    let {\n      time,\n      idle\n    } = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    if (this._timeout) {\n      clearTimeout(this._timeout);\n      this._timeout = setTimeout(() => this.stop('time'), time ?? this.options.time).unref();\n    }\n    if (this._idletimeout) {\n      clearTimeout(this._idletimeout);\n      this._idletimeout = setTimeout(() => this.stop('idle'), idle ?? this.options.idle).unref();\n    }\n  }\n\n  /**\n   * Checks whether the collector should end, and if so, ends it.\n   * @returns {boolean} Whether the collector ended or not\n   */\n  checkEnd() {\n    const reason = this.endReason;\n    if (reason) this.stop(reason);\n    return Boolean(reason);\n  }\n\n  /**\n   * Allows collectors to be consumed with for-await-of loops\n   * @see {@link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/for-await...of}\n   */\n  async *[Symbol.asyncIterator]() {\n    const queue = [];\n    const onCollect = function () {\n      for (var _len3 = arguments.length, item = new Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {\n        item[_key3] = arguments[_key3];\n      }\n      return queue.push(item);\n    };\n    this.on('collect', onCollect);\n    try {\n      while (queue.length || !this.ended) {\n        if (queue.length) {\n          yield queue.shift();\n        } else {\n          // eslint-disable-next-line no-await-in-loop\n          await new Promise(resolve => {\n            const tick = () => {\n              this.removeListener('collect', tick);\n              this.removeListener('end', tick);\n              return resolve();\n            };\n            this.on('collect', tick);\n            this.on('end', tick);\n          });\n        }\n      }\n    } finally {\n      this.removeListener('collect', onCollect);\n    }\n  }\n  toJSON() {\n    return flatten(this);\n  }\n\n  /* eslint-disable no-empty-function */\n  /**\n   * The reason this collector has ended with, or null if it hasn't ended yet\n   * @type {?string}\n   * @readonly\n   */\n  get endReason() {\n    return this._endReason;\n  }\n\n  /**\n   * Handles incoming events from the `handleCollect` function. Returns null if the event should not\n   * be collected, or returns an object describing the data that should be stored.\n   * @see Collector#handleCollect\n   * @param {...*} args Any args the event listener emits\n   * @returns {?(*|Promise<?*>)} Data to insert into collection, if any\n   * @abstract\n   */\n  collect() {}\n\n  /**\n   * Handles incoming events from the `handleDispose`. Returns null if the event should not\n   * be disposed, or returns the key that should be removed.\n   * @see Collector#handleDispose\n   * @param {...*} args Any args the event listener emits\n   * @returns {?*} Key to remove from the collection, if any\n   * @abstract\n   */\n  dispose() {}\n  /* eslint-enable no-empty-function */\n}\n\nmodule.exports = Collector;","map":{"version":3,"names":["EventEmitter","require","setTimeout","clearTimeout","Collection","DiscordjsTypeError","ErrorCodes","flatten","Collector","constructor","client","options","Object","defineProperty","value","filter","collected","ended","_timeout","_idletimeout","_endReason","InvalidType","handleCollect","bind","handleDispose","time","stop","unref","idle","args","collectedId","collect","filterResult","set","emit","checkEnd","dispose","has","delete","next","Promise","resolve","reject","cleanup","removeListener","onCollect","onEnd","item","on","reason","resetTimer","endReason","Boolean","Symbol","asyncIterator","queue","push","length","shift","tick","toJSON","module","exports"],"sources":["J:/Coding/Projekts/Web/JavaScript/sillcode.tech/node_modules/discord.js/src/structures/interfaces/Collector.js"],"sourcesContent":["'use strict';\n\nconst EventEmitter = require('node:events');\nconst { setTimeout, clearTimeout } = require('node:timers');\nconst { Collection } = require('@discordjs/collection');\nconst { DiscordjsTypeError, ErrorCodes } = require('../../errors');\nconst { flatten } = require('../../util/Util');\n\n/**\n * Filter to be applied to the collector.\n * @typedef {Function} CollectorFilter\n * @param {...*} args Any arguments received by the listener\n * @param {Collection} collection The items collected by this collector\n * @returns {boolean|Promise<boolean>}\n */\n\n/**\n * Options to be applied to the collector.\n * @typedef {Object} CollectorOptions\n * @property {CollectorFilter} [filter] The filter applied to this collector\n * @property {number} [time] How long to run the collector for in milliseconds\n * @property {number} [idle] How long to stop the collector after inactivity in milliseconds\n * @property {boolean} [dispose=false] Whether to dispose data when it's deleted\n */\n\n/**\n * Abstract class for defining a new Collector.\n * @extends {EventEmitter}\n * @abstract\n */\nclass Collector extends EventEmitter {\n  constructor(client, options = {}) {\n    super();\n\n    /**\n     * The client that instantiated this Collector\n     * @name Collector#client\n     * @type {Client}\n     * @readonly\n     */\n    Object.defineProperty(this, 'client', { value: client });\n\n    /**\n     * The filter applied to this collector\n     * @type {CollectorFilter}\n     * @returns {boolean|Promise<boolean>}\n     */\n    this.filter = options.filter ?? (() => true);\n\n    /**\n     * The options of this collector\n     * @type {CollectorOptions}\n     */\n    this.options = options;\n\n    /**\n     * The items collected by this collector\n     * @type {Collection}\n     */\n    this.collected = new Collection();\n\n    /**\n     * Whether this collector has finished collecting\n     * @type {boolean}\n     */\n    this.ended = false;\n\n    /**\n     * Timeout for cleanup\n     * @type {?Timeout}\n     * @private\n     */\n    this._timeout = null;\n\n    /**\n     * Timeout for cleanup due to inactivity\n     * @type {?Timeout}\n     * @private\n     */\n    this._idletimeout = null;\n\n    /**\n     * The reason the collector ended\n     * @type {string|null}\n     * @private\n     */\n    this._endReason = null;\n\n    if (typeof this.filter !== 'function') {\n      throw new DiscordjsTypeError(ErrorCodes.InvalidType, 'options.filter', 'function');\n    }\n\n    this.handleCollect = this.handleCollect.bind(this);\n    this.handleDispose = this.handleDispose.bind(this);\n\n    if (options.time) this._timeout = setTimeout(() => this.stop('time'), options.time).unref();\n    if (options.idle) this._idletimeout = setTimeout(() => this.stop('idle'), options.idle).unref();\n  }\n\n  /**\n   * Call this to handle an event as a collectable element. Accepts any event data as parameters.\n   * @param {...*} args The arguments emitted by the listener\n   * @returns {Promise<void>}\n   * @emits Collector#collect\n   */\n  async handleCollect(...args) {\n    const collectedId = await this.collect(...args);\n\n    if (collectedId) {\n      const filterResult = await this.filter(...args, this.collected);\n      if (filterResult) {\n        this.collected.set(collectedId, args[0]);\n\n        /**\n         * Emitted whenever an element is collected.\n         * @event Collector#collect\n         * @param {...*} args The arguments emitted by the listener\n         */\n        this.emit('collect', ...args);\n\n        if (this._idletimeout) {\n          clearTimeout(this._idletimeout);\n          this._idletimeout = setTimeout(() => this.stop('idle'), this.options.idle).unref();\n        }\n      } else {\n        /**\n         * Emitted whenever an element is not collected by the collector.\n         * @event Collector#ignore\n         * @param {...*} args The arguments emitted by the listener\n         */\n        this.emit('ignore', ...args);\n      }\n    }\n    this.checkEnd();\n  }\n\n  /**\n   * Call this to remove an element from the collection. Accepts any event data as parameters.\n   * @param {...*} args The arguments emitted by the listener\n   * @returns {Promise<void>}\n   * @emits Collector#dispose\n   */\n  async handleDispose(...args) {\n    if (!this.options.dispose) return;\n\n    const dispose = this.dispose(...args);\n    if (!dispose || !(await this.filter(...args)) || !this.collected.has(dispose)) return;\n    this.collected.delete(dispose);\n\n    /**\n     * Emitted whenever an element is disposed of.\n     * @event Collector#dispose\n     * @param {...*} args The arguments emitted by the listener\n     */\n    this.emit('dispose', ...args);\n    this.checkEnd();\n  }\n\n  /**\n   * Returns a promise that resolves with the next collected element;\n   * rejects with collected elements if the collector finishes without receiving a next element\n   * @type {Promise}\n   * @readonly\n   */\n  get next() {\n    return new Promise((resolve, reject) => {\n      if (this.ended) {\n        reject(this.collected);\n        return;\n      }\n\n      const cleanup = () => {\n        this.removeListener('collect', onCollect);\n        this.removeListener('end', onEnd);\n      };\n\n      const onCollect = item => {\n        cleanup();\n        resolve(item);\n      };\n\n      const onEnd = () => {\n        cleanup();\n        reject(this.collected);\n      };\n\n      this.on('collect', onCollect);\n      this.on('end', onEnd);\n    });\n  }\n\n  /**\n   * Stops this collector and emits the `end` event.\n   * @param {string} [reason='user'] The reason this collector is ending\n   * @emits Collector#end\n   */\n  stop(reason = 'user') {\n    if (this.ended) return;\n\n    if (this._timeout) {\n      clearTimeout(this._timeout);\n      this._timeout = null;\n    }\n    if (this._idletimeout) {\n      clearTimeout(this._idletimeout);\n      this._idletimeout = null;\n    }\n\n    this._endReason = reason;\n    this.ended = true;\n\n    /**\n     * Emitted when the collector is finished collecting.\n     * @event Collector#end\n     * @param {Collection} collected The elements collected by the collector\n     * @param {string} reason The reason the collector ended\n     */\n    this.emit('end', this.collected, reason);\n  }\n\n  /**\n   * Options used to reset the timeout and idle timer of a {@link Collector}.\n   * @typedef {Object} CollectorResetTimerOptions\n   * @property {number} [time] How long to run the collector for (in milliseconds)\n   * @property {number} [idle] How long to wait to stop the collector after inactivity (in milliseconds)\n   */\n\n  /**\n   * Resets the collector's timeout and idle timer.\n   * @param {CollectorResetTimerOptions} [options] Options for resetting\n   */\n  resetTimer({ time, idle } = {}) {\n    if (this._timeout) {\n      clearTimeout(this._timeout);\n      this._timeout = setTimeout(() => this.stop('time'), time ?? this.options.time).unref();\n    }\n    if (this._idletimeout) {\n      clearTimeout(this._idletimeout);\n      this._idletimeout = setTimeout(() => this.stop('idle'), idle ?? this.options.idle).unref();\n    }\n  }\n\n  /**\n   * Checks whether the collector should end, and if so, ends it.\n   * @returns {boolean} Whether the collector ended or not\n   */\n  checkEnd() {\n    const reason = this.endReason;\n    if (reason) this.stop(reason);\n    return Boolean(reason);\n  }\n\n  /**\n   * Allows collectors to be consumed with for-await-of loops\n   * @see {@link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/for-await...of}\n   */\n  async *[Symbol.asyncIterator]() {\n    const queue = [];\n    const onCollect = (...item) => queue.push(item);\n    this.on('collect', onCollect);\n\n    try {\n      while (queue.length || !this.ended) {\n        if (queue.length) {\n          yield queue.shift();\n        } else {\n          // eslint-disable-next-line no-await-in-loop\n          await new Promise(resolve => {\n            const tick = () => {\n              this.removeListener('collect', tick);\n              this.removeListener('end', tick);\n              return resolve();\n            };\n            this.on('collect', tick);\n            this.on('end', tick);\n          });\n        }\n      }\n    } finally {\n      this.removeListener('collect', onCollect);\n    }\n  }\n\n  toJSON() {\n    return flatten(this);\n  }\n\n  /* eslint-disable no-empty-function */\n  /**\n   * The reason this collector has ended with, or null if it hasn't ended yet\n   * @type {?string}\n   * @readonly\n   */\n  get endReason() {\n    return this._endReason;\n  }\n\n  /**\n   * Handles incoming events from the `handleCollect` function. Returns null if the event should not\n   * be collected, or returns an object describing the data that should be stored.\n   * @see Collector#handleCollect\n   * @param {...*} args Any args the event listener emits\n   * @returns {?(*|Promise<?*>)} Data to insert into collection, if any\n   * @abstract\n   */\n  collect() {}\n\n  /**\n   * Handles incoming events from the `handleDispose`. Returns null if the event should not\n   * be disposed, or returns the key that should be removed.\n   * @see Collector#handleDispose\n   * @param {...*} args Any args the event listener emits\n   * @returns {?*} Key to remove from the collection, if any\n   * @abstract\n   */\n  dispose() {}\n  /* eslint-enable no-empty-function */\n}\n\nmodule.exports = Collector;\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}