{"ast":null,"code":"'use strict';\n\nconst {\n  makeURLSearchParams\n} = require('@discordjs/rest');\nconst {\n  lazy\n} = require('@discordjs/util');\nconst {\n  DiscordSnowflake\n} = require('@sapphire/snowflake');\nconst {\n  Routes,\n  WebhookType\n} = require('discord-api-types/v10');\nconst MessagePayload = require('./MessagePayload');\nconst {\n  DiscordjsError,\n  ErrorCodes\n} = require('../errors');\nconst DataResolver = require('../util/DataResolver');\nconst getMessage = lazy(() => require('./Message').Message);\n\n/**\n * Represents a webhook.\n */\nclass Webhook {\n  constructor(client, data) {\n    /**\n     * The client that instantiated the webhook\n     * @name Webhook#client\n     * @type {Client}\n     * @readonly\n     */\n    Object.defineProperty(this, 'client', {\n      value: client\n    });\n    if (data) this._patch(data);\n  }\n  _patch(data) {\n    if ('name' in data) {\n      /**\n       * The name of the webhook\n       * @type {string}\n       */\n      this.name = data.name;\n    }\n\n    /**\n     * The token for the webhook, unavailable for follower webhooks and webhooks owned by another application.\n     * @name Webhook#token\n     * @type {?string}\n     */\n    Object.defineProperty(this, 'token', {\n      value: data.token ?? null,\n      writable: true,\n      configurable: true\n    });\n    if ('avatar' in data) {\n      /**\n       * The avatar for the webhook\n       * @type {?string}\n       */\n      this.avatar = data.avatar;\n    }\n\n    /**\n     * The webhook's id\n     * @type {Snowflake}\n     */\n    this.id = data.id;\n    if ('type' in data) {\n      /**\n       * The type of the webhook\n       * @type {WebhookType}\n       */\n      this.type = data.type;\n    }\n    if ('guild_id' in data) {\n      /**\n       * The guild the webhook belongs to\n       * @type {Snowflake}\n       */\n      this.guildId = data.guild_id;\n    }\n    if ('channel_id' in data) {\n      /**\n       * The id of the channel the webhook belongs to\n       * @type {Snowflake}\n       */\n      this.channelId = data.channel_id;\n    }\n    if ('user' in data) {\n      /**\n       * The owner of the webhook\n       * @type {?(User|APIUser)}\n       */\n      this.owner = this.client.users?._add(data.user) ?? data.user;\n    } else {\n      this.owner ??= null;\n    }\n    if ('application_id' in data) {\n      /**\n       * The application that created this webhook\n       * @type {?Snowflake}\n       */\n      this.applicationId = data.application_id;\n    } else {\n      this.applicationId ??= null;\n    }\n    if ('source_guild' in data) {\n      /**\n       * The source guild of the webhook\n       * @type {?(Guild|APIGuild)}\n       */\n      this.sourceGuild = this.client.guilds?.resolve(data.source_guild.id) ?? data.source_guild;\n    } else {\n      this.sourceGuild ??= null;\n    }\n    if ('source_channel' in data) {\n      /**\n       * The source channel of the webhook\n       * @type {?(NewsChannel|APIChannel)}\n       */\n      this.sourceChannel = this.client.channels?.resolve(data.source_channel?.id) ?? data.source_channel;\n    } else {\n      this.sourceChannel ??= null;\n    }\n  }\n\n  /**\n   * Options that can be passed into send.\n   * @typedef {BaseMessageOptions} WebhookCreateMessageOptions\n   * @property {boolean} [tts=false] Whether the message should be spoken aloud\n   * @property {MessageFlags} [flags] Which flags to set for the message.\n   * <info>Only the {@link MessageFlags.SuppressEmbeds} flag can be set.</info>\n   * @property {string} [username=this.name] Username override for the message\n   * @property {string} [avatarURL] Avatar URL override for the message\n   * @property {Snowflake} [threadId] The id of the thread in the channel to send to.\n   * <info>For interaction webhooks, this property is ignored</info>\n   * @property {string} [threadName] Name of the thread to create (only available if webhook is in a forum channel)\n   */\n\n  /**\n   * Options that can be passed into editMessage.\n   * @typedef {BaseMessageOptions} WebhookEditMessageOptions\n   * @property {Attachment[]} [attachments] Attachments to send with the message\n   * @property {Snowflake} [threadId] The id of the thread this message belongs to\n   * <info>For interaction webhooks, this property is ignored</info>\n   */\n\n  /**\n   * The channel the webhook belongs to\n   * @type {?(TextChannel|VoiceChannel|NewsChannel|ForumChannel)}\n   * @readonly\n   */\n  get channel() {\n    return this.client.channels.resolve(this.channelId);\n  }\n\n  /**\n   * Sends a message with this webhook.\n   * @param {string|MessagePayload|WebhookCreateMessageOptions} options The options to provide\n   * @returns {Promise<Message>}\n   * @example\n   * // Send a basic message\n   * webhook.send('hello!')\n   *   .then(message => console.log(`Sent message: ${message.content}`))\n   *   .catch(console.error);\n   * @example\n   * // Send a basic message in a thread\n   * webhook.send({ content: 'hello!', threadId: '836856309672348295' })\n   *   .then(message => console.log(`Sent message: ${message.content}`))\n   *   .catch(console.error);\n   * @example\n   * // Send a remote file\n   * webhook.send({\n   *   files: ['https://cdn.discordapp.com/icons/222078108977594368/6e1019b3179d71046e463a75915e7244.png?size=2048']\n   * })\n   *   .then(console.log)\n   *   .catch(console.error);\n   * @example\n   * // Send a local file\n   * webhook.send({\n   *   files: [{\n   *     attachment: 'entire/path/to/file.jpg',\n   *     name: 'file.jpg'\n   *   }]\n   * })\n   *   .then(console.log)\n   *   .catch(console.error);\n   * @example\n   * // Send an embed with a local image inside\n   * webhook.send({\n   *   content: 'This is an embed',\n   *   embeds: [{\n   *     thumbnail: {\n   *          url: 'attachment://file.jpg'\n   *       }\n   *    }],\n   *    files: [{\n   *       attachment: 'entire/path/to/file.jpg',\n   *       name: 'file.jpg'\n   *    }]\n   * })\n   *   .then(console.log)\n   *   .catch(console.error);\n   */\n  async send(options) {\n    if (!this.token) throw new DiscordjsError(ErrorCodes.WebhookTokenUnavailable);\n    let messagePayload;\n    if (options instanceof MessagePayload) {\n      messagePayload = options.resolveBody();\n    } else {\n      messagePayload = MessagePayload.create(this, options).resolveBody();\n    }\n    const query = makeURLSearchParams({\n      wait: true,\n      thread_id: messagePayload.options.threadId\n    });\n    const {\n      body,\n      files\n    } = await messagePayload.resolveFiles();\n    const d = await this.client.rest.post(Routes.webhook(this.id, this.token), {\n      body,\n      files,\n      query,\n      auth: false\n    });\n    if (!this.client.channels) return d;\n    return this.client.channels.cache.get(d.channel_id)?.messages._add(d, false) ?? new (getMessage())(this.client, d);\n  }\n\n  /**\n   * Sends a raw slack message with this webhook.\n   * @param {Object} body The raw body to send\n   * @returns {Promise<boolean>}\n   * @example\n   * // Send a slack message\n   * webhook.sendSlackMessage({\n   *   'username': 'Wumpus',\n   *   'attachments': [{\n   *     'pretext': 'this looks pretty cool',\n   *     'color': '#F0F',\n   *     'footer_icon': 'http://snek.s3.amazonaws.com/topSnek.png',\n   *     'footer': 'Powered by sneks',\n   *     'ts': Date.now() / 1_000\n   *   }]\n   * }).catch(console.error);\n   * @see {@link https://api.slack.com/messaging/webhooks}\n   */\n  async sendSlackMessage(body) {\n    if (!this.token) throw new DiscordjsError(ErrorCodes.WebhookTokenUnavailable);\n    const data = await this.client.rest.post(Routes.webhookPlatform(this.id, this.token, 'slack'), {\n      query: makeURLSearchParams({\n        wait: true\n      }),\n      auth: false,\n      body\n    });\n    return data.toString() === 'ok';\n  }\n\n  /**\n   * Options used to edit a {@link Webhook}.\n   * @typedef {Object} WebhookEditData\n   * @property {string} [name=this.name] The new name for the webhook\n   * @property {?(BufferResolvable)} [avatar] The new avatar for the webhook\n   * @property {GuildTextChannelResolvable} [channel] The new channel for the webhook\n   * @property {string} [reason] Reason for editing the webhook\n   */\n\n  /**\n   * Edits this webhook.\n   * @param {WebhookEditData} options Options for editing the webhook\n   * @returns {Promise<Webhook>}\n   */\n  async edit(_ref) {\n    let {\n      name = this.name,\n      avatar,\n      channel,\n      reason\n    } = _ref;\n    if (avatar && !(typeof avatar === 'string' && avatar.startsWith('data:'))) {\n      avatar = await DataResolver.resolveImage(avatar);\n    }\n    channel &&= channel.id ?? channel;\n    const data = await this.client.rest.patch(Routes.webhook(this.id, channel ? undefined : this.token), {\n      body: {\n        name,\n        avatar,\n        channel_id: channel\n      },\n      reason,\n      auth: !this.token || Boolean(channel)\n    });\n    this.name = data.name;\n    this.avatar = data.avatar;\n    this.channelId = data.channel_id;\n    return this;\n  }\n\n  /**\n   * Options that can be passed into fetchMessage.\n   * @typedef {options} WebhookFetchMessageOptions\n   * @property {boolean} [cache=true] Whether to cache the message.\n   * @property {Snowflake} [threadId] The id of the thread this message belongs to.\n   * <info>For interaction webhooks, this property is ignored</info>\n   */\n\n  /**\n   * Gets a message that was sent by this webhook.\n   * @param {Snowflake|'@original'} message The id of the message to fetch\n   * @param {WebhookFetchMessageOptions} [options={}] The options to provide to fetch the message.\n   * @returns {Promise<Message>} Returns the message sent by this webhook\n   */\n  async fetchMessage(message) {\n    let {\n      threadId\n    } = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    if (!this.token) throw new DiscordjsError(ErrorCodes.WebhookTokenUnavailable);\n    const data = await this.client.rest.get(Routes.webhookMessage(this.id, this.token, message), {\n      query: threadId ? makeURLSearchParams({\n        thread_id: threadId\n      }) : undefined,\n      auth: false\n    });\n    if (!this.client.channels) return data;\n    return this.client.channels.cache.get(data.channel_id)?.messages._add(data, false) ?? new (getMessage())(this.client, data);\n  }\n\n  /**\n   * Edits a message that was sent by this webhook.\n   * @param {MessageResolvable|'@original'} message The message to edit\n   * @param {string|MessagePayload|WebhookEditMessageOptions} options The options to provide\n   * @returns {Promise<Message>} Returns the message edited by this webhook\n   */\n  async editMessage(message, options) {\n    if (!this.token) throw new DiscordjsError(ErrorCodes.WebhookTokenUnavailable);\n    let messagePayload;\n    if (options instanceof MessagePayload) messagePayload = options;else messagePayload = MessagePayload.create(this, options);\n    const {\n      body,\n      files\n    } = await messagePayload.resolveBody().resolveFiles();\n    const d = await this.client.rest.patch(Routes.webhookMessage(this.id, this.token, typeof message === 'string' ? message : message.id), {\n      body,\n      files,\n      query: messagePayload.options.threadId ? makeURLSearchParams({\n        thread_id: messagePayload.options.threadId\n      }) : undefined,\n      auth: false\n    });\n    const channelManager = this.client.channels;\n    if (!channelManager) return d;\n    const messageManager = channelManager.cache.get(d.channel_id)?.messages;\n    if (!messageManager) return new (getMessage())(this.client, d);\n    const existing = messageManager.cache.get(d.id);\n    if (!existing) return messageManager._add(d);\n    const clone = existing._clone();\n    clone._patch(d);\n    return clone;\n  }\n\n  /**\n   * Deletes the webhook.\n   * @param {string} [reason] Reason for deleting this webhook\n   * @returns {Promise<void>}\n   */\n  async delete(reason) {\n    await this.client.rest.delete(Routes.webhook(this.id, this.token), {\n      reason,\n      auth: !this.token\n    });\n  }\n\n  /**\n   * Delete a message that was sent by this webhook.\n   * @param {MessageResolvable|'@original'} message The message to delete\n   * @param {Snowflake} [threadId] The id of the thread this message belongs to\n   * @returns {Promise<void>}\n   */\n  async deleteMessage(message, threadId) {\n    if (!this.token) throw new DiscordjsError(ErrorCodes.WebhookTokenUnavailable);\n    await this.client.rest.delete(Routes.webhookMessage(this.id, this.token, typeof message === 'string' ? message : message.id), {\n      query: threadId ? makeURLSearchParams({\n        thread_id: threadId\n      }) : undefined,\n      auth: false\n    });\n  }\n\n  /**\n   * The timestamp the webhook was created at\n   * @type {number}\n   * @readonly\n   */\n  get createdTimestamp() {\n    return DiscordSnowflake.timestampFrom(this.id);\n  }\n\n  /**\n   * The time the webhook was created at\n   * @type {Date}\n   * @readonly\n   */\n  get createdAt() {\n    return new Date(this.createdTimestamp);\n  }\n\n  /**\n   * The URL of this webhook\n   * @type {string}\n   * @readonly\n   */\n  get url() {\n    return this.client.options.rest.api + Routes.webhook(this.id, this.token);\n  }\n\n  /**\n   * A link to the webhook's avatar.\n   * @param {ImageURLOptions} [options={}] Options for the image URL\n   * @returns {?string}\n   */\n  avatarURL() {\n    let options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    return this.avatar && this.client.rest.cdn.avatar(this.id, this.avatar, options);\n  }\n\n  /**\n   * Whether this webhook is created by a user.\n   * @returns {boolean}\n   */\n  isUserCreated() {\n    return Boolean(this.type === WebhookType.Incoming && this.owner && !this.owner.bot);\n  }\n\n  /**\n   * Whether this webhook is created by an application.\n   * @returns {boolean}\n   */\n  isApplicationCreated() {\n    return this.type === WebhookType.Application;\n  }\n\n  /**\n   * Whether or not this webhook is a channel follower webhook.\n   * @returns {boolean}\n   */\n  isChannelFollower() {\n    return this.type === WebhookType.ChannelFollower;\n  }\n\n  /**\n   * Whether or not this webhook is an incoming webhook.\n   * @returns {boolean}\n   */\n  isIncoming() {\n    return this.type === WebhookType.Incoming;\n  }\n  static applyToClass(structure) {\n    let ignore = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];\n    for (const prop of ['send', 'sendSlackMessage', 'fetchMessage', 'edit', 'editMessage', 'delete', 'deleteMessage', 'createdTimestamp', 'createdAt', 'url']) {\n      if (ignore.includes(prop)) continue;\n      Object.defineProperty(structure.prototype, prop, Object.getOwnPropertyDescriptor(Webhook.prototype, prop));\n    }\n  }\n}\nmodule.exports = Webhook;","map":{"version":3,"names":["makeURLSearchParams","require","lazy","DiscordSnowflake","Routes","WebhookType","MessagePayload","DiscordjsError","ErrorCodes","DataResolver","getMessage","Message","Webhook","constructor","client","data","Object","defineProperty","value","_patch","name","token","writable","configurable","avatar","id","type","guildId","guild_id","channelId","channel_id","owner","users","_add","user","applicationId","application_id","sourceGuild","guilds","resolve","source_guild","sourceChannel","channels","source_channel","channel","send","options","WebhookTokenUnavailable","messagePayload","resolveBody","create","query","wait","thread_id","threadId","body","files","resolveFiles","d","rest","post","webhook","auth","cache","get","messages","sendSlackMessage","webhookPlatform","toString","edit","reason","startsWith","resolveImage","patch","undefined","Boolean","fetchMessage","message","webhookMessage","editMessage","channelManager","messageManager","existing","clone","_clone","delete","deleteMessage","createdTimestamp","timestampFrom","createdAt","Date","url","api","avatarURL","cdn","isUserCreated","Incoming","bot","isApplicationCreated","Application","isChannelFollower","ChannelFollower","isIncoming","applyToClass","structure","ignore","prop","includes","prototype","getOwnPropertyDescriptor","module","exports"],"sources":["J:/Coding/Projekts/Web/JavaScript/sillcode.tech/node_modules/discord.js/src/structures/Webhook.js"],"sourcesContent":["'use strict';\n\nconst { makeURLSearchParams } = require('@discordjs/rest');\nconst { lazy } = require('@discordjs/util');\nconst { DiscordSnowflake } = require('@sapphire/snowflake');\nconst { Routes, WebhookType } = require('discord-api-types/v10');\nconst MessagePayload = require('./MessagePayload');\nconst { DiscordjsError, ErrorCodes } = require('../errors');\nconst DataResolver = require('../util/DataResolver');\n\nconst getMessage = lazy(() => require('./Message').Message);\n\n/**\n * Represents a webhook.\n */\nclass Webhook {\n  constructor(client, data) {\n    /**\n     * The client that instantiated the webhook\n     * @name Webhook#client\n     * @type {Client}\n     * @readonly\n     */\n    Object.defineProperty(this, 'client', { value: client });\n    if (data) this._patch(data);\n  }\n\n  _patch(data) {\n    if ('name' in data) {\n      /**\n       * The name of the webhook\n       * @type {string}\n       */\n      this.name = data.name;\n    }\n\n    /**\n     * The token for the webhook, unavailable for follower webhooks and webhooks owned by another application.\n     * @name Webhook#token\n     * @type {?string}\n     */\n    Object.defineProperty(this, 'token', {\n      value: data.token ?? null,\n      writable: true,\n      configurable: true,\n    });\n\n    if ('avatar' in data) {\n      /**\n       * The avatar for the webhook\n       * @type {?string}\n       */\n      this.avatar = data.avatar;\n    }\n\n    /**\n     * The webhook's id\n     * @type {Snowflake}\n     */\n    this.id = data.id;\n\n    if ('type' in data) {\n      /**\n       * The type of the webhook\n       * @type {WebhookType}\n       */\n      this.type = data.type;\n    }\n\n    if ('guild_id' in data) {\n      /**\n       * The guild the webhook belongs to\n       * @type {Snowflake}\n       */\n      this.guildId = data.guild_id;\n    }\n\n    if ('channel_id' in data) {\n      /**\n       * The id of the channel the webhook belongs to\n       * @type {Snowflake}\n       */\n      this.channelId = data.channel_id;\n    }\n\n    if ('user' in data) {\n      /**\n       * The owner of the webhook\n       * @type {?(User|APIUser)}\n       */\n      this.owner = this.client.users?._add(data.user) ?? data.user;\n    } else {\n      this.owner ??= null;\n    }\n\n    if ('application_id' in data) {\n      /**\n       * The application that created this webhook\n       * @type {?Snowflake}\n       */\n      this.applicationId = data.application_id;\n    } else {\n      this.applicationId ??= null;\n    }\n\n    if ('source_guild' in data) {\n      /**\n       * The source guild of the webhook\n       * @type {?(Guild|APIGuild)}\n       */\n      this.sourceGuild = this.client.guilds?.resolve(data.source_guild.id) ?? data.source_guild;\n    } else {\n      this.sourceGuild ??= null;\n    }\n\n    if ('source_channel' in data) {\n      /**\n       * The source channel of the webhook\n       * @type {?(NewsChannel|APIChannel)}\n       */\n      this.sourceChannel = this.client.channels?.resolve(data.source_channel?.id) ?? data.source_channel;\n    } else {\n      this.sourceChannel ??= null;\n    }\n  }\n\n  /**\n   * Options that can be passed into send.\n   * @typedef {BaseMessageOptions} WebhookCreateMessageOptions\n   * @property {boolean} [tts=false] Whether the message should be spoken aloud\n   * @property {MessageFlags} [flags] Which flags to set for the message.\n   * <info>Only the {@link MessageFlags.SuppressEmbeds} flag can be set.</info>\n   * @property {string} [username=this.name] Username override for the message\n   * @property {string} [avatarURL] Avatar URL override for the message\n   * @property {Snowflake} [threadId] The id of the thread in the channel to send to.\n   * <info>For interaction webhooks, this property is ignored</info>\n   * @property {string} [threadName] Name of the thread to create (only available if webhook is in a forum channel)\n   */\n\n  /**\n   * Options that can be passed into editMessage.\n   * @typedef {BaseMessageOptions} WebhookEditMessageOptions\n   * @property {Attachment[]} [attachments] Attachments to send with the message\n   * @property {Snowflake} [threadId] The id of the thread this message belongs to\n   * <info>For interaction webhooks, this property is ignored</info>\n   */\n\n  /**\n   * The channel the webhook belongs to\n   * @type {?(TextChannel|VoiceChannel|NewsChannel|ForumChannel)}\n   * @readonly\n   */\n  get channel() {\n    return this.client.channels.resolve(this.channelId);\n  }\n\n  /**\n   * Sends a message with this webhook.\n   * @param {string|MessagePayload|WebhookCreateMessageOptions} options The options to provide\n   * @returns {Promise<Message>}\n   * @example\n   * // Send a basic message\n   * webhook.send('hello!')\n   *   .then(message => console.log(`Sent message: ${message.content}`))\n   *   .catch(console.error);\n   * @example\n   * // Send a basic message in a thread\n   * webhook.send({ content: 'hello!', threadId: '836856309672348295' })\n   *   .then(message => console.log(`Sent message: ${message.content}`))\n   *   .catch(console.error);\n   * @example\n   * // Send a remote file\n   * webhook.send({\n   *   files: ['https://cdn.discordapp.com/icons/222078108977594368/6e1019b3179d71046e463a75915e7244.png?size=2048']\n   * })\n   *   .then(console.log)\n   *   .catch(console.error);\n   * @example\n   * // Send a local file\n   * webhook.send({\n   *   files: [{\n   *     attachment: 'entire/path/to/file.jpg',\n   *     name: 'file.jpg'\n   *   }]\n   * })\n   *   .then(console.log)\n   *   .catch(console.error);\n   * @example\n   * // Send an embed with a local image inside\n   * webhook.send({\n   *   content: 'This is an embed',\n   *   embeds: [{\n   *     thumbnail: {\n   *          url: 'attachment://file.jpg'\n   *       }\n   *    }],\n   *    files: [{\n   *       attachment: 'entire/path/to/file.jpg',\n   *       name: 'file.jpg'\n   *    }]\n   * })\n   *   .then(console.log)\n   *   .catch(console.error);\n   */\n  async send(options) {\n    if (!this.token) throw new DiscordjsError(ErrorCodes.WebhookTokenUnavailable);\n\n    let messagePayload;\n\n    if (options instanceof MessagePayload) {\n      messagePayload = options.resolveBody();\n    } else {\n      messagePayload = MessagePayload.create(this, options).resolveBody();\n    }\n\n    const query = makeURLSearchParams({\n      wait: true,\n      thread_id: messagePayload.options.threadId,\n    });\n\n    const { body, files } = await messagePayload.resolveFiles();\n    const d = await this.client.rest.post(Routes.webhook(this.id, this.token), {\n      body,\n      files,\n      query,\n      auth: false,\n    });\n\n    if (!this.client.channels) return d;\n    return this.client.channels.cache.get(d.channel_id)?.messages._add(d, false) ?? new (getMessage())(this.client, d);\n  }\n\n  /**\n   * Sends a raw slack message with this webhook.\n   * @param {Object} body The raw body to send\n   * @returns {Promise<boolean>}\n   * @example\n   * // Send a slack message\n   * webhook.sendSlackMessage({\n   *   'username': 'Wumpus',\n   *   'attachments': [{\n   *     'pretext': 'this looks pretty cool',\n   *     'color': '#F0F',\n   *     'footer_icon': 'http://snek.s3.amazonaws.com/topSnek.png',\n   *     'footer': 'Powered by sneks',\n   *     'ts': Date.now() / 1_000\n   *   }]\n   * }).catch(console.error);\n   * @see {@link https://api.slack.com/messaging/webhooks}\n   */\n  async sendSlackMessage(body) {\n    if (!this.token) throw new DiscordjsError(ErrorCodes.WebhookTokenUnavailable);\n\n    const data = await this.client.rest.post(Routes.webhookPlatform(this.id, this.token, 'slack'), {\n      query: makeURLSearchParams({ wait: true }),\n      auth: false,\n      body,\n    });\n    return data.toString() === 'ok';\n  }\n\n  /**\n   * Options used to edit a {@link Webhook}.\n   * @typedef {Object} WebhookEditData\n   * @property {string} [name=this.name] The new name for the webhook\n   * @property {?(BufferResolvable)} [avatar] The new avatar for the webhook\n   * @property {GuildTextChannelResolvable} [channel] The new channel for the webhook\n   * @property {string} [reason] Reason for editing the webhook\n   */\n\n  /**\n   * Edits this webhook.\n   * @param {WebhookEditData} options Options for editing the webhook\n   * @returns {Promise<Webhook>}\n   */\n  async edit({ name = this.name, avatar, channel, reason }) {\n    if (avatar && !(typeof avatar === 'string' && avatar.startsWith('data:'))) {\n      avatar = await DataResolver.resolveImage(avatar);\n    }\n    channel &&= channel.id ?? channel;\n    const data = await this.client.rest.patch(Routes.webhook(this.id, channel ? undefined : this.token), {\n      body: { name, avatar, channel_id: channel },\n      reason,\n      auth: !this.token || Boolean(channel),\n    });\n\n    this.name = data.name;\n    this.avatar = data.avatar;\n    this.channelId = data.channel_id;\n    return this;\n  }\n\n  /**\n   * Options that can be passed into fetchMessage.\n   * @typedef {options} WebhookFetchMessageOptions\n   * @property {boolean} [cache=true] Whether to cache the message.\n   * @property {Snowflake} [threadId] The id of the thread this message belongs to.\n   * <info>For interaction webhooks, this property is ignored</info>\n   */\n\n  /**\n   * Gets a message that was sent by this webhook.\n   * @param {Snowflake|'@original'} message The id of the message to fetch\n   * @param {WebhookFetchMessageOptions} [options={}] The options to provide to fetch the message.\n   * @returns {Promise<Message>} Returns the message sent by this webhook\n   */\n  async fetchMessage(message, { threadId } = {}) {\n    if (!this.token) throw new DiscordjsError(ErrorCodes.WebhookTokenUnavailable);\n\n    const data = await this.client.rest.get(Routes.webhookMessage(this.id, this.token, message), {\n      query: threadId ? makeURLSearchParams({ thread_id: threadId }) : undefined,\n      auth: false,\n    });\n\n    if (!this.client.channels) return data;\n    return (\n      this.client.channels.cache.get(data.channel_id)?.messages._add(data, false) ??\n      new (getMessage())(this.client, data)\n    );\n  }\n\n  /**\n   * Edits a message that was sent by this webhook.\n   * @param {MessageResolvable|'@original'} message The message to edit\n   * @param {string|MessagePayload|WebhookEditMessageOptions} options The options to provide\n   * @returns {Promise<Message>} Returns the message edited by this webhook\n   */\n  async editMessage(message, options) {\n    if (!this.token) throw new DiscordjsError(ErrorCodes.WebhookTokenUnavailable);\n\n    let messagePayload;\n\n    if (options instanceof MessagePayload) messagePayload = options;\n    else messagePayload = MessagePayload.create(this, options);\n\n    const { body, files } = await messagePayload.resolveBody().resolveFiles();\n\n    const d = await this.client.rest.patch(\n      Routes.webhookMessage(this.id, this.token, typeof message === 'string' ? message : message.id),\n      {\n        body,\n        files,\n        query: messagePayload.options.threadId\n          ? makeURLSearchParams({ thread_id: messagePayload.options.threadId })\n          : undefined,\n        auth: false,\n      },\n    );\n\n    const channelManager = this.client.channels;\n    if (!channelManager) return d;\n\n    const messageManager = channelManager.cache.get(d.channel_id)?.messages;\n    if (!messageManager) return new (getMessage())(this.client, d);\n\n    const existing = messageManager.cache.get(d.id);\n    if (!existing) return messageManager._add(d);\n\n    const clone = existing._clone();\n    clone._patch(d);\n    return clone;\n  }\n\n  /**\n   * Deletes the webhook.\n   * @param {string} [reason] Reason for deleting this webhook\n   * @returns {Promise<void>}\n   */\n  async delete(reason) {\n    await this.client.rest.delete(Routes.webhook(this.id, this.token), {\n      reason,\n      auth: !this.token,\n    });\n  }\n\n  /**\n   * Delete a message that was sent by this webhook.\n   * @param {MessageResolvable|'@original'} message The message to delete\n   * @param {Snowflake} [threadId] The id of the thread this message belongs to\n   * @returns {Promise<void>}\n   */\n  async deleteMessage(message, threadId) {\n    if (!this.token) throw new DiscordjsError(ErrorCodes.WebhookTokenUnavailable);\n\n    await this.client.rest.delete(\n      Routes.webhookMessage(this.id, this.token, typeof message === 'string' ? message : message.id),\n      {\n        query: threadId ? makeURLSearchParams({ thread_id: threadId }) : undefined,\n        auth: false,\n      },\n    );\n  }\n\n  /**\n   * The timestamp the webhook was created at\n   * @type {number}\n   * @readonly\n   */\n  get createdTimestamp() {\n    return DiscordSnowflake.timestampFrom(this.id);\n  }\n\n  /**\n   * The time the webhook was created at\n   * @type {Date}\n   * @readonly\n   */\n  get createdAt() {\n    return new Date(this.createdTimestamp);\n  }\n\n  /**\n   * The URL of this webhook\n   * @type {string}\n   * @readonly\n   */\n  get url() {\n    return this.client.options.rest.api + Routes.webhook(this.id, this.token);\n  }\n\n  /**\n   * A link to the webhook's avatar.\n   * @param {ImageURLOptions} [options={}] Options for the image URL\n   * @returns {?string}\n   */\n  avatarURL(options = {}) {\n    return this.avatar && this.client.rest.cdn.avatar(this.id, this.avatar, options);\n  }\n\n  /**\n   * Whether this webhook is created by a user.\n   * @returns {boolean}\n   */\n  isUserCreated() {\n    return Boolean(this.type === WebhookType.Incoming && this.owner && !this.owner.bot);\n  }\n\n  /**\n   * Whether this webhook is created by an application.\n   * @returns {boolean}\n   */\n  isApplicationCreated() {\n    return this.type === WebhookType.Application;\n  }\n\n  /**\n   * Whether or not this webhook is a channel follower webhook.\n   * @returns {boolean}\n   */\n  isChannelFollower() {\n    return this.type === WebhookType.ChannelFollower;\n  }\n\n  /**\n   * Whether or not this webhook is an incoming webhook.\n   * @returns {boolean}\n   */\n  isIncoming() {\n    return this.type === WebhookType.Incoming;\n  }\n\n  static applyToClass(structure, ignore = []) {\n    for (const prop of [\n      'send',\n      'sendSlackMessage',\n      'fetchMessage',\n      'edit',\n      'editMessage',\n      'delete',\n      'deleteMessage',\n      'createdTimestamp',\n      'createdAt',\n      'url',\n    ]) {\n      if (ignore.includes(prop)) continue;\n      Object.defineProperty(structure.prototype, prop, Object.getOwnPropertyDescriptor(Webhook.prototype, prop));\n    }\n  }\n}\n\nmodule.exports = Webhook;\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}