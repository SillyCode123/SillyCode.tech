{"ast":null,"code":"'use strict';\n\nconst {\n  DiscordSnowflake\n} = require('@sapphire/snowflake');\nconst {\n  PermissionFlagsBits\n} = require('discord-api-types/v10');\nconst Base = require('./Base');\nconst {\n  DiscordjsError,\n  ErrorCodes\n} = require('../errors');\nconst PermissionsBitField = require('../util/PermissionsBitField');\n\n/**\n * Represents a role on Discord.\n * @extends {Base}\n */\nclass Role extends Base {\n  constructor(client, data, guild) {\n    super(client);\n\n    /**\n     * The guild that the role belongs to\n     * @type {Guild}\n     */\n    this.guild = guild;\n\n    /**\n     * The icon hash of the role\n     * @type {?string}\n     */\n    this.icon = null;\n\n    /**\n     * The unicode emoji for the role\n     * @type {?string}\n     */\n    this.unicodeEmoji = null;\n    if (data) this._patch(data);\n  }\n  _patch(data) {\n    /**\n     * The role's id (unique to the guild it is part of)\n     * @type {Snowflake}\n     */\n    this.id = data.id;\n    if ('name' in data) {\n      /**\n       * The name of the role\n       * @type {string}\n       */\n      this.name = data.name;\n    }\n    if ('color' in data) {\n      /**\n       * The base 10 color of the role\n       * @type {number}\n       */\n      this.color = data.color;\n    }\n    if ('hoist' in data) {\n      /**\n       * If true, users that are part of this role will appear in a separate category in the users list\n       * @type {boolean}\n       */\n      this.hoist = data.hoist;\n    }\n    if ('position' in data) {\n      /**\n       * The raw position of the role from the API\n       * @type {number}\n       */\n      this.rawPosition = data.position;\n    }\n    if ('permissions' in data) {\n      /**\n       * The permissions of the role\n       * @type {Readonly<PermissionsBitField>}\n       */\n      this.permissions = new PermissionsBitField(BigInt(data.permissions)).freeze();\n    }\n    if ('managed' in data) {\n      /**\n       * Whether or not the role is managed by an external service\n       * @type {boolean}\n       */\n      this.managed = data.managed;\n    }\n    if ('mentionable' in data) {\n      /**\n       * Whether or not the role can be mentioned by anyone\n       * @type {boolean}\n       */\n      this.mentionable = data.mentionable;\n    }\n    if ('icon' in data) this.icon = data.icon;\n    if ('unicode_emoji' in data) this.unicodeEmoji = data.unicode_emoji;\n\n    /**\n     * The tags this role has\n     * @type {?Object}\n     * @property {Snowflake} [botId] The id of the bot this role belongs to\n     * @property {Snowflake|string} [integrationId] The id of the integration this role belongs to\n     * @property {true} [premiumSubscriberRole] Whether this is the guild's premium subscription role\n     */\n    this.tags = data.tags ? {} : null;\n    if (data.tags) {\n      if ('bot_id' in data.tags) {\n        this.tags.botId = data.tags.bot_id;\n      }\n      if ('integration_id' in data.tags) {\n        this.tags.integrationId = data.tags.integration_id;\n      }\n      if ('premium_subscriber' in data.tags) {\n        this.tags.premiumSubscriberRole = true;\n      }\n    }\n  }\n\n  /**\n   * The timestamp the role was created at\n   * @type {number}\n   * @readonly\n   */\n  get createdTimestamp() {\n    return DiscordSnowflake.timestampFrom(this.id);\n  }\n\n  /**\n   * The time the role was created at\n   * @type {Date}\n   * @readonly\n   */\n  get createdAt() {\n    return new Date(this.createdTimestamp);\n  }\n\n  /**\n   * The hexadecimal version of the role color, with a leading hashtag\n   * @type {string}\n   * @readonly\n   */\n  get hexColor() {\n    return `#${this.color.toString(16).padStart(6, '0')}`;\n  }\n\n  /**\n   * The cached guild members that have this role\n   * @type {Collection<Snowflake, GuildMember>}\n   * @readonly\n   */\n  get members() {\n    return this.guild.members.cache.filter(m => m.roles.cache.has(this.id));\n  }\n\n  /**\n   * Whether the role is editable by the client user\n   * @type {boolean}\n   * @readonly\n   */\n  get editable() {\n    if (this.managed) return false;\n    const clientMember = this.guild.members.resolve(this.client.user);\n    if (!clientMember.permissions.has(PermissionFlagsBits.ManageRoles)) return false;\n    return clientMember.roles.highest.comparePositionTo(this) > 0;\n  }\n\n  /**\n   * The position of the role in the role manager\n   * @type {number}\n   * @readonly\n   */\n  get position() {\n    const sorted = this.guild._sortedRoles();\n    return [...sorted.values()].indexOf(sorted.get(this.id));\n  }\n\n  /**\n   * Compares this role's position to another role's.\n   * @param {RoleResolvable} role Role to compare to this one\n   * @returns {number} Negative number if this role's position is lower (other role's is higher),\n   * positive number if this one is higher (other's is lower), 0 if equal\n   */\n  comparePositionTo(role) {\n    return this.guild.roles.comparePositions(this, role);\n  }\n\n  /**\n   * The data for a role.\n   * @typedef {Object} RoleData\n   * @property {string} [name] The name of the role\n   * @property {ColorResolvable} [color] The color of the role, either a hex string or a base 10 number\n   * @property {boolean} [hoist] Whether or not the role should be hoisted\n   * @property {number} [position] The position of the role\n   * @property {PermissionResolvable} [permissions] The permissions of the role\n   * @property {boolean} [mentionable] Whether or not the role should be mentionable\n   * @property {?(BufferResolvable|Base64Resolvable|EmojiResolvable)} [icon] The icon for the role\n   * <warn>The `EmojiResolvable` should belong to the same guild as the role.\n   * If not, pass the emoji's URL directly</warn>\n   * @property {?string} [unicodeEmoji] The unicode emoji for the role\n   */\n\n  /**\n   * Edits the role.\n   * @param {EditRoleOptions} data The new data for the role\n   * @returns {Promise<Role>}\n   * @example\n   * // Edit a role\n   * role.edit({ name: 'new role' })\n   *   .then(updated => console.log(`Edited role name to ${updated.name}`))\n   *   .catch(console.error);\n   */\n  edit(data) {\n    return this.guild.roles.edit(this, data);\n  }\n\n  /**\n   * Returns `channel.permissionsFor(role)`. Returns permissions for a role in a guild channel,\n   * taking into account permission overwrites.\n   * @param {GuildChannel|Snowflake} channel The guild channel to use as context\n   * @param {boolean} [checkAdmin=true] Whether having the {@link PermissionFlagsBits.Administrator} permission\n   * will return all permissions\n   * @returns {Readonly<PermissionsBitField>}\n   */\n  permissionsIn(channel) {\n    let checkAdmin = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\n    channel = this.guild.channels.resolve(channel);\n    if (!channel) throw new DiscordjsError(ErrorCodes.GuildChannelResolve);\n    return channel.rolePermissions(this, checkAdmin);\n  }\n\n  /**\n   * Sets a new name for the role.\n   * @param {string} name The new name of the role\n   * @param {string} [reason] Reason for changing the role's name\n   * @returns {Promise<Role>}\n   * @example\n   * // Set the name of the role\n   * role.setName('new role')\n   *   .then(updated => console.log(`Updated role name to ${updated.name}`))\n   *   .catch(console.error);\n   */\n  setName(name, reason) {\n    return this.edit({\n      name,\n      reason\n    });\n  }\n\n  /**\n   * Sets a new color for the role.\n   * @param {ColorResolvable} color The color of the role\n   * @param {string} [reason] Reason for changing the role's color\n   * @returns {Promise<Role>}\n   * @example\n   * // Set the color of a role\n   * role.setColor('#FF0000')\n   *   .then(updated => console.log(`Set color of role to ${updated.color}`))\n   *   .catch(console.error);\n   */\n  setColor(color, reason) {\n    return this.edit({\n      color,\n      reason\n    });\n  }\n\n  /**\n   * Sets whether or not the role should be hoisted.\n   * @param {boolean} [hoist=true] Whether or not to hoist the role\n   * @param {string} [reason] Reason for setting whether or not the role should be hoisted\n   * @returns {Promise<Role>}\n   * @example\n   * // Set the hoist of the role\n   * role.setHoist(true)\n   *   .then(updated => console.log(`Role hoisted: ${updated.hoist}`))\n   *   .catch(console.error);\n   */\n  setHoist() {\n    let hoist = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;\n    let reason = arguments.length > 1 ? arguments[1] : undefined;\n    return this.edit({\n      hoist,\n      reason\n    });\n  }\n\n  /**\n   * Sets the permissions of the role.\n   * @param {PermissionResolvable} permissions The permissions of the role\n   * @param {string} [reason] Reason for changing the role's permissions\n   * @returns {Promise<Role>}\n   * @example\n   * // Set the permissions of the role\n   * role.setPermissions([PermissionFlagsBits.KickMembers, PermissionFlagsBits.BanMembers])\n   *   .then(updated => console.log(`Updated permissions to ${updated.permissions.bitfield}`))\n   *   .catch(console.error);\n   * @example\n   * // Remove all permissions from a role\n   * role.setPermissions(0n)\n   *   .then(updated => console.log(`Updated permissions to ${updated.permissions.bitfield}`))\n   *   .catch(console.error);\n   */\n  setPermissions(permissions, reason) {\n    return this.edit({\n      permissions,\n      reason\n    });\n  }\n\n  /**\n   * Sets whether this role is mentionable.\n   * @param {boolean} [mentionable=true] Whether this role should be mentionable\n   * @param {string} [reason] Reason for setting whether or not this role should be mentionable\n   * @returns {Promise<Role>}\n   * @example\n   * // Make the role mentionable\n   * role.setMentionable(true)\n   *   .then(updated => console.log(`Role updated ${updated.name}`))\n   *   .catch(console.error);\n   */\n  setMentionable() {\n    let mentionable = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;\n    let reason = arguments.length > 1 ? arguments[1] : undefined;\n    return this.edit({\n      mentionable,\n      reason\n    });\n  }\n\n  /**\n   * Sets a new icon for the role.\n   * @param {?(BufferResolvable|Base64Resolvable|EmojiResolvable)} icon The icon for the role\n   * <warn>The `EmojiResolvable` should belong to the same guild as the role.\n   * If not, pass the emoji's URL directly</warn>\n   * @param {string} [reason] Reason for changing the role's icon\n   * @returns {Promise<Role>}\n   */\n  setIcon(icon, reason) {\n    return this.edit({\n      icon,\n      reason\n    });\n  }\n\n  /**\n   * Sets a new unicode emoji for the role.\n   * @param {?string} unicodeEmoji The new unicode emoji for the role\n   * @param {string} [reason] Reason for changing the role's unicode emoji\n   * @returns {Promise<Role>}\n   * @example\n   * // Set a new unicode emoji for the role\n   * role.setUnicodeEmoji('🤖')\n   *   .then(updated => console.log(`Set unicode emoji for the role to ${updated.unicodeEmoji}`))\n   *   .catch(console.error);\n   */\n  setUnicodeEmoji(unicodeEmoji, reason) {\n    return this.edit({\n      unicodeEmoji,\n      reason\n    });\n  }\n\n  /**\n   * Options used to set the position of a role.\n   * @typedef {Object} SetRolePositionOptions\n   * @property {boolean} [relative=false] Whether to change the position relative to its current value or not\n   * @property {string} [reason] The reason for changing the position\n   */\n\n  /**\n   * Sets the new position of the role.\n   * @param {number} position The new position for the role\n   * @param {SetRolePositionOptions} [options] Options for setting the position\n   * @returns {Promise<Role>}\n   * @example\n   * // Set the position of the role\n   * role.setPosition(1)\n   *   .then(updated => console.log(`Role position: ${updated.position}`))\n   *   .catch(console.error);\n   */\n  setPosition(position) {\n    let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    return this.guild.roles.setPosition(this, position, options);\n  }\n\n  /**\n   * Deletes the role.\n   * @param {string} [reason] Reason for deleting this role\n   * @returns {Promise<Role>}\n   * @example\n   * // Delete a role\n   * role.delete('The role needed to go')\n   *   .then(deleted => console.log(`Deleted role ${deleted.name}`))\n   *   .catch(console.error);\n   */\n  async delete(reason) {\n    await this.guild.roles.delete(this.id, reason);\n    return this;\n  }\n\n  /**\n   * A link to the role's icon\n   * @param {ImageURLOptions} [options={}] Options for the image URL\n   * @returns {?string}\n   */\n  iconURL() {\n    let options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    return this.icon && this.client.rest.cdn.roleIcon(this.id, this.icon, options);\n  }\n\n  /**\n   * Whether this role equals another role. It compares all properties, so for most operations\n   * it is advisable to just compare `role.id === role2.id` as it is much faster and is often\n   * what most users need.\n   * @param {Role} role Role to compare with\n   * @returns {boolean}\n   */\n  equals(role) {\n    return role && this.id === role.id && this.name === role.name && this.color === role.color && this.hoist === role.hoist && this.position === role.position && this.permissions.bitfield === role.permissions.bitfield && this.managed === role.managed && this.icon === role.icon && this.unicodeEmoji === role.unicodeEmoji;\n  }\n\n  /**\n   * When concatenated with a string, this automatically returns the role's mention instead of the Role object.\n   * @returns {string}\n   * @example\n   * // Logs: Role: <@&123456789012345678>\n   * console.log(`Role: ${role}`);\n   */\n  toString() {\n    if (this.id === this.guild.id) return '@everyone';\n    return `<@&${this.id}>`;\n  }\n  toJSON() {\n    return {\n      ...super.toJSON({\n        createdTimestamp: true\n      }),\n      permissions: this.permissions.toJSON()\n    };\n  }\n}\nexports.Role = Role;\n\n/**\n * @external APIRole\n * @see {@link https://discord.com/developers/docs/topics/permissions#role-object}\n */","map":{"version":3,"names":["DiscordSnowflake","require","PermissionFlagsBits","Base","DiscordjsError","ErrorCodes","PermissionsBitField","Role","constructor","client","data","guild","icon","unicodeEmoji","_patch","id","name","color","hoist","rawPosition","position","permissions","BigInt","freeze","managed","mentionable","unicode_emoji","tags","botId","bot_id","integrationId","integration_id","premiumSubscriberRole","createdTimestamp","timestampFrom","createdAt","Date","hexColor","toString","padStart","members","cache","filter","m","roles","has","editable","clientMember","resolve","user","ManageRoles","highest","comparePositionTo","sorted","_sortedRoles","values","indexOf","get","role","comparePositions","edit","permissionsIn","channel","checkAdmin","channels","GuildChannelResolve","rolePermissions","setName","reason","setColor","setHoist","setPermissions","setMentionable","setIcon","setUnicodeEmoji","setPosition","options","delete","iconURL","rest","cdn","roleIcon","equals","bitfield","toJSON","exports"],"sources":["J:/Coding/Projekts/Web/JavaScript/sillcode.tech/node_modules/discord.js/src/structures/Role.js"],"sourcesContent":["'use strict';\n\nconst { DiscordSnowflake } = require('@sapphire/snowflake');\nconst { PermissionFlagsBits } = require('discord-api-types/v10');\nconst Base = require('./Base');\nconst { DiscordjsError, ErrorCodes } = require('../errors');\nconst PermissionsBitField = require('../util/PermissionsBitField');\n\n/**\n * Represents a role on Discord.\n * @extends {Base}\n */\nclass Role extends Base {\n  constructor(client, data, guild) {\n    super(client);\n\n    /**\n     * The guild that the role belongs to\n     * @type {Guild}\n     */\n    this.guild = guild;\n\n    /**\n     * The icon hash of the role\n     * @type {?string}\n     */\n    this.icon = null;\n\n    /**\n     * The unicode emoji for the role\n     * @type {?string}\n     */\n    this.unicodeEmoji = null;\n\n    if (data) this._patch(data);\n  }\n\n  _patch(data) {\n    /**\n     * The role's id (unique to the guild it is part of)\n     * @type {Snowflake}\n     */\n    this.id = data.id;\n    if ('name' in data) {\n      /**\n       * The name of the role\n       * @type {string}\n       */\n      this.name = data.name;\n    }\n\n    if ('color' in data) {\n      /**\n       * The base 10 color of the role\n       * @type {number}\n       */\n      this.color = data.color;\n    }\n\n    if ('hoist' in data) {\n      /**\n       * If true, users that are part of this role will appear in a separate category in the users list\n       * @type {boolean}\n       */\n      this.hoist = data.hoist;\n    }\n\n    if ('position' in data) {\n      /**\n       * The raw position of the role from the API\n       * @type {number}\n       */\n      this.rawPosition = data.position;\n    }\n\n    if ('permissions' in data) {\n      /**\n       * The permissions of the role\n       * @type {Readonly<PermissionsBitField>}\n       */\n      this.permissions = new PermissionsBitField(BigInt(data.permissions)).freeze();\n    }\n\n    if ('managed' in data) {\n      /**\n       * Whether or not the role is managed by an external service\n       * @type {boolean}\n       */\n      this.managed = data.managed;\n    }\n\n    if ('mentionable' in data) {\n      /**\n       * Whether or not the role can be mentioned by anyone\n       * @type {boolean}\n       */\n      this.mentionable = data.mentionable;\n    }\n\n    if ('icon' in data) this.icon = data.icon;\n\n    if ('unicode_emoji' in data) this.unicodeEmoji = data.unicode_emoji;\n\n    /**\n     * The tags this role has\n     * @type {?Object}\n     * @property {Snowflake} [botId] The id of the bot this role belongs to\n     * @property {Snowflake|string} [integrationId] The id of the integration this role belongs to\n     * @property {true} [premiumSubscriberRole] Whether this is the guild's premium subscription role\n     */\n    this.tags = data.tags ? {} : null;\n    if (data.tags) {\n      if ('bot_id' in data.tags) {\n        this.tags.botId = data.tags.bot_id;\n      }\n      if ('integration_id' in data.tags) {\n        this.tags.integrationId = data.tags.integration_id;\n      }\n      if ('premium_subscriber' in data.tags) {\n        this.tags.premiumSubscriberRole = true;\n      }\n    }\n  }\n\n  /**\n   * The timestamp the role was created at\n   * @type {number}\n   * @readonly\n   */\n  get createdTimestamp() {\n    return DiscordSnowflake.timestampFrom(this.id);\n  }\n\n  /**\n   * The time the role was created at\n   * @type {Date}\n   * @readonly\n   */\n  get createdAt() {\n    return new Date(this.createdTimestamp);\n  }\n\n  /**\n   * The hexadecimal version of the role color, with a leading hashtag\n   * @type {string}\n   * @readonly\n   */\n  get hexColor() {\n    return `#${this.color.toString(16).padStart(6, '0')}`;\n  }\n\n  /**\n   * The cached guild members that have this role\n   * @type {Collection<Snowflake, GuildMember>}\n   * @readonly\n   */\n  get members() {\n    return this.guild.members.cache.filter(m => m.roles.cache.has(this.id));\n  }\n\n  /**\n   * Whether the role is editable by the client user\n   * @type {boolean}\n   * @readonly\n   */\n  get editable() {\n    if (this.managed) return false;\n    const clientMember = this.guild.members.resolve(this.client.user);\n    if (!clientMember.permissions.has(PermissionFlagsBits.ManageRoles)) return false;\n    return clientMember.roles.highest.comparePositionTo(this) > 0;\n  }\n\n  /**\n   * The position of the role in the role manager\n   * @type {number}\n   * @readonly\n   */\n  get position() {\n    const sorted = this.guild._sortedRoles();\n    return [...sorted.values()].indexOf(sorted.get(this.id));\n  }\n\n  /**\n   * Compares this role's position to another role's.\n   * @param {RoleResolvable} role Role to compare to this one\n   * @returns {number} Negative number if this role's position is lower (other role's is higher),\n   * positive number if this one is higher (other's is lower), 0 if equal\n   */\n  comparePositionTo(role) {\n    return this.guild.roles.comparePositions(this, role);\n  }\n\n  /**\n   * The data for a role.\n   * @typedef {Object} RoleData\n   * @property {string} [name] The name of the role\n   * @property {ColorResolvable} [color] The color of the role, either a hex string or a base 10 number\n   * @property {boolean} [hoist] Whether or not the role should be hoisted\n   * @property {number} [position] The position of the role\n   * @property {PermissionResolvable} [permissions] The permissions of the role\n   * @property {boolean} [mentionable] Whether or not the role should be mentionable\n   * @property {?(BufferResolvable|Base64Resolvable|EmojiResolvable)} [icon] The icon for the role\n   * <warn>The `EmojiResolvable` should belong to the same guild as the role.\n   * If not, pass the emoji's URL directly</warn>\n   * @property {?string} [unicodeEmoji] The unicode emoji for the role\n   */\n\n  /**\n   * Edits the role.\n   * @param {EditRoleOptions} data The new data for the role\n   * @returns {Promise<Role>}\n   * @example\n   * // Edit a role\n   * role.edit({ name: 'new role' })\n   *   .then(updated => console.log(`Edited role name to ${updated.name}`))\n   *   .catch(console.error);\n   */\n  edit(data) {\n    return this.guild.roles.edit(this, data);\n  }\n\n  /**\n   * Returns `channel.permissionsFor(role)`. Returns permissions for a role in a guild channel,\n   * taking into account permission overwrites.\n   * @param {GuildChannel|Snowflake} channel The guild channel to use as context\n   * @param {boolean} [checkAdmin=true] Whether having the {@link PermissionFlagsBits.Administrator} permission\n   * will return all permissions\n   * @returns {Readonly<PermissionsBitField>}\n   */\n  permissionsIn(channel, checkAdmin = true) {\n    channel = this.guild.channels.resolve(channel);\n    if (!channel) throw new DiscordjsError(ErrorCodes.GuildChannelResolve);\n    return channel.rolePermissions(this, checkAdmin);\n  }\n\n  /**\n   * Sets a new name for the role.\n   * @param {string} name The new name of the role\n   * @param {string} [reason] Reason for changing the role's name\n   * @returns {Promise<Role>}\n   * @example\n   * // Set the name of the role\n   * role.setName('new role')\n   *   .then(updated => console.log(`Updated role name to ${updated.name}`))\n   *   .catch(console.error);\n   */\n  setName(name, reason) {\n    return this.edit({ name, reason });\n  }\n\n  /**\n   * Sets a new color for the role.\n   * @param {ColorResolvable} color The color of the role\n   * @param {string} [reason] Reason for changing the role's color\n   * @returns {Promise<Role>}\n   * @example\n   * // Set the color of a role\n   * role.setColor('#FF0000')\n   *   .then(updated => console.log(`Set color of role to ${updated.color}`))\n   *   .catch(console.error);\n   */\n  setColor(color, reason) {\n    return this.edit({ color, reason });\n  }\n\n  /**\n   * Sets whether or not the role should be hoisted.\n   * @param {boolean} [hoist=true] Whether or not to hoist the role\n   * @param {string} [reason] Reason for setting whether or not the role should be hoisted\n   * @returns {Promise<Role>}\n   * @example\n   * // Set the hoist of the role\n   * role.setHoist(true)\n   *   .then(updated => console.log(`Role hoisted: ${updated.hoist}`))\n   *   .catch(console.error);\n   */\n  setHoist(hoist = true, reason) {\n    return this.edit({ hoist, reason });\n  }\n\n  /**\n   * Sets the permissions of the role.\n   * @param {PermissionResolvable} permissions The permissions of the role\n   * @param {string} [reason] Reason for changing the role's permissions\n   * @returns {Promise<Role>}\n   * @example\n   * // Set the permissions of the role\n   * role.setPermissions([PermissionFlagsBits.KickMembers, PermissionFlagsBits.BanMembers])\n   *   .then(updated => console.log(`Updated permissions to ${updated.permissions.bitfield}`))\n   *   .catch(console.error);\n   * @example\n   * // Remove all permissions from a role\n   * role.setPermissions(0n)\n   *   .then(updated => console.log(`Updated permissions to ${updated.permissions.bitfield}`))\n   *   .catch(console.error);\n   */\n  setPermissions(permissions, reason) {\n    return this.edit({ permissions, reason });\n  }\n\n  /**\n   * Sets whether this role is mentionable.\n   * @param {boolean} [mentionable=true] Whether this role should be mentionable\n   * @param {string} [reason] Reason for setting whether or not this role should be mentionable\n   * @returns {Promise<Role>}\n   * @example\n   * // Make the role mentionable\n   * role.setMentionable(true)\n   *   .then(updated => console.log(`Role updated ${updated.name}`))\n   *   .catch(console.error);\n   */\n  setMentionable(mentionable = true, reason) {\n    return this.edit({ mentionable, reason });\n  }\n\n  /**\n   * Sets a new icon for the role.\n   * @param {?(BufferResolvable|Base64Resolvable|EmojiResolvable)} icon The icon for the role\n   * <warn>The `EmojiResolvable` should belong to the same guild as the role.\n   * If not, pass the emoji's URL directly</warn>\n   * @param {string} [reason] Reason for changing the role's icon\n   * @returns {Promise<Role>}\n   */\n  setIcon(icon, reason) {\n    return this.edit({ icon, reason });\n  }\n\n  /**\n   * Sets a new unicode emoji for the role.\n   * @param {?string} unicodeEmoji The new unicode emoji for the role\n   * @param {string} [reason] Reason for changing the role's unicode emoji\n   * @returns {Promise<Role>}\n   * @example\n   * // Set a new unicode emoji for the role\n   * role.setUnicodeEmoji('🤖')\n   *   .then(updated => console.log(`Set unicode emoji for the role to ${updated.unicodeEmoji}`))\n   *   .catch(console.error);\n   */\n  setUnicodeEmoji(unicodeEmoji, reason) {\n    return this.edit({ unicodeEmoji, reason });\n  }\n\n  /**\n   * Options used to set the position of a role.\n   * @typedef {Object} SetRolePositionOptions\n   * @property {boolean} [relative=false] Whether to change the position relative to its current value or not\n   * @property {string} [reason] The reason for changing the position\n   */\n\n  /**\n   * Sets the new position of the role.\n   * @param {number} position The new position for the role\n   * @param {SetRolePositionOptions} [options] Options for setting the position\n   * @returns {Promise<Role>}\n   * @example\n   * // Set the position of the role\n   * role.setPosition(1)\n   *   .then(updated => console.log(`Role position: ${updated.position}`))\n   *   .catch(console.error);\n   */\n  setPosition(position, options = {}) {\n    return this.guild.roles.setPosition(this, position, options);\n  }\n\n  /**\n   * Deletes the role.\n   * @param {string} [reason] Reason for deleting this role\n   * @returns {Promise<Role>}\n   * @example\n   * // Delete a role\n   * role.delete('The role needed to go')\n   *   .then(deleted => console.log(`Deleted role ${deleted.name}`))\n   *   .catch(console.error);\n   */\n  async delete(reason) {\n    await this.guild.roles.delete(this.id, reason);\n    return this;\n  }\n\n  /**\n   * A link to the role's icon\n   * @param {ImageURLOptions} [options={}] Options for the image URL\n   * @returns {?string}\n   */\n  iconURL(options = {}) {\n    return this.icon && this.client.rest.cdn.roleIcon(this.id, this.icon, options);\n  }\n\n  /**\n   * Whether this role equals another role. It compares all properties, so for most operations\n   * it is advisable to just compare `role.id === role2.id` as it is much faster and is often\n   * what most users need.\n   * @param {Role} role Role to compare with\n   * @returns {boolean}\n   */\n  equals(role) {\n    return (\n      role &&\n      this.id === role.id &&\n      this.name === role.name &&\n      this.color === role.color &&\n      this.hoist === role.hoist &&\n      this.position === role.position &&\n      this.permissions.bitfield === role.permissions.bitfield &&\n      this.managed === role.managed &&\n      this.icon === role.icon &&\n      this.unicodeEmoji === role.unicodeEmoji\n    );\n  }\n\n  /**\n   * When concatenated with a string, this automatically returns the role's mention instead of the Role object.\n   * @returns {string}\n   * @example\n   * // Logs: Role: <@&123456789012345678>\n   * console.log(`Role: ${role}`);\n   */\n  toString() {\n    if (this.id === this.guild.id) return '@everyone';\n    return `<@&${this.id}>`;\n  }\n\n  toJSON() {\n    return {\n      ...super.toJSON({ createdTimestamp: true }),\n      permissions: this.permissions.toJSON(),\n    };\n  }\n}\n\nexports.Role = Role;\n\n/**\n * @external APIRole\n * @see {@link https://discord.com/developers/docs/topics/permissions#role-object}\n */\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}