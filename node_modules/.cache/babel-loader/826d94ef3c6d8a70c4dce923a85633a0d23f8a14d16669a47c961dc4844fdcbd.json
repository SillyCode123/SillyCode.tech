{"ast":null,"code":"'use strict';\n\nconst {\n  Routes\n} = require('discord-api-types/v10');\nconst User = require('./User');\nconst DataResolver = require('../util/DataResolver');\n\n/**\n * Represents the logged in client's Discord user.\n * @extends {User}\n */\nclass ClientUser extends User {\n  _patch(data) {\n    super._patch(data);\n    if ('verified' in data) {\n      /**\n       * Whether or not this account has been verified\n       * @type {boolean}\n       */\n      this.verified = data.verified;\n    }\n    if ('mfa_enabled' in data) {\n      /**\n       * If the bot's {@link ClientApplication#owner Owner} has MFA enabled on their account\n       * @type {?boolean}\n       */\n      this.mfaEnabled = typeof data.mfa_enabled === 'boolean' ? data.mfa_enabled : null;\n    } else {\n      this.mfaEnabled ??= null;\n    }\n    if ('token' in data) this.client.token = data.token;\n  }\n\n  /**\n   * Represents the client user's presence\n   * @type {ClientPresence}\n   * @readonly\n   */\n  get presence() {\n    return this.client.presence;\n  }\n\n  /**\n   * Data used to edit the logged in client\n   * @typedef {Object} ClientUserEditData\n   * @property {string} [username] The new username\n   * @property {?(BufferResolvable|Base64Resolvable)} [avatar] The new avatar\n   */\n\n  /**\n   * Edits the logged in client.\n   * @param {ClientUserEditData} data The new data\n   * @returns {Promise<ClientUser>}\n   */\n  async edit(data) {\n    if (typeof data.avatar !== 'undefined') data.avatar = await DataResolver.resolveImage(data.avatar);\n    const newData = await this.client.rest.patch(Routes.user(), {\n      body: data\n    });\n    this.client.token = newData.token;\n    this.client.rest.setToken(newData.token);\n    const {\n      updated\n    } = this.client.actions.UserUpdate.handle(newData);\n    return updated ?? this;\n  }\n\n  /**\n   * Sets the username of the logged in client.\n   * <info>Changing usernames in Discord is heavily rate limited, with only 2 requests\n   * every hour. Use this sparingly!</info>\n   * @param {string} username The new username\n   * @returns {Promise<ClientUser>}\n   * @example\n   * // Set username\n   * client.user.setUsername('discordjs')\n   *   .then(user => console.log(`My new username is ${user.username}`))\n   *   .catch(console.error);\n   */\n  setUsername(username) {\n    return this.edit({\n      username\n    });\n  }\n\n  /**\n   * Sets the avatar of the logged in client.\n   * @param {?(BufferResolvable|Base64Resolvable)} avatar The new avatar\n   * @returns {Promise<ClientUser>}\n   * @example\n   * // Set avatar\n   * client.user.setAvatar('./avatar.png')\n   *   .then(user => console.log(`New avatar set!`))\n   *   .catch(console.error);\n   */\n  setAvatar(avatar) {\n    return this.edit({\n      avatar\n    });\n  }\n\n  /**\n   * Options for setting activities\n   * @typedef {Object} ActivitiesOptions\n   * @property {string} [name] Name of the activity\n   * @property {ActivityType} [type] Type of the activity\n   * @property {string} [url] Twitch / YouTube stream URL\n   */\n\n  /**\n   * Data resembling a raw Discord presence.\n   * @typedef {Object} PresenceData\n   * @property {PresenceStatusData} [status] Status of the user\n   * @property {boolean} [afk] Whether the user is AFK\n   * @property {ActivitiesOptions[]} [activities] Activity the user is playing\n   * @property {number|number[]} [shardId] Shard id(s) to have the activity set on\n   */\n\n  /**\n   * Sets the full presence of the client user.\n   * @param {PresenceData} data Data for the presence\n   * @returns {ClientPresence}\n   * @example\n   * // Set the client user's presence\n   * client.user.setPresence({ activities: [{ name: 'with discord.js' }], status: 'idle' });\n   */\n  setPresence(data) {\n    return this.client.presence.set(data);\n  }\n\n  /**\n   * A user's status. Must be one of:\n   * * `online`\n   * * `idle`\n   * * `invisible`\n   * * `dnd` (do not disturb)\n   * @typedef {string} PresenceStatusData\n   */\n\n  /**\n   * Sets the status of the client user.\n   * @param {PresenceStatusData} status Status to change to\n   * @param {number|number[]} [shardId] Shard id(s) to have the activity set on\n   * @returns {ClientPresence}\n   * @example\n   * // Set the client user's status\n   * client.user.setStatus('idle');\n   */\n  setStatus(status, shardId) {\n    return this.setPresence({\n      status,\n      shardId\n    });\n  }\n\n  /**\n   * Options for setting an activity.\n   * @typedef {Object} ActivityOptions\n   * @property {string} [name] Name of the activity\n   * @property {string} [url] Twitch / YouTube stream URL\n   * @property {ActivityType} [type] Type of the activity\n   * @property {number|number[]} [shardId] Shard Id(s) to have the activity set on\n   */\n\n  /**\n   * Sets the activity the client user is playing.\n   * @param {string|ActivityOptions} [name] Activity being played, or options for setting the activity\n   * @param {ActivityOptions} [options] Options for setting the activity\n   * @returns {ClientPresence}\n   * @example\n   * // Set the client user's activity\n   * client.user.setActivity('discord.js', { type: ActivityType.Watching });\n   */\n  setActivity(name) {\n    let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    if (!name) return this.setPresence({\n      activities: [],\n      shardId: options.shardId\n    });\n    const activity = Object.assign({}, options, typeof name === 'object' ? name : {\n      name\n    });\n    return this.setPresence({\n      activities: [activity],\n      shardId: activity.shardId\n    });\n  }\n\n  /**\n   * Sets/removes the AFK flag for the client user.\n   * @param {boolean} [afk=true] Whether or not the user is AFK\n   * @param {number|number[]} [shardId] Shard Id(s) to have the AFK flag set on\n   * @returns {ClientPresence}\n   */\n  setAFK() {\n    let afk = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;\n    let shardId = arguments.length > 1 ? arguments[1] : undefined;\n    return this.setPresence({\n      afk,\n      shardId\n    });\n  }\n}\nmodule.exports = ClientUser;","map":{"version":3,"names":["Routes","require","User","DataResolver","ClientUser","_patch","data","verified","mfaEnabled","mfa_enabled","client","token","presence","edit","avatar","resolveImage","newData","rest","patch","user","body","setToken","updated","actions","UserUpdate","handle","setUsername","username","setAvatar","setPresence","set","setStatus","status","shardId","setActivity","name","options","activities","activity","Object","assign","setAFK","afk","module","exports"],"sources":["J:/Coding/Projekts/Web/JavaScript/sillcode.tech/node_modules/discord.js/src/structures/ClientUser.js"],"sourcesContent":["'use strict';\n\nconst { Routes } = require('discord-api-types/v10');\nconst User = require('./User');\nconst DataResolver = require('../util/DataResolver');\n\n/**\n * Represents the logged in client's Discord user.\n * @extends {User}\n */\nclass ClientUser extends User {\n  _patch(data) {\n    super._patch(data);\n\n    if ('verified' in data) {\n      /**\n       * Whether or not this account has been verified\n       * @type {boolean}\n       */\n      this.verified = data.verified;\n    }\n\n    if ('mfa_enabled' in data) {\n      /**\n       * If the bot's {@link ClientApplication#owner Owner} has MFA enabled on their account\n       * @type {?boolean}\n       */\n      this.mfaEnabled = typeof data.mfa_enabled === 'boolean' ? data.mfa_enabled : null;\n    } else {\n      this.mfaEnabled ??= null;\n    }\n\n    if ('token' in data) this.client.token = data.token;\n  }\n\n  /**\n   * Represents the client user's presence\n   * @type {ClientPresence}\n   * @readonly\n   */\n  get presence() {\n    return this.client.presence;\n  }\n\n  /**\n   * Data used to edit the logged in client\n   * @typedef {Object} ClientUserEditData\n   * @property {string} [username] The new username\n   * @property {?(BufferResolvable|Base64Resolvable)} [avatar] The new avatar\n   */\n\n  /**\n   * Edits the logged in client.\n   * @param {ClientUserEditData} data The new data\n   * @returns {Promise<ClientUser>}\n   */\n  async edit(data) {\n    if (typeof data.avatar !== 'undefined') data.avatar = await DataResolver.resolveImage(data.avatar);\n    const newData = await this.client.rest.patch(Routes.user(), { body: data });\n    this.client.token = newData.token;\n    this.client.rest.setToken(newData.token);\n    const { updated } = this.client.actions.UserUpdate.handle(newData);\n    return updated ?? this;\n  }\n\n  /**\n   * Sets the username of the logged in client.\n   * <info>Changing usernames in Discord is heavily rate limited, with only 2 requests\n   * every hour. Use this sparingly!</info>\n   * @param {string} username The new username\n   * @returns {Promise<ClientUser>}\n   * @example\n   * // Set username\n   * client.user.setUsername('discordjs')\n   *   .then(user => console.log(`My new username is ${user.username}`))\n   *   .catch(console.error);\n   */\n  setUsername(username) {\n    return this.edit({ username });\n  }\n\n  /**\n   * Sets the avatar of the logged in client.\n   * @param {?(BufferResolvable|Base64Resolvable)} avatar The new avatar\n   * @returns {Promise<ClientUser>}\n   * @example\n   * // Set avatar\n   * client.user.setAvatar('./avatar.png')\n   *   .then(user => console.log(`New avatar set!`))\n   *   .catch(console.error);\n   */\n  setAvatar(avatar) {\n    return this.edit({ avatar });\n  }\n\n  /**\n   * Options for setting activities\n   * @typedef {Object} ActivitiesOptions\n   * @property {string} [name] Name of the activity\n   * @property {ActivityType} [type] Type of the activity\n   * @property {string} [url] Twitch / YouTube stream URL\n   */\n\n  /**\n   * Data resembling a raw Discord presence.\n   * @typedef {Object} PresenceData\n   * @property {PresenceStatusData} [status] Status of the user\n   * @property {boolean} [afk] Whether the user is AFK\n   * @property {ActivitiesOptions[]} [activities] Activity the user is playing\n   * @property {number|number[]} [shardId] Shard id(s) to have the activity set on\n   */\n\n  /**\n   * Sets the full presence of the client user.\n   * @param {PresenceData} data Data for the presence\n   * @returns {ClientPresence}\n   * @example\n   * // Set the client user's presence\n   * client.user.setPresence({ activities: [{ name: 'with discord.js' }], status: 'idle' });\n   */\n  setPresence(data) {\n    return this.client.presence.set(data);\n  }\n\n  /**\n   * A user's status. Must be one of:\n   * * `online`\n   * * `idle`\n   * * `invisible`\n   * * `dnd` (do not disturb)\n   * @typedef {string} PresenceStatusData\n   */\n\n  /**\n   * Sets the status of the client user.\n   * @param {PresenceStatusData} status Status to change to\n   * @param {number|number[]} [shardId] Shard id(s) to have the activity set on\n   * @returns {ClientPresence}\n   * @example\n   * // Set the client user's status\n   * client.user.setStatus('idle');\n   */\n  setStatus(status, shardId) {\n    return this.setPresence({ status, shardId });\n  }\n\n  /**\n   * Options for setting an activity.\n   * @typedef {Object} ActivityOptions\n   * @property {string} [name] Name of the activity\n   * @property {string} [url] Twitch / YouTube stream URL\n   * @property {ActivityType} [type] Type of the activity\n   * @property {number|number[]} [shardId] Shard Id(s) to have the activity set on\n   */\n\n  /**\n   * Sets the activity the client user is playing.\n   * @param {string|ActivityOptions} [name] Activity being played, or options for setting the activity\n   * @param {ActivityOptions} [options] Options for setting the activity\n   * @returns {ClientPresence}\n   * @example\n   * // Set the client user's activity\n   * client.user.setActivity('discord.js', { type: ActivityType.Watching });\n   */\n  setActivity(name, options = {}) {\n    if (!name) return this.setPresence({ activities: [], shardId: options.shardId });\n\n    const activity = Object.assign({}, options, typeof name === 'object' ? name : { name });\n    return this.setPresence({ activities: [activity], shardId: activity.shardId });\n  }\n\n  /**\n   * Sets/removes the AFK flag for the client user.\n   * @param {boolean} [afk=true] Whether or not the user is AFK\n   * @param {number|number[]} [shardId] Shard Id(s) to have the AFK flag set on\n   * @returns {ClientPresence}\n   */\n  setAFK(afk = true, shardId) {\n    return this.setPresence({ afk, shardId });\n  }\n}\n\nmodule.exports = ClientUser;\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}