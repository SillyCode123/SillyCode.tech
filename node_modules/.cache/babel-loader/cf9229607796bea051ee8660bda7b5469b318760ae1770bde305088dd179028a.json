{"ast":null,"code":"'use strict';\n\nconst process = require('node:process');\nconst {\n  Collection\n} = require('@discordjs/collection');\nconst {\n  ChannelType,\n  Routes\n} = require('discord-api-types/v10');\nconst CachedManager = require('./CachedManager');\nconst GuildTextThreadManager = require('./GuildTextThreadManager');\nconst {\n  DiscordjsError,\n  DiscordjsTypeError,\n  ErrorCodes\n} = require('../errors');\nconst GuildChannel = require('../structures/GuildChannel');\nconst PermissionOverwrites = require('../structures/PermissionOverwrites');\nconst ThreadChannel = require('../structures/ThreadChannel');\nconst Webhook = require('../structures/Webhook');\nconst ChannelFlagsBitField = require('../util/ChannelFlagsBitField');\nconst {\n  transformGuildForumTag,\n  transformGuildDefaultReaction\n} = require('../util/Channels');\nconst {\n  ThreadChannelTypes\n} = require('../util/Constants');\nconst DataResolver = require('../util/DataResolver');\nconst {\n  setPosition\n} = require('../util/Util');\nlet cacheWarningEmitted = false;\n\n/**\n * Manages API methods for GuildChannels and stores their cache.\n * @extends {CachedManager}\n */\nclass GuildChannelManager extends CachedManager {\n  constructor(guild, iterable) {\n    super(guild.client, GuildChannel, iterable);\n    const defaultCaching = this._cache.constructor.name === 'Collection' || this._cache.maxSize === undefined || this._cache.maxSize === Infinity;\n    if (!cacheWarningEmitted && !defaultCaching) {\n      cacheWarningEmitted = true;\n      process.emitWarning(`Overriding the cache handling for ${this.constructor.name} is unsupported and breaks functionality.`, 'UnsupportedCacheOverwriteWarning');\n    }\n\n    /**\n     * The guild this Manager belongs to\n     * @type {Guild}\n     */\n    this.guild = guild;\n  }\n\n  /**\n   * The number of channels in this managers cache excluding thread channels\n   * that do not count towards a guild's maximum channels restriction.\n   * @type {number}\n   * @readonly\n   */\n  get channelCountWithoutThreads() {\n    return this.cache.reduce((acc, channel) => {\n      if (ThreadChannelTypes.includes(channel.type)) return acc;\n      return ++acc;\n    }, 0);\n  }\n\n  /**\n   * The cache of this Manager\n   * @type {Collection<Snowflake, GuildChannel|ThreadChannel>}\n   * @name GuildChannelManager#cache\n   */\n\n  _add(channel) {\n    const existing = this.cache.get(channel.id);\n    if (existing) return existing;\n    this.cache.set(channel.id, channel);\n    return channel;\n  }\n\n  /**\n   * Data that can be resolved to give a Guild Channel object. This can be:\n   * * A GuildChannel object\n   * * A ThreadChannel object\n   * * A Snowflake\n   * @typedef {GuildChannel|ThreadChannel|Snowflake} GuildChannelResolvable\n   */\n\n  /**\n   * Resolves a GuildChannelResolvable to a Channel object.\n   * @param {GuildChannelResolvable} channel The GuildChannel resolvable to resolve\n   * @returns {?(GuildChannel|ThreadChannel)}\n   */\n  resolve(channel) {\n    if (channel instanceof ThreadChannel) return super.resolve(channel.id);\n    return super.resolve(channel);\n  }\n\n  /**\n   * Resolves a GuildChannelResolvable to a channel id.\n   * @param {GuildChannelResolvable} channel The GuildChannel resolvable to resolve\n   * @returns {?Snowflake}\n   */\n  resolveId(channel) {\n    if (channel instanceof ThreadChannel) return super.resolveId(channel.id);\n    return super.resolveId(channel);\n  }\n\n  /**\n   * Adds the target channel to a channel's followers.\n   * @param {NewsChannel|Snowflake} channel The channel to follow\n   * @param {TextChannelResolvable} targetChannel The channel where published announcements will be posted at\n   * @param {string} [reason] Reason for creating the webhook\n   * @returns {Promise<Snowflake>} Returns created target webhook id.\n   */\n  async addFollower(channel, targetChannel, reason) {\n    const channelId = this.resolveId(channel);\n    const targetChannelId = this.resolveId(targetChannel);\n    if (!channelId || !targetChannelId) throw new Error(ErrorCodes.GuildChannelResolve);\n    const {\n      webhook_id\n    } = await this.client.rest.post(Routes.channelFollowers(channelId), {\n      body: {\n        webhook_channel_id: targetChannelId\n      },\n      reason\n    });\n    return webhook_id;\n  }\n\n  /**\n   * Options used to create a new channel in a guild.\n   * @typedef {CategoryCreateChannelOptions} GuildChannelCreateOptions\n   * @property {?CategoryChannelResolvable} [parent] Parent of the new channel\n   */\n\n  /**\n   * Creates a new channel in the guild.\n   * @param {GuildChannelCreateOptions} options Options for creating the new channel\n   * @returns {Promise<GuildChannel>}\n   * @example\n   * // Create a new text channel\n   * guild.channels.create({ name: 'new-general', reason: 'Needed a cool new channel' })\n   *   .then(console.log)\n   *   .catch(console.error);\n   * @example\n   * // Create a new channel with permission overwrites\n   * guild.channels.create({\n   *   name: 'new-general',\n   *   type: ChannelType.GuildVoice,\n   *   permissionOverwrites: [\n   *      {\n   *        id: message.author.id,\n   *        deny: [PermissionFlagsBits.ViewChannel],\n   *     },\n   *   ],\n   * })\n   */\n  async create(_ref) {\n    let {\n      name,\n      type,\n      topic,\n      nsfw,\n      bitrate,\n      userLimit,\n      parent,\n      permissionOverwrites,\n      position,\n      rateLimitPerUser,\n      rtcRegion,\n      videoQualityMode,\n      availableTags,\n      defaultReactionEmoji,\n      defaultAutoArchiveDuration,\n      defaultSortOrder,\n      reason\n    } = _ref;\n    parent &&= this.client.channels.resolveId(parent);\n    permissionOverwrites &&= permissionOverwrites.map(o => PermissionOverwrites.resolve(o, this.guild));\n    const data = await this.client.rest.post(Routes.guildChannels(this.guild.id), {\n      body: {\n        name,\n        topic,\n        type,\n        nsfw,\n        bitrate,\n        user_limit: userLimit,\n        parent_id: parent,\n        position,\n        permission_overwrites: permissionOverwrites,\n        rate_limit_per_user: rateLimitPerUser,\n        rtc_region: rtcRegion,\n        video_quality_mode: videoQualityMode,\n        available_tags: availableTags?.map(availableTag => transformGuildForumTag(availableTag)),\n        default_reaction_emoji: defaultReactionEmoji && transformGuildDefaultReaction(defaultReactionEmoji),\n        default_auto_archive_duration: defaultAutoArchiveDuration,\n        default_sort_order: defaultSortOrder\n      },\n      reason\n    });\n    return this.client.actions.ChannelCreate.handle(data).channel;\n  }\n\n  /**\n   * @typedef {ChannelWebhookCreateOptions} WebhookCreateOptions\n   * @property {TextChannel|NewsChannel|VoiceChannel|ForumChannel|Snowflake} channel\n   * The channel to create the webhook for\n   */\n\n  /**\n   * Creates a webhook for the channel.\n   * @param {WebhookCreateOptions} options Options for creating the webhook\n   * @returns {Promise<Webhook>} Returns the created Webhook\n   * @example\n   * // Create a webhook for the current channel\n   * guild.channels.createWebhook({\n   *   channel: '222197033908436994',\n   *   name: 'Snek',\n   *   avatar: 'https://i.imgur.com/mI8XcpG.jpg',\n   *   reason: 'Needed a cool new Webhook'\n   * })\n   *   .then(console.log)\n   *   .catch(console.error)\n   */\n  async createWebhook(_ref2) {\n    let {\n      channel,\n      name,\n      avatar,\n      reason\n    } = _ref2;\n    const id = this.resolveId(channel);\n    if (!id) throw new DiscordjsTypeError(ErrorCodes.InvalidType, 'channel', 'GuildChannelResolvable');\n    if (typeof avatar === 'string' && !avatar.startsWith('data:')) {\n      avatar = await DataResolver.resolveImage(avatar);\n    }\n    const data = await this.client.rest.post(Routes.channelWebhooks(id), {\n      body: {\n        name,\n        avatar\n      },\n      reason\n    });\n    return new Webhook(this.client, data);\n  }\n\n  /**\n   * Options used to edit a guild channel.\n   * @typedef {Object} GuildChannelEditOptions\n   * @property {string} [name] The name of the channel\n   * @property {ChannelType} [type] The type of the channel (only conversion between text and news is supported)\n   * @property {number} [position] The position of the channel\n   * @property {?string} [topic] The topic of the text channel\n   * @property {boolean} [nsfw] Whether the channel is NSFW\n   * @property {number} [bitrate] The bitrate of the voice channel\n   * @property {number} [userLimit] The user limit of the voice channel\n   * @property {?CategoryChannelResolvable} [parent] The parent of the channel\n   * @property {boolean} [lockPermissions]\n   * Lock the permissions of the channel to what the parent's permissions are\n   * @property {OverwriteResolvable[]|Collection<Snowflake, OverwriteResolvable>} [permissionOverwrites]\n   * Permission overwrites for the channel\n   * @property {number} [rateLimitPerUser] The rate limit per user (slowmode) for the channel in seconds\n   * @property {ThreadAutoArchiveDuration} [defaultAutoArchiveDuration]\n   * The default auto archive duration for all new threads in this channel\n   * @property {?string} [rtcRegion] The RTC region of the channel\n   * @property {?VideoQualityMode} [videoQualityMode] The camera video quality mode of the channel\n   * @property {GuildForumTagData[]} [availableTags] The tags to set as available in a forum channel\n   * @property {?DefaultReactionEmoji} [defaultReactionEmoji] The emoji to set as the default reaction emoji\n   * @property {number} [defaultThreadRateLimitPerUser] The rate limit per user (slowmode) to set on forum posts\n   * @property {ChannelFlagsResolvable} [flags] The flags to set on the channel\n   * @property {?SortOrderType} [defaultSortOrder] The default sort order mode to set on the channel\n   * @property {string} [reason] Reason for editing this channel\n   */\n\n  /**\n   * Edits the channel.\n   * @param {GuildChannelResolvable} channel The channel to edit\n   * @param {GuildChannelEditOptions} data Options for editing the channel\n   * @returns {Promise<GuildChannel>}\n   * @example\n   * // Edit a channel\n   * guild.channels.edit('222197033908436994', { name: 'new-channel' })\n   *   .then(console.log)\n   *   .catch(console.error);\n   */\n  async edit(channel, data) {\n    channel = this.resolve(channel);\n    if (!channel) throw new DiscordjsTypeError(ErrorCodes.InvalidType, 'channel', 'GuildChannelResolvable');\n    const parent = data.parent && this.client.channels.resolveId(data.parent);\n    if (typeof data.position !== 'undefined') {\n      await this.setPosition(channel, data.position, {\n        position: data.position,\n        reason: data.reason\n      });\n    }\n    let permission_overwrites = data.permissionOverwrites?.map(o => PermissionOverwrites.resolve(o, this.guild));\n    if (data.lockPermissions) {\n      if (parent) {\n        const newParent = this.guild.channels.resolve(parent);\n        if (newParent?.type === ChannelType.GuildCategory) {\n          permission_overwrites = newParent.permissionOverwrites.cache.map(o => PermissionOverwrites.resolve(o, this.guild));\n        }\n      } else if (channel.parent) {\n        permission_overwrites = channel.parent.permissionOverwrites.cache.map(o => PermissionOverwrites.resolve(o, this.guild));\n      }\n    }\n    const newData = await this.client.rest.patch(Routes.channel(channel.id), {\n      body: {\n        name: (data.name ?? channel.name).trim(),\n        type: data.type,\n        topic: data.topic,\n        nsfw: data.nsfw,\n        bitrate: data.bitrate ?? channel.bitrate,\n        user_limit: data.userLimit ?? channel.userLimit,\n        rtc_region: 'rtcRegion' in data ? data.rtcRegion : channel.rtcRegion,\n        video_quality_mode: data.videoQualityMode,\n        parent_id: parent,\n        lock_permissions: data.lockPermissions,\n        rate_limit_per_user: data.rateLimitPerUser,\n        default_auto_archive_duration: data.defaultAutoArchiveDuration,\n        permission_overwrites,\n        available_tags: data.availableTags?.map(availableTag => transformGuildForumTag(availableTag)),\n        default_reaction_emoji: data.defaultReactionEmoji && transformGuildDefaultReaction(data.defaultReactionEmoji),\n        default_thread_rate_limit_per_user: data.defaultThreadRateLimitPerUser,\n        flags: 'flags' in data ? ChannelFlagsBitField.resolve(data.flags) : undefined,\n        default_sort_order: data.defaultSortOrder\n      },\n      reason: data.reason\n    });\n    return this.client.actions.ChannelUpdate.handle(newData).updated;\n  }\n\n  /**\n   * Sets a new position for the guild channel.\n   * @param {GuildChannelResolvable} channel The channel to set the position for\n   * @param {number} position The new position for the guild channel\n   * @param {SetChannelPositionOptions} options Options for setting position\n   * @returns {Promise<GuildChannel>}\n   * @example\n   * // Set a new channel position\n   * guild.channels.setPosition('222078374472843266', 2)\n   *   .then(newChannel => console.log(`Channel's new position is ${newChannel.position}`))\n   *   .catch(console.error);\n   */\n  async setPosition(channel, position) {\n    let {\n      relative,\n      reason\n    } = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n    channel = this.resolve(channel);\n    if (!channel) throw new DiscordjsTypeError(ErrorCodes.InvalidType, 'channel', 'GuildChannelResolvable');\n    const updatedChannels = await setPosition(channel, position, relative, this.guild._sortedChannels(channel), this.client, Routes.guildChannels(this.guild.id), reason);\n    this.client.actions.GuildChannelsPositionUpdate.handle({\n      guild_id: this.guild.id,\n      channels: updatedChannels\n    });\n    return channel;\n  }\n\n  /**\n   * Obtains one or more guild channels from Discord, or the channel cache if they're already available.\n   * @param {Snowflake} [id] The channel's id\n   * @param {BaseFetchOptions} [options] Additional options for this fetch\n   * @returns {Promise<?GuildChannel|ThreadChannel|Collection<Snowflake, ?GuildChannel>>}\n   * @example\n   * // Fetch all channels from the guild (excluding threads)\n   * message.guild.channels.fetch()\n   *   .then(channels => console.log(`There are ${channels.size} channels.`))\n   *   .catch(console.error);\n   * @example\n   * // Fetch a single channel\n   * message.guild.channels.fetch('222197033908436994')\n   *   .then(channel => console.log(`The channel name is: ${channel.name}`))\n   *   .catch(console.error);\n   */\n  async fetch(id) {\n    let {\n      cache = true,\n      force = false\n    } = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    if (id && !force) {\n      const existing = this.cache.get(id);\n      if (existing) return existing;\n    }\n    if (id) {\n      const data = await this.client.rest.get(Routes.channel(id));\n      // Since this is the guild manager, throw if on a different guild\n      if (this.guild.id !== data.guild_id) throw new DiscordjsError(ErrorCodes.GuildChannelUnowned);\n      return this.client.channels._add(data, this.guild, {\n        cache\n      });\n    }\n    const data = await this.client.rest.get(Routes.guildChannels(this.guild.id));\n    const channels = new Collection();\n    for (const channel of data) channels.set(channel.id, this.client.channels._add(channel, this.guild, {\n      cache\n    }));\n    return channels;\n  }\n\n  /**\n   * Fetches all webhooks for the channel.\n   * @param {GuildChannelResolvable} channel The channel to fetch webhooks for\n   * @returns {Promise<Collection<Snowflake, Webhook>>}\n   * @example\n   * // Fetch webhooks\n   * guild.channels.fetchWebhooks('769862166131245066')\n   *   .then(hooks => console.log(`This channel has ${hooks.size} hooks`))\n   *   .catch(console.error);\n   */\n  async fetchWebhooks(channel) {\n    const id = this.resolveId(channel);\n    if (!id) throw new DiscordjsTypeError(ErrorCodes.InvalidType, 'channel', 'GuildChannelResolvable');\n    const data = await this.client.rest.get(Routes.channelWebhooks(id));\n    return data.reduce((hooks, hook) => hooks.set(hook.id, new Webhook(this.client, hook)), new Collection());\n  }\n\n  /**\n   * Data that can be resolved to give a Category Channel object. This can be:\n   * * A CategoryChannel object\n   * * A Snowflake\n   * @typedef {CategoryChannel|Snowflake} CategoryChannelResolvable\n   */\n\n  /**\n   * The data needed for updating a channel's position.\n   * @typedef {Object} ChannelPosition\n   * @property {GuildChannel|Snowflake} channel Channel to update\n   * @property {number} [position] New position for the channel\n   * @property {CategoryChannelResolvable} [parent] Parent channel for this channel\n   * @property {boolean} [lockPermissions] If the overwrites should be locked to the parents overwrites\n   */\n\n  /**\n   * Batch-updates the guild's channels' positions.\n   * <info>Only one channel's parent can be changed at a time</info>\n   * @param {ChannelPosition[]} channelPositions Channel positions to update\n   * @returns {Promise<Guild>}\n   * @example\n   * guild.channels.setPositions([{ channel: channelId, position: newChannelIndex }])\n   *   .then(guild => console.log(`Updated channel positions for ${guild}`))\n   *   .catch(console.error);\n   */\n  async setPositions(channelPositions) {\n    channelPositions = channelPositions.map(r => ({\n      id: this.client.channels.resolveId(r.channel),\n      position: r.position,\n      lock_permissions: r.lockPermissions,\n      parent_id: typeof r.parent !== 'undefined' ? this.resolveId(r.parent) : undefined\n    }));\n    await this.client.rest.patch(Routes.guildChannels(this.guild.id), {\n      body: channelPositions\n    });\n    return this.client.actions.GuildChannelsPositionUpdate.handle({\n      guild_id: this.guild.id,\n      channels: channelPositions\n    }).guild;\n  }\n\n  /**\n   * Obtains all active thread channels in the guild from Discord\n   * @param {boolean} [cache=true] Whether to cache the fetched data\n   * @returns {Promise<FetchedThreads>}\n   * @example\n   * // Fetch all threads from the guild\n   * message.guild.channels.fetchActiveThreads()\n   *   .then(fetched => console.log(`There are ${fetched.threads.size} threads.`))\n   *   .catch(console.error);\n   */\n  async fetchActiveThreads() {\n    let cache = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;\n    const raw = await this.client.rest.get(Routes.guildActiveThreads(this.guild.id));\n    return GuildTextThreadManager._mapThreads(raw, this.client, {\n      guild: this.guild,\n      cache\n    });\n  }\n\n  /**\n   * Deletes the channel.\n   * @param {GuildChannelResolvable} channel The channel to delete\n   * @param {string} [reason] Reason for deleting this channel\n   * @returns {Promise<void>}\n   * @example\n   * // Delete the channel\n   * guild.channels.delete('858850993013260338', 'making room for new channels')\n   *   .then(console.log)\n   *   .catch(console.error);\n   */\n  async delete(channel, reason) {\n    const id = this.resolveId(channel);\n    if (!id) throw new DiscordjsTypeError(ErrorCodes.InvalidType, 'channel', 'GuildChannelResolvable');\n    await this.client.rest.delete(Routes.channel(id), {\n      reason\n    });\n    this.client.actions.ChannelDelete.handle({\n      id\n    });\n  }\n}\nmodule.exports = GuildChannelManager;","map":{"version":3,"names":["process","require","Collection","ChannelType","Routes","CachedManager","GuildTextThreadManager","DiscordjsError","DiscordjsTypeError","ErrorCodes","GuildChannel","PermissionOverwrites","ThreadChannel","Webhook","ChannelFlagsBitField","transformGuildForumTag","transformGuildDefaultReaction","ThreadChannelTypes","DataResolver","setPosition","cacheWarningEmitted","GuildChannelManager","constructor","guild","iterable","client","defaultCaching","_cache","name","maxSize","undefined","Infinity","emitWarning","channelCountWithoutThreads","cache","reduce","acc","channel","includes","type","_add","existing","get","id","set","resolve","resolveId","addFollower","targetChannel","reason","channelId","targetChannelId","Error","GuildChannelResolve","webhook_id","rest","post","channelFollowers","body","webhook_channel_id","create","topic","nsfw","bitrate","userLimit","parent","permissionOverwrites","position","rateLimitPerUser","rtcRegion","videoQualityMode","availableTags","defaultReactionEmoji","defaultAutoArchiveDuration","defaultSortOrder","channels","map","o","data","guildChannels","user_limit","parent_id","permission_overwrites","rate_limit_per_user","rtc_region","video_quality_mode","available_tags","availableTag","default_reaction_emoji","default_auto_archive_duration","default_sort_order","actions","ChannelCreate","handle","createWebhook","avatar","InvalidType","startsWith","resolveImage","channelWebhooks","edit","lockPermissions","newParent","GuildCategory","newData","patch","trim","lock_permissions","default_thread_rate_limit_per_user","defaultThreadRateLimitPerUser","flags","ChannelUpdate","updated","relative","updatedChannels","_sortedChannels","GuildChannelsPositionUpdate","guild_id","fetch","force","GuildChannelUnowned","fetchWebhooks","hooks","hook","setPositions","channelPositions","r","fetchActiveThreads","raw","guildActiveThreads","_mapThreads","delete","ChannelDelete","module","exports"],"sources":["J:/Coding/Projekts/Web/JavaScript/sillcode.tech/node_modules/discord.js/src/managers/GuildChannelManager.js"],"sourcesContent":["'use strict';\n\nconst process = require('node:process');\nconst { Collection } = require('@discordjs/collection');\nconst { ChannelType, Routes } = require('discord-api-types/v10');\nconst CachedManager = require('./CachedManager');\nconst GuildTextThreadManager = require('./GuildTextThreadManager');\nconst { DiscordjsError, DiscordjsTypeError, ErrorCodes } = require('../errors');\nconst GuildChannel = require('../structures/GuildChannel');\nconst PermissionOverwrites = require('../structures/PermissionOverwrites');\nconst ThreadChannel = require('../structures/ThreadChannel');\nconst Webhook = require('../structures/Webhook');\nconst ChannelFlagsBitField = require('../util/ChannelFlagsBitField');\nconst { transformGuildForumTag, transformGuildDefaultReaction } = require('../util/Channels');\nconst { ThreadChannelTypes } = require('../util/Constants');\nconst DataResolver = require('../util/DataResolver');\nconst { setPosition } = require('../util/Util');\n\nlet cacheWarningEmitted = false;\n\n/**\n * Manages API methods for GuildChannels and stores their cache.\n * @extends {CachedManager}\n */\nclass GuildChannelManager extends CachedManager {\n  constructor(guild, iterable) {\n    super(guild.client, GuildChannel, iterable);\n    const defaultCaching =\n      this._cache.constructor.name === 'Collection' ||\n      this._cache.maxSize === undefined ||\n      this._cache.maxSize === Infinity;\n    if (!cacheWarningEmitted && !defaultCaching) {\n      cacheWarningEmitted = true;\n      process.emitWarning(\n        `Overriding the cache handling for ${this.constructor.name} is unsupported and breaks functionality.`,\n        'UnsupportedCacheOverwriteWarning',\n      );\n    }\n\n    /**\n     * The guild this Manager belongs to\n     * @type {Guild}\n     */\n    this.guild = guild;\n  }\n\n  /**\n   * The number of channels in this managers cache excluding thread channels\n   * that do not count towards a guild's maximum channels restriction.\n   * @type {number}\n   * @readonly\n   */\n  get channelCountWithoutThreads() {\n    return this.cache.reduce((acc, channel) => {\n      if (ThreadChannelTypes.includes(channel.type)) return acc;\n      return ++acc;\n    }, 0);\n  }\n\n  /**\n   * The cache of this Manager\n   * @type {Collection<Snowflake, GuildChannel|ThreadChannel>}\n   * @name GuildChannelManager#cache\n   */\n\n  _add(channel) {\n    const existing = this.cache.get(channel.id);\n    if (existing) return existing;\n    this.cache.set(channel.id, channel);\n    return channel;\n  }\n\n  /**\n   * Data that can be resolved to give a Guild Channel object. This can be:\n   * * A GuildChannel object\n   * * A ThreadChannel object\n   * * A Snowflake\n   * @typedef {GuildChannel|ThreadChannel|Snowflake} GuildChannelResolvable\n   */\n\n  /**\n   * Resolves a GuildChannelResolvable to a Channel object.\n   * @param {GuildChannelResolvable} channel The GuildChannel resolvable to resolve\n   * @returns {?(GuildChannel|ThreadChannel)}\n   */\n  resolve(channel) {\n    if (channel instanceof ThreadChannel) return super.resolve(channel.id);\n    return super.resolve(channel);\n  }\n\n  /**\n   * Resolves a GuildChannelResolvable to a channel id.\n   * @param {GuildChannelResolvable} channel The GuildChannel resolvable to resolve\n   * @returns {?Snowflake}\n   */\n  resolveId(channel) {\n    if (channel instanceof ThreadChannel) return super.resolveId(channel.id);\n    return super.resolveId(channel);\n  }\n\n  /**\n   * Adds the target channel to a channel's followers.\n   * @param {NewsChannel|Snowflake} channel The channel to follow\n   * @param {TextChannelResolvable} targetChannel The channel where published announcements will be posted at\n   * @param {string} [reason] Reason for creating the webhook\n   * @returns {Promise<Snowflake>} Returns created target webhook id.\n   */\n  async addFollower(channel, targetChannel, reason) {\n    const channelId = this.resolveId(channel);\n    const targetChannelId = this.resolveId(targetChannel);\n    if (!channelId || !targetChannelId) throw new Error(ErrorCodes.GuildChannelResolve);\n    const { webhook_id } = await this.client.rest.post(Routes.channelFollowers(channelId), {\n      body: { webhook_channel_id: targetChannelId },\n      reason,\n    });\n    return webhook_id;\n  }\n\n  /**\n   * Options used to create a new channel in a guild.\n   * @typedef {CategoryCreateChannelOptions} GuildChannelCreateOptions\n   * @property {?CategoryChannelResolvable} [parent] Parent of the new channel\n   */\n\n  /**\n   * Creates a new channel in the guild.\n   * @param {GuildChannelCreateOptions} options Options for creating the new channel\n   * @returns {Promise<GuildChannel>}\n   * @example\n   * // Create a new text channel\n   * guild.channels.create({ name: 'new-general', reason: 'Needed a cool new channel' })\n   *   .then(console.log)\n   *   .catch(console.error);\n   * @example\n   * // Create a new channel with permission overwrites\n   * guild.channels.create({\n   *   name: 'new-general',\n   *   type: ChannelType.GuildVoice,\n   *   permissionOverwrites: [\n   *      {\n   *        id: message.author.id,\n   *        deny: [PermissionFlagsBits.ViewChannel],\n   *     },\n   *   ],\n   * })\n   */\n  async create({\n    name,\n    type,\n    topic,\n    nsfw,\n    bitrate,\n    userLimit,\n    parent,\n    permissionOverwrites,\n    position,\n    rateLimitPerUser,\n    rtcRegion,\n    videoQualityMode,\n    availableTags,\n    defaultReactionEmoji,\n    defaultAutoArchiveDuration,\n    defaultSortOrder,\n    reason,\n  }) {\n    parent &&= this.client.channels.resolveId(parent);\n    permissionOverwrites &&= permissionOverwrites.map(o => PermissionOverwrites.resolve(o, this.guild));\n\n    const data = await this.client.rest.post(Routes.guildChannels(this.guild.id), {\n      body: {\n        name,\n        topic,\n        type,\n        nsfw,\n        bitrate,\n        user_limit: userLimit,\n        parent_id: parent,\n        position,\n        permission_overwrites: permissionOverwrites,\n        rate_limit_per_user: rateLimitPerUser,\n        rtc_region: rtcRegion,\n        video_quality_mode: videoQualityMode,\n        available_tags: availableTags?.map(availableTag => transformGuildForumTag(availableTag)),\n        default_reaction_emoji: defaultReactionEmoji && transformGuildDefaultReaction(defaultReactionEmoji),\n        default_auto_archive_duration: defaultAutoArchiveDuration,\n        default_sort_order: defaultSortOrder,\n      },\n      reason,\n    });\n    return this.client.actions.ChannelCreate.handle(data).channel;\n  }\n\n  /**\n   * @typedef {ChannelWebhookCreateOptions} WebhookCreateOptions\n   * @property {TextChannel|NewsChannel|VoiceChannel|ForumChannel|Snowflake} channel\n   * The channel to create the webhook for\n   */\n\n  /**\n   * Creates a webhook for the channel.\n   * @param {WebhookCreateOptions} options Options for creating the webhook\n   * @returns {Promise<Webhook>} Returns the created Webhook\n   * @example\n   * // Create a webhook for the current channel\n   * guild.channels.createWebhook({\n   *   channel: '222197033908436994',\n   *   name: 'Snek',\n   *   avatar: 'https://i.imgur.com/mI8XcpG.jpg',\n   *   reason: 'Needed a cool new Webhook'\n   * })\n   *   .then(console.log)\n   *   .catch(console.error)\n   */\n  async createWebhook({ channel, name, avatar, reason }) {\n    const id = this.resolveId(channel);\n    if (!id) throw new DiscordjsTypeError(ErrorCodes.InvalidType, 'channel', 'GuildChannelResolvable');\n    if (typeof avatar === 'string' && !avatar.startsWith('data:')) {\n      avatar = await DataResolver.resolveImage(avatar);\n    }\n    const data = await this.client.rest.post(Routes.channelWebhooks(id), {\n      body: {\n        name,\n        avatar,\n      },\n      reason,\n    });\n    return new Webhook(this.client, data);\n  }\n\n  /**\n   * Options used to edit a guild channel.\n   * @typedef {Object} GuildChannelEditOptions\n   * @property {string} [name] The name of the channel\n   * @property {ChannelType} [type] The type of the channel (only conversion between text and news is supported)\n   * @property {number} [position] The position of the channel\n   * @property {?string} [topic] The topic of the text channel\n   * @property {boolean} [nsfw] Whether the channel is NSFW\n   * @property {number} [bitrate] The bitrate of the voice channel\n   * @property {number} [userLimit] The user limit of the voice channel\n   * @property {?CategoryChannelResolvable} [parent] The parent of the channel\n   * @property {boolean} [lockPermissions]\n   * Lock the permissions of the channel to what the parent's permissions are\n   * @property {OverwriteResolvable[]|Collection<Snowflake, OverwriteResolvable>} [permissionOverwrites]\n   * Permission overwrites for the channel\n   * @property {number} [rateLimitPerUser] The rate limit per user (slowmode) for the channel in seconds\n   * @property {ThreadAutoArchiveDuration} [defaultAutoArchiveDuration]\n   * The default auto archive duration for all new threads in this channel\n   * @property {?string} [rtcRegion] The RTC region of the channel\n   * @property {?VideoQualityMode} [videoQualityMode] The camera video quality mode of the channel\n   * @property {GuildForumTagData[]} [availableTags] The tags to set as available in a forum channel\n   * @property {?DefaultReactionEmoji} [defaultReactionEmoji] The emoji to set as the default reaction emoji\n   * @property {number} [defaultThreadRateLimitPerUser] The rate limit per user (slowmode) to set on forum posts\n   * @property {ChannelFlagsResolvable} [flags] The flags to set on the channel\n   * @property {?SortOrderType} [defaultSortOrder] The default sort order mode to set on the channel\n   * @property {string} [reason] Reason for editing this channel\n   */\n\n  /**\n   * Edits the channel.\n   * @param {GuildChannelResolvable} channel The channel to edit\n   * @param {GuildChannelEditOptions} data Options for editing the channel\n   * @returns {Promise<GuildChannel>}\n   * @example\n   * // Edit a channel\n   * guild.channels.edit('222197033908436994', { name: 'new-channel' })\n   *   .then(console.log)\n   *   .catch(console.error);\n   */\n  async edit(channel, data) {\n    channel = this.resolve(channel);\n    if (!channel) throw new DiscordjsTypeError(ErrorCodes.InvalidType, 'channel', 'GuildChannelResolvable');\n\n    const parent = data.parent && this.client.channels.resolveId(data.parent);\n\n    if (typeof data.position !== 'undefined') {\n      await this.setPosition(channel, data.position, { position: data.position, reason: data.reason });\n    }\n\n    let permission_overwrites = data.permissionOverwrites?.map(o => PermissionOverwrites.resolve(o, this.guild));\n\n    if (data.lockPermissions) {\n      if (parent) {\n        const newParent = this.guild.channels.resolve(parent);\n        if (newParent?.type === ChannelType.GuildCategory) {\n          permission_overwrites = newParent.permissionOverwrites.cache.map(o =>\n            PermissionOverwrites.resolve(o, this.guild),\n          );\n        }\n      } else if (channel.parent) {\n        permission_overwrites = channel.parent.permissionOverwrites.cache.map(o =>\n          PermissionOverwrites.resolve(o, this.guild),\n        );\n      }\n    }\n\n    const newData = await this.client.rest.patch(Routes.channel(channel.id), {\n      body: {\n        name: (data.name ?? channel.name).trim(),\n        type: data.type,\n        topic: data.topic,\n        nsfw: data.nsfw,\n        bitrate: data.bitrate ?? channel.bitrate,\n        user_limit: data.userLimit ?? channel.userLimit,\n        rtc_region: 'rtcRegion' in data ? data.rtcRegion : channel.rtcRegion,\n        video_quality_mode: data.videoQualityMode,\n        parent_id: parent,\n        lock_permissions: data.lockPermissions,\n        rate_limit_per_user: data.rateLimitPerUser,\n        default_auto_archive_duration: data.defaultAutoArchiveDuration,\n        permission_overwrites,\n        available_tags: data.availableTags?.map(availableTag => transformGuildForumTag(availableTag)),\n        default_reaction_emoji: data.defaultReactionEmoji && transformGuildDefaultReaction(data.defaultReactionEmoji),\n        default_thread_rate_limit_per_user: data.defaultThreadRateLimitPerUser,\n        flags: 'flags' in data ? ChannelFlagsBitField.resolve(data.flags) : undefined,\n        default_sort_order: data.defaultSortOrder,\n      },\n      reason: data.reason,\n    });\n\n    return this.client.actions.ChannelUpdate.handle(newData).updated;\n  }\n\n  /**\n   * Sets a new position for the guild channel.\n   * @param {GuildChannelResolvable} channel The channel to set the position for\n   * @param {number} position The new position for the guild channel\n   * @param {SetChannelPositionOptions} options Options for setting position\n   * @returns {Promise<GuildChannel>}\n   * @example\n   * // Set a new channel position\n   * guild.channels.setPosition('222078374472843266', 2)\n   *   .then(newChannel => console.log(`Channel's new position is ${newChannel.position}`))\n   *   .catch(console.error);\n   */\n  async setPosition(channel, position, { relative, reason } = {}) {\n    channel = this.resolve(channel);\n    if (!channel) throw new DiscordjsTypeError(ErrorCodes.InvalidType, 'channel', 'GuildChannelResolvable');\n    const updatedChannels = await setPosition(\n      channel,\n      position,\n      relative,\n      this.guild._sortedChannels(channel),\n      this.client,\n      Routes.guildChannels(this.guild.id),\n      reason,\n    );\n\n    this.client.actions.GuildChannelsPositionUpdate.handle({\n      guild_id: this.guild.id,\n      channels: updatedChannels,\n    });\n    return channel;\n  }\n\n  /**\n   * Obtains one or more guild channels from Discord, or the channel cache if they're already available.\n   * @param {Snowflake} [id] The channel's id\n   * @param {BaseFetchOptions} [options] Additional options for this fetch\n   * @returns {Promise<?GuildChannel|ThreadChannel|Collection<Snowflake, ?GuildChannel>>}\n   * @example\n   * // Fetch all channels from the guild (excluding threads)\n   * message.guild.channels.fetch()\n   *   .then(channels => console.log(`There are ${channels.size} channels.`))\n   *   .catch(console.error);\n   * @example\n   * // Fetch a single channel\n   * message.guild.channels.fetch('222197033908436994')\n   *   .then(channel => console.log(`The channel name is: ${channel.name}`))\n   *   .catch(console.error);\n   */\n  async fetch(id, { cache = true, force = false } = {}) {\n    if (id && !force) {\n      const existing = this.cache.get(id);\n      if (existing) return existing;\n    }\n\n    if (id) {\n      const data = await this.client.rest.get(Routes.channel(id));\n      // Since this is the guild manager, throw if on a different guild\n      if (this.guild.id !== data.guild_id) throw new DiscordjsError(ErrorCodes.GuildChannelUnowned);\n      return this.client.channels._add(data, this.guild, { cache });\n    }\n\n    const data = await this.client.rest.get(Routes.guildChannels(this.guild.id));\n    const channels = new Collection();\n    for (const channel of data) channels.set(channel.id, this.client.channels._add(channel, this.guild, { cache }));\n    return channels;\n  }\n\n  /**\n   * Fetches all webhooks for the channel.\n   * @param {GuildChannelResolvable} channel The channel to fetch webhooks for\n   * @returns {Promise<Collection<Snowflake, Webhook>>}\n   * @example\n   * // Fetch webhooks\n   * guild.channels.fetchWebhooks('769862166131245066')\n   *   .then(hooks => console.log(`This channel has ${hooks.size} hooks`))\n   *   .catch(console.error);\n   */\n  async fetchWebhooks(channel) {\n    const id = this.resolveId(channel);\n    if (!id) throw new DiscordjsTypeError(ErrorCodes.InvalidType, 'channel', 'GuildChannelResolvable');\n    const data = await this.client.rest.get(Routes.channelWebhooks(id));\n    return data.reduce((hooks, hook) => hooks.set(hook.id, new Webhook(this.client, hook)), new Collection());\n  }\n\n  /**\n   * Data that can be resolved to give a Category Channel object. This can be:\n   * * A CategoryChannel object\n   * * A Snowflake\n   * @typedef {CategoryChannel|Snowflake} CategoryChannelResolvable\n   */\n\n  /**\n   * The data needed for updating a channel's position.\n   * @typedef {Object} ChannelPosition\n   * @property {GuildChannel|Snowflake} channel Channel to update\n   * @property {number} [position] New position for the channel\n   * @property {CategoryChannelResolvable} [parent] Parent channel for this channel\n   * @property {boolean} [lockPermissions] If the overwrites should be locked to the parents overwrites\n   */\n\n  /**\n   * Batch-updates the guild's channels' positions.\n   * <info>Only one channel's parent can be changed at a time</info>\n   * @param {ChannelPosition[]} channelPositions Channel positions to update\n   * @returns {Promise<Guild>}\n   * @example\n   * guild.channels.setPositions([{ channel: channelId, position: newChannelIndex }])\n   *   .then(guild => console.log(`Updated channel positions for ${guild}`))\n   *   .catch(console.error);\n   */\n  async setPositions(channelPositions) {\n    channelPositions = channelPositions.map(r => ({\n      id: this.client.channels.resolveId(r.channel),\n      position: r.position,\n      lock_permissions: r.lockPermissions,\n      parent_id: typeof r.parent !== 'undefined' ? this.resolveId(r.parent) : undefined,\n    }));\n\n    await this.client.rest.patch(Routes.guildChannels(this.guild.id), { body: channelPositions });\n    return this.client.actions.GuildChannelsPositionUpdate.handle({\n      guild_id: this.guild.id,\n      channels: channelPositions,\n    }).guild;\n  }\n\n  /**\n   * Obtains all active thread channels in the guild from Discord\n   * @param {boolean} [cache=true] Whether to cache the fetched data\n   * @returns {Promise<FetchedThreads>}\n   * @example\n   * // Fetch all threads from the guild\n   * message.guild.channels.fetchActiveThreads()\n   *   .then(fetched => console.log(`There are ${fetched.threads.size} threads.`))\n   *   .catch(console.error);\n   */\n  async fetchActiveThreads(cache = true) {\n    const raw = await this.client.rest.get(Routes.guildActiveThreads(this.guild.id));\n    return GuildTextThreadManager._mapThreads(raw, this.client, { guild: this.guild, cache });\n  }\n\n  /**\n   * Deletes the channel.\n   * @param {GuildChannelResolvable} channel The channel to delete\n   * @param {string} [reason] Reason for deleting this channel\n   * @returns {Promise<void>}\n   * @example\n   * // Delete the channel\n   * guild.channels.delete('858850993013260338', 'making room for new channels')\n   *   .then(console.log)\n   *   .catch(console.error);\n   */\n  async delete(channel, reason) {\n    const id = this.resolveId(channel);\n    if (!id) throw new DiscordjsTypeError(ErrorCodes.InvalidType, 'channel', 'GuildChannelResolvable');\n    await this.client.rest.delete(Routes.channel(id), { reason });\n    this.client.actions.ChannelDelete.handle({ id });\n  }\n}\n\nmodule.exports = GuildChannelManager;\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}