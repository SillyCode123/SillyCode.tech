{"ast":null,"code":"'use strict';\n\nconst {\n  Collection\n} = require('@discordjs/collection');\nconst {\n  Routes\n} = require('discord-api-types/v10');\nconst CachedManager = require('./CachedManager');\nconst {\n  DiscordjsTypeError,\n  ErrorCodes\n} = require('../errors');\nconst ThreadMember = require('../structures/ThreadMember');\n\n/**\n * Manages API methods for GuildMembers and stores their cache.\n * @extends {CachedManager}\n */\nclass ThreadMemberManager extends CachedManager {\n  constructor(thread, iterable) {\n    super(thread.client, ThreadMember, iterable);\n\n    /**\n     * The thread this manager belongs to\n     * @type {ThreadChannel}\n     */\n    this.thread = thread;\n  }\n\n  /**\n   * The cache of this Manager\n   * @type {Collection<Snowflake, ThreadMember>}\n   * @name ThreadMemberManager#cache\n   */\n\n  _add(data) {\n    let cache = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\n    const existing = this.cache.get(data.user_id);\n    if (cache) existing?._patch(data);\n    if (existing) return existing;\n    const member = new ThreadMember(this.thread, data);\n    if (cache) this.cache.set(data.user_id, member);\n    return member;\n  }\n\n  /**\n   * Fetches the client user as a ThreadMember of the thread.\n   * @param {BaseFetchOptions} [options] The options for fetching the member\n   * @returns {Promise<ThreadMember>}\n   */\n  fetchMe(options) {\n    return this.fetch({\n      ...options,\n      member: this.client.user.id\n    });\n  }\n\n  /**\n   * The client user as a ThreadMember of this ThreadChannel\n   * @type {?ThreadMember}\n   * @readonly\n   */\n  get me() {\n    return this.resolve(this.client.user.id);\n  }\n\n  /**\n   * Data that resolves to give a ThreadMember object. This can be:\n   * * A ThreadMember object\n   * * A User resolvable\n   * @typedef {ThreadMember|UserResolvable} ThreadMemberResolvable\n   */\n\n  /**\n   * Resolves a {@link ThreadMemberResolvable} to a {@link ThreadMember} object.\n   * @param {ThreadMemberResolvable} member The user that is part of the thread\n   * @returns {?GuildMember}\n   */\n  resolve(member) {\n    const memberResolvable = super.resolve(member);\n    if (memberResolvable) return memberResolvable;\n    const userResolvable = this.client.users.resolveId(member);\n    if (userResolvable) return super.resolve(userResolvable);\n    return null;\n  }\n\n  /**\n   * Resolves a {@link ThreadMemberResolvable} to a {@link ThreadMember} id string.\n   * @param {ThreadMemberResolvable} member The user that is part of the guild\n   * @returns {?Snowflake}\n   */\n  resolveId(member) {\n    const memberResolvable = super.resolveId(member);\n    if (memberResolvable) return memberResolvable;\n    const userResolvable = this.client.users.resolveId(member);\n    return this.cache.has(userResolvable) ? userResolvable : null;\n  }\n\n  /**\n   * Adds a member to the thread.\n   * @param {UserResolvable|'@me'} member The member to add\n   * @param {string} [reason] The reason for adding this member\n   * @returns {Promise<Snowflake>}\n   */\n  async add(member, reason) {\n    const id = member === '@me' ? member : this.client.users.resolveId(member);\n    if (!id) throw new DiscordjsTypeError(ErrorCodes.InvalidType, 'member', 'UserResolvable');\n    await this.client.rest.put(Routes.threadMembers(this.thread.id, id), {\n      reason\n    });\n    return id;\n  }\n\n  /**\n   * Remove a user from the thread.\n   * @param {Snowflake|'@me'} id The id of the member to remove\n   * @param {string} [reason] The reason for removing this member from the thread\n   * @returns {Promise<Snowflake>}\n   */\n  async remove(id, reason) {\n    await this.client.rest.delete(Routes.threadMembers(this.thread.id, id), {\n      reason\n    });\n    return id;\n  }\n\n  /**\n   * @typedef {BaseFetchOptions} FetchThreadMemberOptions\n   * @property {ThreadMemberResolvable} member The thread member to fetch\n   */\n\n  /**\n   * @typedef {Object} FetchThreadMembersOptions\n   * @property {boolean} [cache] Whether to cache the fetched thread members\n   */\n\n  /**\n   * Fetches thread member(s) from Discord.\n   * <info>This method requires the {@link GatewayIntentBits.GuildMembers} privileged gateway intent.</info>\n   * @param {ThreadMemberResolvable|FetchThreadMemberOptions|FetchThreadMembersOptions} [options]\n   * Options for fetching thread member(s)\n   * @returns {Promise<ThreadMember|Collection<Snowflake, ThreadMember>>}\n   */\n  fetch(options) {\n    if (!options) return this._fetchMany();\n    const {\n      member,\n      cache,\n      force\n    } = options;\n    const resolvedMember = this.resolveId(member ?? options);\n    if (resolvedMember) return this._fetchSingle({\n      member: resolvedMember,\n      cache,\n      force\n    });\n    return this._fetchMany(options);\n  }\n  async _fetchSingle(_ref) {\n    let {\n      member,\n      cache,\n      force = false\n    } = _ref;\n    if (!force) {\n      const existing = this.cache.get(member);\n      if (existing) return existing;\n    }\n    const data = await this.client.rest.get(Routes.threadMembers(this.thread.id, member));\n    return this._add(data, cache);\n  }\n  async _fetchMany() {\n    let options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    const data = await this.client.rest.get(Routes.threadMembers(this.thread.id));\n    return data.reduce((col, member) => col.set(member.user_id, this._add(member, options.cache)), new Collection());\n  }\n}\nmodule.exports = ThreadMemberManager;","map":{"version":3,"names":["Collection","require","Routes","CachedManager","DiscordjsTypeError","ErrorCodes","ThreadMember","ThreadMemberManager","constructor","thread","iterable","client","_add","data","cache","existing","get","user_id","_patch","member","set","fetchMe","options","fetch","user","id","me","resolve","memberResolvable","userResolvable","users","resolveId","has","add","reason","InvalidType","rest","put","threadMembers","remove","delete","_fetchMany","force","resolvedMember","_fetchSingle","reduce","col","module","exports"],"sources":["J:/Coding/Projekts/Web/JavaScript/sillcode.tech/node_modules/discord.js/src/managers/ThreadMemberManager.js"],"sourcesContent":["'use strict';\n\nconst { Collection } = require('@discordjs/collection');\nconst { Routes } = require('discord-api-types/v10');\nconst CachedManager = require('./CachedManager');\nconst { DiscordjsTypeError, ErrorCodes } = require('../errors');\nconst ThreadMember = require('../structures/ThreadMember');\n\n/**\n * Manages API methods for GuildMembers and stores their cache.\n * @extends {CachedManager}\n */\nclass ThreadMemberManager extends CachedManager {\n  constructor(thread, iterable) {\n    super(thread.client, ThreadMember, iterable);\n\n    /**\n     * The thread this manager belongs to\n     * @type {ThreadChannel}\n     */\n    this.thread = thread;\n  }\n\n  /**\n   * The cache of this Manager\n   * @type {Collection<Snowflake, ThreadMember>}\n   * @name ThreadMemberManager#cache\n   */\n\n  _add(data, cache = true) {\n    const existing = this.cache.get(data.user_id);\n    if (cache) existing?._patch(data);\n    if (existing) return existing;\n\n    const member = new ThreadMember(this.thread, data);\n    if (cache) this.cache.set(data.user_id, member);\n    return member;\n  }\n\n  /**\n   * Fetches the client user as a ThreadMember of the thread.\n   * @param {BaseFetchOptions} [options] The options for fetching the member\n   * @returns {Promise<ThreadMember>}\n   */\n  fetchMe(options) {\n    return this.fetch({ ...options, member: this.client.user.id });\n  }\n\n  /**\n   * The client user as a ThreadMember of this ThreadChannel\n   * @type {?ThreadMember}\n   * @readonly\n   */\n  get me() {\n    return this.resolve(this.client.user.id);\n  }\n\n  /**\n   * Data that resolves to give a ThreadMember object. This can be:\n   * * A ThreadMember object\n   * * A User resolvable\n   * @typedef {ThreadMember|UserResolvable} ThreadMemberResolvable\n   */\n\n  /**\n   * Resolves a {@link ThreadMemberResolvable} to a {@link ThreadMember} object.\n   * @param {ThreadMemberResolvable} member The user that is part of the thread\n   * @returns {?GuildMember}\n   */\n  resolve(member) {\n    const memberResolvable = super.resolve(member);\n    if (memberResolvable) return memberResolvable;\n    const userResolvable = this.client.users.resolveId(member);\n    if (userResolvable) return super.resolve(userResolvable);\n    return null;\n  }\n\n  /**\n   * Resolves a {@link ThreadMemberResolvable} to a {@link ThreadMember} id string.\n   * @param {ThreadMemberResolvable} member The user that is part of the guild\n   * @returns {?Snowflake}\n   */\n  resolveId(member) {\n    const memberResolvable = super.resolveId(member);\n    if (memberResolvable) return memberResolvable;\n    const userResolvable = this.client.users.resolveId(member);\n    return this.cache.has(userResolvable) ? userResolvable : null;\n  }\n\n  /**\n   * Adds a member to the thread.\n   * @param {UserResolvable|'@me'} member The member to add\n   * @param {string} [reason] The reason for adding this member\n   * @returns {Promise<Snowflake>}\n   */\n  async add(member, reason) {\n    const id = member === '@me' ? member : this.client.users.resolveId(member);\n    if (!id) throw new DiscordjsTypeError(ErrorCodes.InvalidType, 'member', 'UserResolvable');\n    await this.client.rest.put(Routes.threadMembers(this.thread.id, id), { reason });\n    return id;\n  }\n\n  /**\n   * Remove a user from the thread.\n   * @param {Snowflake|'@me'} id The id of the member to remove\n   * @param {string} [reason] The reason for removing this member from the thread\n   * @returns {Promise<Snowflake>}\n   */\n  async remove(id, reason) {\n    await this.client.rest.delete(Routes.threadMembers(this.thread.id, id), { reason });\n    return id;\n  }\n\n  /**\n   * @typedef {BaseFetchOptions} FetchThreadMemberOptions\n   * @property {ThreadMemberResolvable} member The thread member to fetch\n   */\n\n  /**\n   * @typedef {Object} FetchThreadMembersOptions\n   * @property {boolean} [cache] Whether to cache the fetched thread members\n   */\n\n  /**\n   * Fetches thread member(s) from Discord.\n   * <info>This method requires the {@link GatewayIntentBits.GuildMembers} privileged gateway intent.</info>\n   * @param {ThreadMemberResolvable|FetchThreadMemberOptions|FetchThreadMembersOptions} [options]\n   * Options for fetching thread member(s)\n   * @returns {Promise<ThreadMember|Collection<Snowflake, ThreadMember>>}\n   */\n  fetch(options) {\n    if (!options) return this._fetchMany();\n    const { member, cache, force } = options;\n    const resolvedMember = this.resolveId(member ?? options);\n    if (resolvedMember) return this._fetchSingle({ member: resolvedMember, cache, force });\n    return this._fetchMany(options);\n  }\n\n  async _fetchSingle({ member, cache, force = false }) {\n    if (!force) {\n      const existing = this.cache.get(member);\n      if (existing) return existing;\n    }\n\n    const data = await this.client.rest.get(Routes.threadMembers(this.thread.id, member));\n    return this._add(data, cache);\n  }\n\n  async _fetchMany(options = {}) {\n    const data = await this.client.rest.get(Routes.threadMembers(this.thread.id));\n    return data.reduce((col, member) => col.set(member.user_id, this._add(member, options.cache)), new Collection());\n  }\n}\n\nmodule.exports = ThreadMemberManager;\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}