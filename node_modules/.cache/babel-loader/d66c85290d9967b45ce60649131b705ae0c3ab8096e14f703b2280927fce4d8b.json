{"ast":null,"code":"'use strict';\n\n/* global WebAssembly */\nconst assert = require('assert');\nconst net = require('net');\nconst util = require('./core/util');\nconst Request = require('./core/request');\nconst DispatcherBase = require('./dispatcher-base');\nconst {\n  RequestContentLengthMismatchError,\n  ResponseContentLengthMismatchError,\n  InvalidArgumentError,\n  RequestAbortedError,\n  HeadersTimeoutError,\n  HeadersOverflowError,\n  SocketError,\n  InformationalError,\n  BodyTimeoutError,\n  HTTPParserError,\n  ResponseExceededMaxSizeError\n} = require('./core/errors');\nconst buildConnector = require('./core/connect');\nconst {\n  kUrl,\n  kReset,\n  kServerName,\n  kClient,\n  kBusy,\n  kParser,\n  kConnect,\n  kBlocking,\n  kResuming,\n  kRunning,\n  kPending,\n  kSize,\n  kWriting,\n  kQueue,\n  kConnected,\n  kConnecting,\n  kNeedDrain,\n  kNoRef,\n  kKeepAliveDefaultTimeout,\n  kHostHeader,\n  kPendingIdx,\n  kRunningIdx,\n  kError,\n  kPipelining,\n  kSocket,\n  kKeepAliveTimeoutValue,\n  kMaxHeadersSize,\n  kKeepAliveMaxTimeout,\n  kKeepAliveTimeoutThreshold,\n  kHeadersTimeout,\n  kBodyTimeout,\n  kStrictContentLength,\n  kConnector,\n  kMaxRedirections,\n  kMaxRequests,\n  kCounter,\n  kClose,\n  kDestroy,\n  kDispatch,\n  kInterceptors,\n  kLocalAddress,\n  kMaxResponseSize\n} = require('./core/symbols');\nconst kClosedResolve = Symbol('kClosedResolve');\nconst channels = {};\ntry {\n  const diagnosticsChannel = require('diagnostics_channel');\n  channels.sendHeaders = diagnosticsChannel.channel('undici:client:sendHeaders');\n  channels.beforeConnect = diagnosticsChannel.channel('undici:client:beforeConnect');\n  channels.connectError = diagnosticsChannel.channel('undici:client:connectError');\n  channels.connected = diagnosticsChannel.channel('undici:client:connected');\n} catch {\n  channels.sendHeaders = {\n    hasSubscribers: false\n  };\n  channels.beforeConnect = {\n    hasSubscribers: false\n  };\n  channels.connectError = {\n    hasSubscribers: false\n  };\n  channels.connected = {\n    hasSubscribers: false\n  };\n}\nclass Client extends DispatcherBase {\n  constructor(url) {\n    let {\n      interceptors,\n      maxHeaderSize,\n      headersTimeout,\n      socketTimeout,\n      requestTimeout,\n      connectTimeout,\n      bodyTimeout,\n      idleTimeout,\n      keepAlive,\n      keepAliveTimeout,\n      maxKeepAliveTimeout,\n      keepAliveMaxTimeout,\n      keepAliveTimeoutThreshold,\n      socketPath,\n      pipelining,\n      tls,\n      strictContentLength,\n      maxCachedSessions,\n      maxRedirections,\n      connect,\n      maxRequestsPerClient,\n      localAddress,\n      maxResponseSize\n    } = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    super();\n    if (keepAlive !== undefined) {\n      throw new InvalidArgumentError('unsupported keepAlive, use pipelining=0 instead');\n    }\n    if (socketTimeout !== undefined) {\n      throw new InvalidArgumentError('unsupported socketTimeout, use headersTimeout & bodyTimeout instead');\n    }\n    if (requestTimeout !== undefined) {\n      throw new InvalidArgumentError('unsupported requestTimeout, use headersTimeout & bodyTimeout instead');\n    }\n    if (idleTimeout !== undefined) {\n      throw new InvalidArgumentError('unsupported idleTimeout, use keepAliveTimeout instead');\n    }\n    if (maxKeepAliveTimeout !== undefined) {\n      throw new InvalidArgumentError('unsupported maxKeepAliveTimeout, use keepAliveMaxTimeout instead');\n    }\n    if (maxHeaderSize != null && !Number.isFinite(maxHeaderSize)) {\n      throw new InvalidArgumentError('invalid maxHeaderSize');\n    }\n    if (socketPath != null && typeof socketPath !== 'string') {\n      throw new InvalidArgumentError('invalid socketPath');\n    }\n    if (connectTimeout != null && (!Number.isFinite(connectTimeout) || connectTimeout < 0)) {\n      throw new InvalidArgumentError('invalid connectTimeout');\n    }\n    if (keepAliveTimeout != null && (!Number.isFinite(keepAliveTimeout) || keepAliveTimeout <= 0)) {\n      throw new InvalidArgumentError('invalid keepAliveTimeout');\n    }\n    if (keepAliveMaxTimeout != null && (!Number.isFinite(keepAliveMaxTimeout) || keepAliveMaxTimeout <= 0)) {\n      throw new InvalidArgumentError('invalid keepAliveMaxTimeout');\n    }\n    if (keepAliveTimeoutThreshold != null && !Number.isFinite(keepAliveTimeoutThreshold)) {\n      throw new InvalidArgumentError('invalid keepAliveTimeoutThreshold');\n    }\n    if (headersTimeout != null && (!Number.isInteger(headersTimeout) || headersTimeout < 0)) {\n      throw new InvalidArgumentError('headersTimeout must be a positive integer or zero');\n    }\n    if (bodyTimeout != null && (!Number.isInteger(bodyTimeout) || bodyTimeout < 0)) {\n      throw new InvalidArgumentError('bodyTimeout must be a positive integer or zero');\n    }\n    if (connect != null && typeof connect !== 'function' && typeof connect !== 'object') {\n      throw new InvalidArgumentError('connect must be a function or an object');\n    }\n    if (maxRedirections != null && (!Number.isInteger(maxRedirections) || maxRedirections < 0)) {\n      throw new InvalidArgumentError('maxRedirections must be a positive number');\n    }\n    if (maxRequestsPerClient != null && (!Number.isInteger(maxRequestsPerClient) || maxRequestsPerClient < 0)) {\n      throw new InvalidArgumentError('maxRequestsPerClient must be a positive number');\n    }\n    if (localAddress != null && (typeof localAddress !== 'string' || net.isIP(localAddress) === 0)) {\n      throw new InvalidArgumentError('localAddress must be valid string IP address');\n    }\n    if (maxResponseSize != null && (!Number.isInteger(maxResponseSize) || maxResponseSize < -1)) {\n      throw new InvalidArgumentError('maxResponseSize must be a positive number');\n    }\n    if (typeof connect !== 'function') {\n      connect = buildConnector({\n        ...tls,\n        maxCachedSessions,\n        socketPath,\n        timeout: connectTimeout,\n        ...connect\n      });\n    }\n    this[kInterceptors] = interceptors && interceptors.Client && Array.isArray(interceptors.Client) ? interceptors.Client : [createRedirectInterceptor({\n      maxRedirections\n    })];\n    this[kUrl] = util.parseOrigin(url);\n    this[kConnector] = connect;\n    this[kSocket] = null;\n    this[kPipelining] = pipelining != null ? pipelining : 1;\n    this[kMaxHeadersSize] = maxHeaderSize || 16384;\n    this[kKeepAliveDefaultTimeout] = keepAliveTimeout == null ? 4e3 : keepAliveTimeout;\n    this[kKeepAliveMaxTimeout] = keepAliveMaxTimeout == null ? 600e3 : keepAliveMaxTimeout;\n    this[kKeepAliveTimeoutThreshold] = keepAliveTimeoutThreshold == null ? 1e3 : keepAliveTimeoutThreshold;\n    this[kKeepAliveTimeoutValue] = this[kKeepAliveDefaultTimeout];\n    this[kServerName] = null;\n    this[kLocalAddress] = localAddress != null ? localAddress : null;\n    this[kResuming] = 0; // 0, idle, 1, scheduled, 2 resuming\n    this[kNeedDrain] = 0; // 0, idle, 1, scheduled, 2 resuming\n    this[kHostHeader] = `host: ${this[kUrl].hostname}${this[kUrl].port ? `:${this[kUrl].port}` : ''}\\r\\n`;\n    this[kBodyTimeout] = bodyTimeout != null ? bodyTimeout : 30e3;\n    this[kHeadersTimeout] = headersTimeout != null ? headersTimeout : 30e3;\n    this[kStrictContentLength] = strictContentLength == null ? true : strictContentLength;\n    this[kMaxRedirections] = maxRedirections;\n    this[kMaxRequests] = maxRequestsPerClient;\n    this[kClosedResolve] = null;\n    this[kMaxResponseSize] = maxResponseSize > -1 ? maxResponseSize : -1;\n\n    // kQueue is built up of 3 sections separated by\n    // the kRunningIdx and kPendingIdx indices.\n    // |   complete   |   running   |   pending   |\n    //                ^ kRunningIdx ^ kPendingIdx ^ kQueue.length\n    // kRunningIdx points to the first running element.\n    // kPendingIdx points to the first pending element.\n    // This implements a fast queue with an amortized\n    // time of O(1).\n\n    this[kQueue] = [];\n    this[kRunningIdx] = 0;\n    this[kPendingIdx] = 0;\n  }\n  get pipelining() {\n    return this[kPipelining];\n  }\n  set pipelining(value) {\n    this[kPipelining] = value;\n    resume(this, true);\n  }\n  get [kPending]() {\n    return this[kQueue].length - this[kPendingIdx];\n  }\n  get [kRunning]() {\n    return this[kPendingIdx] - this[kRunningIdx];\n  }\n  get [kSize]() {\n    return this[kQueue].length - this[kRunningIdx];\n  }\n  get [kConnected]() {\n    return !!this[kSocket] && !this[kConnecting] && !this[kSocket].destroyed;\n  }\n  get [kBusy]() {\n    const socket = this[kSocket];\n    return socket && (socket[kReset] || socket[kWriting] || socket[kBlocking]) || this[kSize] >= (this[kPipelining] || 1) || this[kPending] > 0;\n  }\n\n  /* istanbul ignore: only used for test */\n  [kConnect](cb) {\n    connect(this);\n    this.once('connect', cb);\n  }\n  [kDispatch](opts, handler) {\n    const origin = opts.origin || this[kUrl].origin;\n    const request = new Request(origin, opts, handler);\n    this[kQueue].push(request);\n    if (this[kResuming]) {\n      // Do nothing.\n    } else if (util.bodyLength(request.body) == null && util.isIterable(request.body)) {\n      // Wait a tick in case stream/iterator is ended in the same tick.\n      this[kResuming] = 1;\n      process.nextTick(resume, this);\n    } else {\n      resume(this, true);\n    }\n    if (this[kResuming] && this[kNeedDrain] !== 2 && this[kBusy]) {\n      this[kNeedDrain] = 2;\n    }\n    return this[kNeedDrain] < 2;\n  }\n  async [kClose]() {\n    return new Promise(resolve => {\n      if (!this[kSize]) {\n        this.destroy(resolve);\n      } else {\n        this[kClosedResolve] = resolve;\n      }\n    });\n  }\n  async [kDestroy](err) {\n    return new Promise(resolve => {\n      const requests = this[kQueue].splice(this[kPendingIdx]);\n      for (let i = 0; i < requests.length; i++) {\n        const request = requests[i];\n        errorRequest(this, request, err);\n      }\n      const callback = () => {\n        if (this[kClosedResolve]) {\n          this[kClosedResolve]();\n          this[kClosedResolve] = null;\n        }\n        resolve();\n      };\n      if (!this[kSocket]) {\n        queueMicrotask(callback);\n      } else {\n        util.destroy(this[kSocket].on('close', callback), err);\n      }\n      resume(this);\n    });\n  }\n}\nconst constants = require('./llhttp/constants');\nconst createRedirectInterceptor = require('./interceptor/redirectInterceptor');\nconst EMPTY_BUF = Buffer.alloc(0);\nasync function lazyllhttp() {\n  const llhttpWasmData = process.env.JEST_WORKER_ID ? require('./llhttp/llhttp.wasm.js') : undefined;\n  let mod;\n  try {\n    mod = await WebAssembly.compile(Buffer.from(require('./llhttp/llhttp_simd.wasm.js'), 'base64'));\n  } catch (e) {\n    /* istanbul ignore next */\n\n    // We could check if the error was caused by the simd option not\n    // being enabled, but the occurring of this other error\n    // * https://github.com/emscripten-core/emscripten/issues/11495\n    // got me to remove that check to avoid breaking Node 12.\n    mod = await WebAssembly.compile(Buffer.from(llhttpWasmData || require('./llhttp/llhttp.wasm.js'), 'base64'));\n  }\n  return await WebAssembly.instantiate(mod, {\n    env: {\n      /* eslint-disable camelcase */\n\n      wasm_on_url: (p, at, len) => {\n        /* istanbul ignore next */\n        return 0;\n      },\n      wasm_on_status: (p, at, len) => {\n        assert.strictEqual(currentParser.ptr, p);\n        const start = at - currentBufferPtr;\n        const end = start + len;\n        return currentParser.onStatus(currentBufferRef.slice(start, end)) || 0;\n      },\n      wasm_on_message_begin: p => {\n        assert.strictEqual(currentParser.ptr, p);\n        return currentParser.onMessageBegin() || 0;\n      },\n      wasm_on_header_field: (p, at, len) => {\n        assert.strictEqual(currentParser.ptr, p);\n        const start = at - currentBufferPtr;\n        const end = start + len;\n        return currentParser.onHeaderField(currentBufferRef.slice(start, end)) || 0;\n      },\n      wasm_on_header_value: (p, at, len) => {\n        assert.strictEqual(currentParser.ptr, p);\n        const start = at - currentBufferPtr;\n        const end = start + len;\n        return currentParser.onHeaderValue(currentBufferRef.slice(start, end)) || 0;\n      },\n      wasm_on_headers_complete: (p, statusCode, upgrade, shouldKeepAlive) => {\n        assert.strictEqual(currentParser.ptr, p);\n        return currentParser.onHeadersComplete(statusCode, Boolean(upgrade), Boolean(shouldKeepAlive)) || 0;\n      },\n      wasm_on_body: (p, at, len) => {\n        assert.strictEqual(currentParser.ptr, p);\n        const start = at - currentBufferPtr;\n        const end = start + len;\n        return currentParser.onBody(currentBufferRef.slice(start, end)) || 0;\n      },\n      wasm_on_message_complete: p => {\n        assert.strictEqual(currentParser.ptr, p);\n        return currentParser.onMessageComplete() || 0;\n      }\n\n      /* eslint-enable camelcase */\n    }\n  });\n}\n\nlet llhttpInstance = null;\nlet llhttpPromise = lazyllhttp().catch(() => {});\nlet currentParser = null;\nlet currentBufferRef = null;\nlet currentBufferSize = 0;\nlet currentBufferPtr = null;\nconst TIMEOUT_HEADERS = 1;\nconst TIMEOUT_BODY = 2;\nconst TIMEOUT_IDLE = 3;\nclass Parser {\n  constructor(client, socket, _ref) {\n    let {\n      exports\n    } = _ref;\n    assert(Number.isFinite(client[kMaxHeadersSize]) && client[kMaxHeadersSize] > 0);\n    this.llhttp = exports;\n    this.ptr = this.llhttp.llhttp_alloc(constants.TYPE.RESPONSE);\n    this.client = client;\n    this.socket = socket;\n    this.timeout = null;\n    this.timeoutValue = null;\n    this.timeoutType = null;\n    this.statusCode = null;\n    this.statusText = '';\n    this.upgrade = false;\n    this.headers = [];\n    this.headersSize = 0;\n    this.headersMaxSize = client[kMaxHeadersSize];\n    this.shouldKeepAlive = false;\n    this.paused = false;\n    this.resume = this.resume.bind(this);\n    this.bytesRead = 0;\n    this.keepAlive = '';\n    this.contentLength = '';\n    this.maxResponseSize = client[kMaxResponseSize];\n  }\n  setTimeout(value, type) {\n    this.timeoutType = type;\n    if (value !== this.timeoutValue) {\n      clearTimeout(this.timeout);\n      if (value) {\n        this.timeout = setTimeout(onParserTimeout, value, this);\n        // istanbul ignore else: only for jest\n        if (this.timeout.unref) {\n          this.timeout.unref();\n        }\n      } else {\n        this.timeout = null;\n      }\n      this.timeoutValue = value;\n    } else if (this.timeout) {\n      // istanbul ignore else: only for jest\n      if (this.timeout.refresh) {\n        this.timeout.refresh();\n      }\n    }\n  }\n  resume() {\n    if (this.socket.destroyed || !this.paused) {\n      return;\n    }\n    assert(this.ptr != null);\n    assert(currentParser == null);\n    this.llhttp.llhttp_resume(this.ptr);\n    assert(this.timeoutType === TIMEOUT_BODY);\n    if (this.timeout) {\n      // istanbul ignore else: only for jest\n      if (this.timeout.refresh) {\n        this.timeout.refresh();\n      }\n    }\n    this.paused = false;\n    this.execute(this.socket.read() || EMPTY_BUF); // Flush parser.\n    this.readMore();\n  }\n  readMore() {\n    while (!this.paused && this.ptr) {\n      const chunk = this.socket.read();\n      if (chunk === null) {\n        break;\n      }\n      this.execute(chunk);\n    }\n  }\n  execute(data) {\n    assert(this.ptr != null);\n    assert(currentParser == null);\n    assert(!this.paused);\n    const {\n      socket,\n      llhttp\n    } = this;\n    if (data.length > currentBufferSize) {\n      if (currentBufferPtr) {\n        llhttp.free(currentBufferPtr);\n      }\n      currentBufferSize = Math.ceil(data.length / 4096) * 4096;\n      currentBufferPtr = llhttp.malloc(currentBufferSize);\n    }\n    new Uint8Array(llhttp.memory.buffer, currentBufferPtr, currentBufferSize).set(data);\n\n    // Call `execute` on the wasm parser.\n    // We pass the `llhttp_parser` pointer address, the pointer address of buffer view data,\n    // and finally the length of bytes to parse.\n    // The return value is an error code or `constants.ERROR.OK`.\n    try {\n      let ret;\n      try {\n        currentBufferRef = data;\n        currentParser = this;\n        ret = llhttp.llhttp_execute(this.ptr, currentBufferPtr, data.length);\n        /* eslint-disable-next-line no-useless-catch */\n      } catch (err) {\n        /* istanbul ignore next: difficult to make a test case for */\n        throw err;\n      } finally {\n        currentParser = null;\n        currentBufferRef = null;\n      }\n      const offset = llhttp.llhttp_get_error_pos(this.ptr) - currentBufferPtr;\n      if (ret === constants.ERROR.PAUSED_UPGRADE) {\n        this.onUpgrade(data.slice(offset));\n      } else if (ret === constants.ERROR.PAUSED) {\n        this.paused = true;\n        socket.unshift(data.slice(offset));\n      } else if (ret !== constants.ERROR.OK) {\n        const ptr = llhttp.llhttp_get_error_reason(this.ptr);\n        let message = '';\n        /* istanbul ignore else: difficult to make a test case for */\n        if (ptr) {\n          const len = new Uint8Array(llhttp.memory.buffer, ptr).indexOf(0);\n          message = Buffer.from(llhttp.memory.buffer, ptr, len).toString();\n        }\n        throw new HTTPParserError(message, constants.ERROR[ret], data.slice(offset));\n      }\n    } catch (err) {\n      util.destroy(socket, err);\n    }\n  }\n  destroy() {\n    assert(this.ptr != null);\n    assert(currentParser == null);\n    this.llhttp.llhttp_free(this.ptr);\n    this.ptr = null;\n    clearTimeout(this.timeout);\n    this.timeout = null;\n    this.timeoutValue = null;\n    this.timeoutType = null;\n    this.paused = false;\n  }\n  onStatus(buf) {\n    this.statusText = buf.toString();\n  }\n  onMessageBegin() {\n    const {\n      socket,\n      client\n    } = this;\n\n    /* istanbul ignore next: difficult to make a test case for */\n    if (socket.destroyed) {\n      return -1;\n    }\n    const request = client[kQueue][client[kRunningIdx]];\n    if (!request) {\n      return -1;\n    }\n  }\n  onHeaderField(buf) {\n    const len = this.headers.length;\n    if ((len & 1) === 0) {\n      this.headers.push(buf);\n    } else {\n      this.headers[len - 1] = Buffer.concat([this.headers[len - 1], buf]);\n    }\n    this.trackHeader(buf.length);\n  }\n  onHeaderValue(buf) {\n    let len = this.headers.length;\n    if ((len & 1) === 1) {\n      this.headers.push(buf);\n      len += 1;\n    } else {\n      this.headers[len - 1] = Buffer.concat([this.headers[len - 1], buf]);\n    }\n    const key = this.headers[len - 2];\n    if (key.length === 10 && key.toString().toLowerCase() === 'keep-alive') {\n      this.keepAlive += buf.toString();\n    } else if (key.length === 14 && key.toString().toLowerCase() === 'content-length') {\n      this.contentLength += buf.toString();\n    }\n    this.trackHeader(buf.length);\n  }\n  trackHeader(len) {\n    this.headersSize += len;\n    if (this.headersSize >= this.headersMaxSize) {\n      util.destroy(this.socket, new HeadersOverflowError());\n    }\n  }\n  onUpgrade(head) {\n    const {\n      upgrade,\n      client,\n      socket,\n      headers,\n      statusCode\n    } = this;\n    assert(upgrade);\n    const request = client[kQueue][client[kRunningIdx]];\n    assert(request);\n    assert(!socket.destroyed);\n    assert(socket === client[kSocket]);\n    assert(!this.paused);\n    assert(request.upgrade || request.method === 'CONNECT');\n    this.statusCode = null;\n    this.statusText = '';\n    this.shouldKeepAlive = null;\n    assert(this.headers.length % 2 === 0);\n    this.headers = [];\n    this.headersSize = 0;\n    socket.unshift(head);\n    socket[kParser].destroy();\n    socket[kParser] = null;\n    socket[kClient] = null;\n    socket[kError] = null;\n    socket.removeListener('error', onSocketError).removeListener('readable', onSocketReadable).removeListener('end', onSocketEnd).removeListener('close', onSocketClose);\n    client[kSocket] = null;\n    client[kQueue][client[kRunningIdx]++] = null;\n    client.emit('disconnect', client[kUrl], [client], new InformationalError('upgrade'));\n    try {\n      request.onUpgrade(statusCode, headers, socket);\n    } catch (err) {\n      util.destroy(socket, err);\n    }\n    resume(client);\n  }\n  onHeadersComplete(statusCode, upgrade, shouldKeepAlive) {\n    const {\n      client,\n      socket,\n      headers,\n      statusText\n    } = this;\n\n    /* istanbul ignore next: difficult to make a test case for */\n    if (socket.destroyed) {\n      return -1;\n    }\n    const request = client[kQueue][client[kRunningIdx]];\n\n    /* istanbul ignore next: difficult to make a test case for */\n    if (!request) {\n      return -1;\n    }\n    assert(!this.upgrade);\n    assert(this.statusCode < 200);\n    if (statusCode === 100) {\n      util.destroy(socket, new SocketError('bad response', util.getSocketInfo(socket)));\n      return -1;\n    }\n\n    /* this can only happen if server is misbehaving */\n    if (upgrade && !request.upgrade) {\n      util.destroy(socket, new SocketError('bad upgrade', util.getSocketInfo(socket)));\n      return -1;\n    }\n    assert.strictEqual(this.timeoutType, TIMEOUT_HEADERS);\n    this.statusCode = statusCode;\n    this.shouldKeepAlive = shouldKeepAlive;\n    if (this.statusCode >= 200) {\n      const bodyTimeout = request.bodyTimeout != null ? request.bodyTimeout : client[kBodyTimeout];\n      this.setTimeout(bodyTimeout, TIMEOUT_BODY);\n    } else if (this.timeout) {\n      // istanbul ignore else: only for jest\n      if (this.timeout.refresh) {\n        this.timeout.refresh();\n      }\n    }\n    if (request.method === 'CONNECT') {\n      assert(client[kRunning] === 1);\n      this.upgrade = true;\n      return 2;\n    }\n    if (upgrade) {\n      assert(client[kRunning] === 1);\n      this.upgrade = true;\n      return 2;\n    }\n    assert(this.headers.length % 2 === 0);\n    this.headers = [];\n    this.headersSize = 0;\n    if (shouldKeepAlive && client[kPipelining]) {\n      const keepAliveTimeout = this.keepAlive ? util.parseKeepAliveTimeout(this.keepAlive) : null;\n      if (keepAliveTimeout != null) {\n        const timeout = Math.min(keepAliveTimeout - client[kKeepAliveTimeoutThreshold], client[kKeepAliveMaxTimeout]);\n        if (timeout <= 0) {\n          socket[kReset] = true;\n        } else {\n          client[kKeepAliveTimeoutValue] = timeout;\n        }\n      } else {\n        client[kKeepAliveTimeoutValue] = client[kKeepAliveDefaultTimeout];\n      }\n    } else {\n      // Stop more requests from being dispatched.\n      socket[kReset] = true;\n    }\n    let pause;\n    try {\n      pause = request.onHeaders(statusCode, headers, this.resume, statusText) === false;\n    } catch (err) {\n      util.destroy(socket, err);\n      return -1;\n    }\n    if (request.method === 'HEAD') {\n      assert(socket[kReset]);\n      return 1;\n    }\n    if (statusCode < 200) {\n      return 1;\n    }\n    if (socket[kBlocking]) {\n      socket[kBlocking] = false;\n      resume(client);\n    }\n    return pause ? constants.ERROR.PAUSED : 0;\n  }\n  onBody(buf) {\n    const {\n      client,\n      socket,\n      statusCode,\n      maxResponseSize\n    } = this;\n    if (socket.destroyed) {\n      return -1;\n    }\n    const request = client[kQueue][client[kRunningIdx]];\n    assert(request);\n    assert.strictEqual(this.timeoutType, TIMEOUT_BODY);\n    if (this.timeout) {\n      // istanbul ignore else: only for jest\n      if (this.timeout.refresh) {\n        this.timeout.refresh();\n      }\n    }\n    assert(statusCode >= 200);\n    if (maxResponseSize > -1 && this.bytesRead + buf.length > maxResponseSize) {\n      util.destroy(socket, new ResponseExceededMaxSizeError());\n      return -1;\n    }\n    this.bytesRead += buf.length;\n    try {\n      if (request.onData(buf) === false) {\n        return constants.ERROR.PAUSED;\n      }\n    } catch (err) {\n      util.destroy(socket, err);\n      return -1;\n    }\n  }\n  onMessageComplete() {\n    const {\n      client,\n      socket,\n      statusCode,\n      upgrade,\n      headers,\n      contentLength,\n      bytesRead,\n      shouldKeepAlive\n    } = this;\n    if (socket.destroyed && (!statusCode || shouldKeepAlive)) {\n      return -1;\n    }\n    if (upgrade) {\n      return;\n    }\n    const request = client[kQueue][client[kRunningIdx]];\n    assert(request);\n    assert(statusCode >= 100);\n    this.statusCode = null;\n    this.statusText = '';\n    this.bytesRead = 0;\n    this.contentLength = '';\n    this.keepAlive = '';\n    assert(this.headers.length % 2 === 0);\n    this.headers = [];\n    this.headersSize = 0;\n    if (statusCode < 200) {\n      return;\n    }\n\n    /* istanbul ignore next: should be handled by llhttp? */\n    if (request.method !== 'HEAD' && contentLength && bytesRead !== parseInt(contentLength, 10)) {\n      util.destroy(socket, new ResponseContentLengthMismatchError());\n      return -1;\n    }\n    try {\n      request.onComplete(headers);\n    } catch (err) {\n      errorRequest(client, request, err);\n    }\n    client[kQueue][client[kRunningIdx]++] = null;\n    if (socket[kWriting]) {\n      assert.strictEqual(client[kRunning], 0);\n      // Response completed before request.\n      util.destroy(socket, new InformationalError('reset'));\n      return constants.ERROR.PAUSED;\n    } else if (!shouldKeepAlive) {\n      util.destroy(socket, new InformationalError('reset'));\n      return constants.ERROR.PAUSED;\n    } else if (socket[kReset] && client[kRunning] === 0) {\n      // Destroy socket once all requests have completed.\n      // The request at the tail of the pipeline is the one\n      // that requested reset and no further requests should\n      // have been queued since then.\n      util.destroy(socket, new InformationalError('reset'));\n      return constants.ERROR.PAUSED;\n    } else if (client[kPipelining] === 1) {\n      // We must wait a full event loop cycle to reuse this socket to make sure\n      // that non-spec compliant servers are not closing the connection even if they\n      // said they won't.\n      setImmediate(resume, client);\n    } else {\n      resume(client);\n    }\n  }\n}\nfunction onParserTimeout(parser) {\n  const {\n    socket,\n    timeoutType,\n    client\n  } = parser;\n\n  /* istanbul ignore else */\n  if (timeoutType === TIMEOUT_HEADERS) {\n    if (!socket[kWriting] || socket.writableNeedDrain || client[kRunning] > 1) {\n      assert(!parser.paused, 'cannot be paused while waiting for headers');\n      util.destroy(socket, new HeadersTimeoutError());\n    }\n  } else if (timeoutType === TIMEOUT_BODY) {\n    if (!parser.paused) {\n      util.destroy(socket, new BodyTimeoutError());\n    }\n  } else if (timeoutType === TIMEOUT_IDLE) {\n    assert(client[kRunning] === 0 && client[kKeepAliveTimeoutValue]);\n    util.destroy(socket, new InformationalError('socket idle timeout'));\n  }\n}\nfunction onSocketReadable() {\n  const {\n    [kParser]: parser\n  } = this;\n  parser.readMore();\n}\nfunction onSocketError(err) {\n  const {\n    [kParser]: parser\n  } = this;\n  assert(err.code !== 'ERR_TLS_CERT_ALTNAME_INVALID');\n\n  // On Mac OS, we get an ECONNRESET even if there is a full body to be forwarded\n  // to the user.\n  if (err.code === 'ECONNRESET' && parser.statusCode && !parser.shouldKeepAlive) {\n    // We treat all incoming data so for as a valid response.\n    parser.onMessageComplete();\n    return;\n  }\n  this[kError] = err;\n  onError(this[kClient], err);\n}\nfunction onError(client, err) {\n  if (client[kRunning] === 0 && err.code !== 'UND_ERR_INFO' && err.code !== 'UND_ERR_SOCKET') {\n    // Error is not caused by running request and not a recoverable\n    // socket error.\n\n    assert(client[kPendingIdx] === client[kRunningIdx]);\n    const requests = client[kQueue].splice(client[kRunningIdx]);\n    for (let i = 0; i < requests.length; i++) {\n      const request = requests[i];\n      errorRequest(client, request, err);\n    }\n    assert(client[kSize] === 0);\n  }\n}\nfunction onSocketEnd() {\n  const {\n    [kParser]: parser\n  } = this;\n  if (parser.statusCode && !parser.shouldKeepAlive) {\n    // We treat all incoming data so far as a valid response.\n    parser.onMessageComplete();\n    return;\n  }\n  util.destroy(this, new SocketError('other side closed', util.getSocketInfo(this)));\n}\nfunction onSocketClose() {\n  const {\n    [kClient]: client\n  } = this;\n  if (!this[kError] && this[kParser].statusCode && !this[kParser].shouldKeepAlive) {\n    // We treat all incoming data so far as a valid response.\n    this[kParser].onMessageComplete();\n  }\n  this[kParser].destroy();\n  this[kParser] = null;\n  const err = this[kError] || new SocketError('closed', util.getSocketInfo(this));\n  client[kSocket] = null;\n  if (client.destroyed) {\n    assert(client[kPending] === 0);\n\n    // Fail entire queue.\n    const requests = client[kQueue].splice(client[kRunningIdx]);\n    for (let i = 0; i < requests.length; i++) {\n      const request = requests[i];\n      errorRequest(client, request, err);\n    }\n  } else if (client[kRunning] > 0 && err.code !== 'UND_ERR_INFO') {\n    // Fail head of pipeline.\n    const request = client[kQueue][client[kRunningIdx]];\n    client[kQueue][client[kRunningIdx]++] = null;\n    errorRequest(client, request, err);\n  }\n  client[kPendingIdx] = client[kRunningIdx];\n  assert(client[kRunning] === 0);\n  client.emit('disconnect', client[kUrl], [client], err);\n  resume(client);\n}\nasync function connect(client) {\n  assert(!client[kConnecting]);\n  assert(!client[kSocket]);\n  let {\n    host,\n    hostname,\n    protocol,\n    port\n  } = client[kUrl];\n\n  // Resolve ipv6\n  if (hostname[0] === '[') {\n    const idx = hostname.indexOf(']');\n    assert(idx !== -1);\n    const ip = hostname.substr(1, idx - 1);\n    assert(net.isIP(ip));\n    hostname = ip;\n  }\n  client[kConnecting] = true;\n  if (channels.beforeConnect.hasSubscribers) {\n    channels.beforeConnect.publish({\n      connectParams: {\n        host,\n        hostname,\n        protocol,\n        port,\n        servername: client[kServerName],\n        localAddress: client[kLocalAddress]\n      },\n      connector: client[kConnector]\n    });\n  }\n  try {\n    const socket = await new Promise((resolve, reject) => {\n      client[kConnector]({\n        host,\n        hostname,\n        protocol,\n        port,\n        servername: client[kServerName],\n        localAddress: client[kLocalAddress]\n      }, (err, socket) => {\n        if (err) {\n          reject(err);\n        } else {\n          resolve(socket);\n        }\n      });\n    });\n    if (!llhttpInstance) {\n      llhttpInstance = await llhttpPromise;\n      llhttpPromise = null;\n    }\n    client[kConnecting] = false;\n    assert(socket);\n    client[kSocket] = socket;\n    socket[kNoRef] = false;\n    socket[kWriting] = false;\n    socket[kReset] = false;\n    socket[kBlocking] = false;\n    socket[kError] = null;\n    socket[kParser] = new Parser(client, socket, llhttpInstance);\n    socket[kClient] = client;\n    socket[kCounter] = 0;\n    socket[kMaxRequests] = client[kMaxRequests];\n    socket.on('error', onSocketError).on('readable', onSocketReadable).on('end', onSocketEnd).on('close', onSocketClose);\n    if (channels.connected.hasSubscribers) {\n      channels.connected.publish({\n        connectParams: {\n          host,\n          hostname,\n          protocol,\n          port,\n          servername: client[kServerName],\n          localAddress: client[kLocalAddress]\n        },\n        connector: client[kConnector],\n        socket\n      });\n    }\n    client.emit('connect', client[kUrl], [client]);\n  } catch (err) {\n    client[kConnecting] = false;\n    if (channels.connectError.hasSubscribers) {\n      channels.connectError.publish({\n        connectParams: {\n          host,\n          hostname,\n          protocol,\n          port,\n          servername: client[kServerName],\n          localAddress: client[kLocalAddress]\n        },\n        connector: client[kConnector],\n        error: err\n      });\n    }\n    if (err.code === 'ERR_TLS_CERT_ALTNAME_INVALID') {\n      assert(client[kRunning] === 0);\n      while (client[kPending] > 0 && client[kQueue][client[kPendingIdx]].servername === client[kServerName]) {\n        const request = client[kQueue][client[kPendingIdx]++];\n        errorRequest(client, request, err);\n      }\n    } else {\n      onError(client, err);\n    }\n    client.emit('connectionError', client[kUrl], [client], err);\n  }\n  resume(client);\n}\nfunction emitDrain(client) {\n  client[kNeedDrain] = 0;\n  client.emit('drain', client[kUrl], [client]);\n}\nfunction resume(client, sync) {\n  if (client[kResuming] === 2) {\n    return;\n  }\n  client[kResuming] = 2;\n  _resume(client, sync);\n  client[kResuming] = 0;\n  if (client[kRunningIdx] > 256) {\n    client[kQueue].splice(0, client[kRunningIdx]);\n    client[kPendingIdx] -= client[kRunningIdx];\n    client[kRunningIdx] = 0;\n  }\n}\nfunction _resume(client, sync) {\n  while (true) {\n    if (client.destroyed) {\n      assert(client[kPending] === 0);\n      return;\n    }\n    if (client.closed && !client[kSize]) {\n      client.destroy();\n      return;\n    }\n    const socket = client[kSocket];\n    if (socket) {\n      if (client[kSize] === 0) {\n        if (!socket[kNoRef] && socket.unref) {\n          socket.unref();\n          socket[kNoRef] = true;\n        }\n      } else if (socket[kNoRef] && socket.ref) {\n        socket.ref();\n        socket[kNoRef] = false;\n      }\n      if (client[kSize] === 0) {\n        if (socket[kParser].timeoutType !== TIMEOUT_IDLE) {\n          socket[kParser].setTimeout(client[kKeepAliveTimeoutValue], TIMEOUT_IDLE);\n        }\n      } else if (client[kRunning] > 0 && socket[kParser].statusCode < 200) {\n        if (socket[kParser].timeoutType !== TIMEOUT_HEADERS) {\n          const request = client[kQueue][client[kRunningIdx]];\n          const headersTimeout = request.headersTimeout != null ? request.headersTimeout : client[kHeadersTimeout];\n          socket[kParser].setTimeout(headersTimeout, TIMEOUT_HEADERS);\n        }\n      }\n    }\n    if (client[kBusy]) {\n      client[kNeedDrain] = 2;\n    } else if (client[kNeedDrain] === 2) {\n      if (sync) {\n        client[kNeedDrain] = 1;\n        process.nextTick(emitDrain, client);\n      } else {\n        emitDrain(client);\n      }\n      continue;\n    }\n    if (client[kPending] === 0) {\n      return;\n    }\n    if (client[kRunning] >= (client[kPipelining] || 1)) {\n      return;\n    }\n    const request = client[kQueue][client[kPendingIdx]];\n    if (client[kUrl].protocol === 'https:' && client[kServerName] !== request.servername) {\n      if (client[kRunning] > 0) {\n        return;\n      }\n      client[kServerName] = request.servername;\n      if (socket && socket.servername !== request.servername) {\n        util.destroy(socket, new InformationalError('servername changed'));\n        return;\n      }\n    }\n    if (client[kConnecting]) {\n      return;\n    }\n    if (!socket) {\n      connect(client);\n      continue;\n    }\n    if (socket.destroyed || socket[kWriting] || socket[kReset] || socket[kBlocking]) {\n      return;\n    }\n    if (client[kRunning] > 0 && !request.idempotent) {\n      // Non-idempotent request cannot be retried.\n      // Ensure that no other requests are inflight and\n      // could cause failure.\n      return;\n    }\n    if (client[kRunning] > 0 && (request.upgrade || request.method === 'CONNECT')) {\n      // Don't dispatch an upgrade until all preceding requests have completed.\n      // A misbehaving server might upgrade the connection before all pipelined\n      // request has completed.\n      return;\n    }\n    if (util.isStream(request.body) && util.bodyLength(request.body) === 0) {\n      request.body.on('data', /* istanbul ignore next */function () {\n        /* istanbul ignore next */\n        assert(false);\n      }).on('error', function (err) {\n        errorRequest(client, request, err);\n      }).on('end', function () {\n        util.destroy(this);\n      });\n      request.body = null;\n    }\n    if (client[kRunning] > 0 && (util.isStream(request.body) || util.isAsyncIterable(request.body))) {\n      // Request with stream or iterator body can error while other requests\n      // are inflight and indirectly error those as well.\n      // Ensure this doesn't happen by waiting for inflight\n      // to complete before dispatching.\n\n      // Request with stream or iterator body cannot be retried.\n      // Ensure that no other requests are inflight and\n      // could cause failure.\n      return;\n    }\n    if (!request.aborted && write(client, request)) {\n      client[kPendingIdx]++;\n    } else {\n      client[kQueue].splice(client[kPendingIdx], 1);\n    }\n  }\n}\nfunction write(client, request) {\n  const {\n    body,\n    method,\n    path,\n    host,\n    upgrade,\n    headers,\n    blocking,\n    reset\n  } = request;\n\n  // https://tools.ietf.org/html/rfc7231#section-4.3.1\n  // https://tools.ietf.org/html/rfc7231#section-4.3.2\n  // https://tools.ietf.org/html/rfc7231#section-4.3.5\n\n  // Sending a payload body on a request that does not\n  // expect it can cause undefined behavior on some\n  // servers and corrupt connection state. Do not\n  // re-use the connection for further requests.\n\n  const expectsPayload = method === 'PUT' || method === 'POST' || method === 'PATCH';\n  if (body && typeof body.read === 'function') {\n    // Try to read EOF in order to get length.\n    body.read(0);\n  }\n  let contentLength = util.bodyLength(body);\n  if (contentLength === null) {\n    contentLength = request.contentLength;\n  }\n  if (contentLength === 0 && !expectsPayload) {\n    // https://tools.ietf.org/html/rfc7230#section-3.3.2\n    // A user agent SHOULD NOT send a Content-Length header field when\n    // the request message does not contain a payload body and the method\n    // semantics do not anticipate such a body.\n\n    contentLength = null;\n  }\n  if (request.contentLength !== null && request.contentLength !== contentLength) {\n    if (client[kStrictContentLength]) {\n      errorRequest(client, request, new RequestContentLengthMismatchError());\n      return false;\n    }\n    process.emitWarning(new RequestContentLengthMismatchError());\n  }\n  const socket = client[kSocket];\n  try {\n    request.onConnect(err => {\n      if (request.aborted || request.completed) {\n        return;\n      }\n      errorRequest(client, request, err || new RequestAbortedError());\n      util.destroy(socket, new InformationalError('aborted'));\n    });\n  } catch (err) {\n    errorRequest(client, request, err);\n  }\n  if (request.aborted) {\n    return false;\n  }\n  if (method === 'HEAD') {\n    // https://github.com/mcollina/undici/issues/258\n    // Close after a HEAD request to interop with misbehaving servers\n    // that may send a body in the response.\n\n    socket[kReset] = true;\n  }\n  if (upgrade || method === 'CONNECT') {\n    // On CONNECT or upgrade, block pipeline from dispatching further\n    // requests on this connection.\n\n    socket[kReset] = true;\n  }\n  if (reset) {\n    socket[kReset] = true;\n  }\n  if (client[kMaxRequests] && socket[kCounter]++ >= client[kMaxRequests]) {\n    socket[kReset] = true;\n  }\n  if (blocking) {\n    socket[kBlocking] = true;\n  }\n  let header = `${method} ${path} HTTP/1.1\\r\\n`;\n  if (typeof host === 'string') {\n    header += `host: ${host}\\r\\n`;\n  } else {\n    header += client[kHostHeader];\n  }\n  if (upgrade) {\n    header += `connection: upgrade\\r\\nupgrade: ${upgrade}\\r\\n`;\n  } else if (client[kPipelining] && !socket[kReset]) {\n    header += 'connection: keep-alive\\r\\n';\n  } else {\n    header += 'connection: close\\r\\n';\n  }\n  if (headers) {\n    header += headers;\n  }\n  if (channels.sendHeaders.hasSubscribers) {\n    channels.sendHeaders.publish({\n      request,\n      headers: header,\n      socket\n    });\n  }\n\n  /* istanbul ignore else: assertion */\n  if (!body) {\n    if (contentLength === 0) {\n      socket.write(`${header}content-length: 0\\r\\n\\r\\n`, 'ascii');\n    } else {\n      assert(contentLength === null, 'no body must not have content length');\n      socket.write(`${header}\\r\\n`, 'ascii');\n    }\n    request.onRequestSent();\n  } else if (util.isBuffer(body)) {\n    assert(contentLength === body.byteLength, 'buffer body must have content length');\n    socket.cork();\n    socket.write(`${header}content-length: ${contentLength}\\r\\n\\r\\n`, 'ascii');\n    socket.write(body);\n    socket.uncork();\n    request.onBodySent(body);\n    request.onRequestSent();\n    if (!expectsPayload) {\n      socket[kReset] = true;\n    }\n  } else if (util.isBlobLike(body)) {\n    if (typeof body.stream === 'function') {\n      writeIterable({\n        body: body.stream(),\n        client,\n        request,\n        socket,\n        contentLength,\n        header,\n        expectsPayload\n      });\n    } else {\n      writeBlob({\n        body,\n        client,\n        request,\n        socket,\n        contentLength,\n        header,\n        expectsPayload\n      });\n    }\n  } else if (util.isStream(body)) {\n    writeStream({\n      body,\n      client,\n      request,\n      socket,\n      contentLength,\n      header,\n      expectsPayload\n    });\n  } else if (util.isIterable(body)) {\n    writeIterable({\n      body,\n      client,\n      request,\n      socket,\n      contentLength,\n      header,\n      expectsPayload\n    });\n  } else {\n    assert(false);\n  }\n  return true;\n}\nfunction writeStream(_ref2) {\n  let {\n    body,\n    client,\n    request,\n    socket,\n    contentLength,\n    header,\n    expectsPayload\n  } = _ref2;\n  assert(contentLength !== 0 || client[kRunning] === 0, 'stream body cannot be pipelined');\n  let finished = false;\n  const writer = new AsyncWriter({\n    socket,\n    request,\n    contentLength,\n    client,\n    expectsPayload,\n    header\n  });\n  const onData = function (chunk) {\n    try {\n      assert(!finished);\n      if (!writer.write(chunk) && this.pause) {\n        this.pause();\n      }\n    } catch (err) {\n      util.destroy(this, err);\n    }\n  };\n  const onDrain = function () {\n    assert(!finished);\n    if (body.resume) {\n      body.resume();\n    }\n  };\n  const onAbort = function () {\n    onFinished(new RequestAbortedError());\n  };\n  const onFinished = function (err) {\n    if (finished) {\n      return;\n    }\n    finished = true;\n    assert(socket.destroyed || socket[kWriting] && client[kRunning] <= 1);\n    socket.off('drain', onDrain).off('error', onFinished);\n    body.removeListener('data', onData).removeListener('end', onFinished).removeListener('error', onFinished).removeListener('close', onAbort);\n    if (!err) {\n      try {\n        writer.end();\n      } catch (er) {\n        err = er;\n      }\n    }\n    writer.destroy(err);\n    if (err && (err.code !== 'UND_ERR_INFO' || err.message !== 'reset')) {\n      util.destroy(body, err);\n    } else {\n      util.destroy(body);\n    }\n  };\n  body.on('data', onData).on('end', onFinished).on('error', onFinished).on('close', onAbort);\n  if (body.resume) {\n    body.resume();\n  }\n  socket.on('drain', onDrain).on('error', onFinished);\n}\nasync function writeBlob(_ref3) {\n  let {\n    body,\n    client,\n    request,\n    socket,\n    contentLength,\n    header,\n    expectsPayload\n  } = _ref3;\n  assert(contentLength === body.size, 'blob body must have content length');\n  try {\n    if (contentLength != null && contentLength !== body.size) {\n      throw new RequestContentLengthMismatchError();\n    }\n    const buffer = Buffer.from(await body.arrayBuffer());\n    socket.cork();\n    socket.write(`${header}content-length: ${contentLength}\\r\\n\\r\\n`, 'ascii');\n    socket.write(buffer);\n    socket.uncork();\n    request.onBodySent(buffer);\n    request.onRequestSent();\n    if (!expectsPayload) {\n      socket[kReset] = true;\n    }\n    resume(client);\n  } catch (err) {\n    util.destroy(socket, err);\n  }\n}\nasync function writeIterable(_ref4) {\n  let {\n    body,\n    client,\n    request,\n    socket,\n    contentLength,\n    header,\n    expectsPayload\n  } = _ref4;\n  assert(contentLength !== 0 || client[kRunning] === 0, 'iterator body cannot be pipelined');\n  let callback = null;\n  function onDrain() {\n    if (callback) {\n      const cb = callback;\n      callback = null;\n      cb();\n    }\n  }\n  const waitForDrain = () => new Promise((resolve, reject) => {\n    assert(callback === null);\n    if (socket[kError]) {\n      reject(socket[kError]);\n    } else {\n      callback = resolve;\n    }\n  });\n  socket.on('close', onDrain).on('drain', onDrain);\n  const writer = new AsyncWriter({\n    socket,\n    request,\n    contentLength,\n    client,\n    expectsPayload,\n    header\n  });\n  try {\n    // It's up to the user to somehow abort the async iterable.\n    for await (const chunk of body) {\n      if (socket[kError]) {\n        throw socket[kError];\n      }\n      if (!writer.write(chunk)) {\n        await waitForDrain();\n      }\n    }\n    writer.end();\n  } catch (err) {\n    writer.destroy(err);\n  } finally {\n    socket.off('close', onDrain).off('drain', onDrain);\n  }\n}\nclass AsyncWriter {\n  constructor(_ref5) {\n    let {\n      socket,\n      request,\n      contentLength,\n      client,\n      expectsPayload,\n      header\n    } = _ref5;\n    this.socket = socket;\n    this.request = request;\n    this.contentLength = contentLength;\n    this.client = client;\n    this.bytesWritten = 0;\n    this.expectsPayload = expectsPayload;\n    this.header = header;\n    socket[kWriting] = true;\n  }\n  write(chunk) {\n    const {\n      socket,\n      request,\n      contentLength,\n      client,\n      bytesWritten,\n      expectsPayload,\n      header\n    } = this;\n    if (socket[kError]) {\n      throw socket[kError];\n    }\n    if (socket.destroyed) {\n      return false;\n    }\n    const len = Buffer.byteLength(chunk);\n    if (!len) {\n      return true;\n    }\n\n    // We should defer writing chunks.\n    if (contentLength !== null && bytesWritten + len > contentLength) {\n      if (client[kStrictContentLength]) {\n        throw new RequestContentLengthMismatchError();\n      }\n      process.emitWarning(new RequestContentLengthMismatchError());\n    }\n    if (bytesWritten === 0) {\n      if (!expectsPayload) {\n        socket[kReset] = true;\n      }\n      if (contentLength === null) {\n        socket.write(`${header}transfer-encoding: chunked\\r\\n`, 'ascii');\n      } else {\n        socket.write(`${header}content-length: ${contentLength}\\r\\n\\r\\n`, 'ascii');\n      }\n    }\n    if (contentLength === null) {\n      socket.write(`\\r\\n${len.toString(16)}\\r\\n`, 'ascii');\n    }\n    this.bytesWritten += len;\n    const ret = socket.write(chunk);\n    request.onBodySent(chunk);\n    if (!ret) {\n      if (socket[kParser].timeout && socket[kParser].timeoutType === TIMEOUT_HEADERS) {\n        // istanbul ignore else: only for jest\n        if (socket[kParser].timeout.refresh) {\n          socket[kParser].timeout.refresh();\n        }\n      }\n    }\n    return ret;\n  }\n  end() {\n    const {\n      socket,\n      contentLength,\n      client,\n      bytesWritten,\n      expectsPayload,\n      header,\n      request\n    } = this;\n    request.onRequestSent();\n    socket[kWriting] = false;\n    if (socket[kError]) {\n      throw socket[kError];\n    }\n    if (socket.destroyed) {\n      return;\n    }\n    if (bytesWritten === 0) {\n      if (expectsPayload) {\n        // https://tools.ietf.org/html/rfc7230#section-3.3.2\n        // A user agent SHOULD send a Content-Length in a request message when\n        // no Transfer-Encoding is sent and the request method defines a meaning\n        // for an enclosed payload body.\n\n        socket.write(`${header}content-length: 0\\r\\n\\r\\n`, 'ascii');\n      } else {\n        socket.write(`${header}\\r\\n`, 'ascii');\n      }\n    } else if (contentLength === null) {\n      socket.write('\\r\\n0\\r\\n\\r\\n', 'ascii');\n    }\n    if (contentLength !== null && bytesWritten !== contentLength) {\n      if (client[kStrictContentLength]) {\n        throw new RequestContentLengthMismatchError();\n      } else {\n        process.emitWarning(new RequestContentLengthMismatchError());\n      }\n    }\n    if (socket[kParser].timeout && socket[kParser].timeoutType === TIMEOUT_HEADERS) {\n      // istanbul ignore else: only for jest\n      if (socket[kParser].timeout.refresh) {\n        socket[kParser].timeout.refresh();\n      }\n    }\n    resume(client);\n  }\n  destroy(err) {\n    const {\n      socket,\n      client\n    } = this;\n    socket[kWriting] = false;\n    if (err) {\n      assert(client[kRunning] <= 1, 'pipeline should only contain this request');\n      util.destroy(socket, err);\n    }\n  }\n}\nfunction errorRequest(client, request, err) {\n  try {\n    request.onError(err);\n    assert(request.aborted);\n  } catch (err) {\n    client.emit('error', err);\n  }\n}\nmodule.exports = Client;","map":{"version":3,"names":["assert","require","net","util","Request","DispatcherBase","RequestContentLengthMismatchError","ResponseContentLengthMismatchError","InvalidArgumentError","RequestAbortedError","HeadersTimeoutError","HeadersOverflowError","SocketError","InformationalError","BodyTimeoutError","HTTPParserError","ResponseExceededMaxSizeError","buildConnector","kUrl","kReset","kServerName","kClient","kBusy","kParser","kConnect","kBlocking","kResuming","kRunning","kPending","kSize","kWriting","kQueue","kConnected","kConnecting","kNeedDrain","kNoRef","kKeepAliveDefaultTimeout","kHostHeader","kPendingIdx","kRunningIdx","kError","kPipelining","kSocket","kKeepAliveTimeoutValue","kMaxHeadersSize","kKeepAliveMaxTimeout","kKeepAliveTimeoutThreshold","kHeadersTimeout","kBodyTimeout","kStrictContentLength","kConnector","kMaxRedirections","kMaxRequests","kCounter","kClose","kDestroy","kDispatch","kInterceptors","kLocalAddress","kMaxResponseSize","kClosedResolve","Symbol","channels","diagnosticsChannel","sendHeaders","channel","beforeConnect","connectError","connected","hasSubscribers","Client","constructor","url","interceptors","maxHeaderSize","headersTimeout","socketTimeout","requestTimeout","connectTimeout","bodyTimeout","idleTimeout","keepAlive","keepAliveTimeout","maxKeepAliveTimeout","keepAliveMaxTimeout","keepAliveTimeoutThreshold","socketPath","pipelining","tls","strictContentLength","maxCachedSessions","maxRedirections","connect","maxRequestsPerClient","localAddress","maxResponseSize","undefined","Number","isFinite","isInteger","isIP","timeout","Array","isArray","createRedirectInterceptor","parseOrigin","hostname","port","value","resume","length","destroyed","socket","cb","once","opts","handler","origin","request","push","bodyLength","body","isIterable","process","nextTick","Promise","resolve","destroy","err","requests","splice","i","errorRequest","callback","queueMicrotask","on","constants","EMPTY_BUF","Buffer","alloc","lazyllhttp","llhttpWasmData","env","JEST_WORKER_ID","mod","WebAssembly","compile","from","e","instantiate","wasm_on_url","p","at","len","wasm_on_status","strictEqual","currentParser","ptr","start","currentBufferPtr","end","onStatus","currentBufferRef","slice","wasm_on_message_begin","onMessageBegin","wasm_on_header_field","onHeaderField","wasm_on_header_value","onHeaderValue","wasm_on_headers_complete","statusCode","upgrade","shouldKeepAlive","onHeadersComplete","Boolean","wasm_on_body","onBody","wasm_on_message_complete","onMessageComplete","llhttpInstance","llhttpPromise","catch","currentBufferSize","TIMEOUT_HEADERS","TIMEOUT_BODY","TIMEOUT_IDLE","Parser","client","exports","llhttp","llhttp_alloc","TYPE","RESPONSE","timeoutValue","timeoutType","statusText","headers","headersSize","headersMaxSize","paused","bind","bytesRead","contentLength","setTimeout","type","clearTimeout","onParserTimeout","unref","refresh","llhttp_resume","execute","read","readMore","chunk","data","free","Math","ceil","malloc","Uint8Array","memory","buffer","set","ret","llhttp_execute","offset","llhttp_get_error_pos","ERROR","PAUSED_UPGRADE","onUpgrade","PAUSED","unshift","OK","llhttp_get_error_reason","message","indexOf","toString","llhttp_free","buf","concat","trackHeader","key","toLowerCase","head","method","removeListener","onSocketError","onSocketReadable","onSocketEnd","onSocketClose","emit","getSocketInfo","parseKeepAliveTimeout","min","pause","onHeaders","onData","parseInt","onComplete","setImmediate","parser","writableNeedDrain","code","onError","host","protocol","idx","ip","substr","publish","connectParams","servername","connector","reject","error","emitDrain","sync","_resume","closed","ref","idempotent","isStream","isAsyncIterable","aborted","write","path","blocking","reset","expectsPayload","emitWarning","onConnect","completed","header","onRequestSent","isBuffer","byteLength","cork","uncork","onBodySent","isBlobLike","stream","writeIterable","writeBlob","writeStream","finished","writer","AsyncWriter","onDrain","onAbort","onFinished","off","er","size","arrayBuffer","waitForDrain","bytesWritten","module"],"sources":["J:/Coding/Projekts/Web/JavaScript/sillcode.tech/node_modules/undici/lib/client.js"],"sourcesContent":["'use strict'\n\n/* global WebAssembly */\n\nconst assert = require('assert')\nconst net = require('net')\nconst util = require('./core/util')\nconst Request = require('./core/request')\nconst DispatcherBase = require('./dispatcher-base')\nconst {\n  RequestContentLengthMismatchError,\n  ResponseContentLengthMismatchError,\n  InvalidArgumentError,\n  RequestAbortedError,\n  HeadersTimeoutError,\n  HeadersOverflowError,\n  SocketError,\n  InformationalError,\n  BodyTimeoutError,\n  HTTPParserError,\n  ResponseExceededMaxSizeError\n} = require('./core/errors')\nconst buildConnector = require('./core/connect')\nconst {\n  kUrl,\n  kReset,\n  kServerName,\n  kClient,\n  kBusy,\n  kParser,\n  kConnect,\n  kBlocking,\n  kResuming,\n  kRunning,\n  kPending,\n  kSize,\n  kWriting,\n  kQueue,\n  kConnected,\n  kConnecting,\n  kNeedDrain,\n  kNoRef,\n  kKeepAliveDefaultTimeout,\n  kHostHeader,\n  kPendingIdx,\n  kRunningIdx,\n  kError,\n  kPipelining,\n  kSocket,\n  kKeepAliveTimeoutValue,\n  kMaxHeadersSize,\n  kKeepAliveMaxTimeout,\n  kKeepAliveTimeoutThreshold,\n  kHeadersTimeout,\n  kBodyTimeout,\n  kStrictContentLength,\n  kConnector,\n  kMaxRedirections,\n  kMaxRequests,\n  kCounter,\n  kClose,\n  kDestroy,\n  kDispatch,\n  kInterceptors,\n  kLocalAddress,\n  kMaxResponseSize\n} = require('./core/symbols')\n\nconst kClosedResolve = Symbol('kClosedResolve')\n\nconst channels = {}\n\ntry {\n  const diagnosticsChannel = require('diagnostics_channel')\n  channels.sendHeaders = diagnosticsChannel.channel('undici:client:sendHeaders')\n  channels.beforeConnect = diagnosticsChannel.channel('undici:client:beforeConnect')\n  channels.connectError = diagnosticsChannel.channel('undici:client:connectError')\n  channels.connected = diagnosticsChannel.channel('undici:client:connected')\n} catch {\n  channels.sendHeaders = { hasSubscribers: false }\n  channels.beforeConnect = { hasSubscribers: false }\n  channels.connectError = { hasSubscribers: false }\n  channels.connected = { hasSubscribers: false }\n}\n\nclass Client extends DispatcherBase {\n  constructor (url, {\n    interceptors,\n    maxHeaderSize,\n    headersTimeout,\n    socketTimeout,\n    requestTimeout,\n    connectTimeout,\n    bodyTimeout,\n    idleTimeout,\n    keepAlive,\n    keepAliveTimeout,\n    maxKeepAliveTimeout,\n    keepAliveMaxTimeout,\n    keepAliveTimeoutThreshold,\n    socketPath,\n    pipelining,\n    tls,\n    strictContentLength,\n    maxCachedSessions,\n    maxRedirections,\n    connect,\n    maxRequestsPerClient,\n    localAddress,\n    maxResponseSize\n  } = {}) {\n    super()\n\n    if (keepAlive !== undefined) {\n      throw new InvalidArgumentError('unsupported keepAlive, use pipelining=0 instead')\n    }\n\n    if (socketTimeout !== undefined) {\n      throw new InvalidArgumentError('unsupported socketTimeout, use headersTimeout & bodyTimeout instead')\n    }\n\n    if (requestTimeout !== undefined) {\n      throw new InvalidArgumentError('unsupported requestTimeout, use headersTimeout & bodyTimeout instead')\n    }\n\n    if (idleTimeout !== undefined) {\n      throw new InvalidArgumentError('unsupported idleTimeout, use keepAliveTimeout instead')\n    }\n\n    if (maxKeepAliveTimeout !== undefined) {\n      throw new InvalidArgumentError('unsupported maxKeepAliveTimeout, use keepAliveMaxTimeout instead')\n    }\n\n    if (maxHeaderSize != null && !Number.isFinite(maxHeaderSize)) {\n      throw new InvalidArgumentError('invalid maxHeaderSize')\n    }\n\n    if (socketPath != null && typeof socketPath !== 'string') {\n      throw new InvalidArgumentError('invalid socketPath')\n    }\n\n    if (connectTimeout != null && (!Number.isFinite(connectTimeout) || connectTimeout < 0)) {\n      throw new InvalidArgumentError('invalid connectTimeout')\n    }\n\n    if (keepAliveTimeout != null && (!Number.isFinite(keepAliveTimeout) || keepAliveTimeout <= 0)) {\n      throw new InvalidArgumentError('invalid keepAliveTimeout')\n    }\n\n    if (keepAliveMaxTimeout != null && (!Number.isFinite(keepAliveMaxTimeout) || keepAliveMaxTimeout <= 0)) {\n      throw new InvalidArgumentError('invalid keepAliveMaxTimeout')\n    }\n\n    if (keepAliveTimeoutThreshold != null && !Number.isFinite(keepAliveTimeoutThreshold)) {\n      throw new InvalidArgumentError('invalid keepAliveTimeoutThreshold')\n    }\n\n    if (headersTimeout != null && (!Number.isInteger(headersTimeout) || headersTimeout < 0)) {\n      throw new InvalidArgumentError('headersTimeout must be a positive integer or zero')\n    }\n\n    if (bodyTimeout != null && (!Number.isInteger(bodyTimeout) || bodyTimeout < 0)) {\n      throw new InvalidArgumentError('bodyTimeout must be a positive integer or zero')\n    }\n\n    if (connect != null && typeof connect !== 'function' && typeof connect !== 'object') {\n      throw new InvalidArgumentError('connect must be a function or an object')\n    }\n\n    if (maxRedirections != null && (!Number.isInteger(maxRedirections) || maxRedirections < 0)) {\n      throw new InvalidArgumentError('maxRedirections must be a positive number')\n    }\n\n    if (maxRequestsPerClient != null && (!Number.isInteger(maxRequestsPerClient) || maxRequestsPerClient < 0)) {\n      throw new InvalidArgumentError('maxRequestsPerClient must be a positive number')\n    }\n\n    if (localAddress != null && (typeof localAddress !== 'string' || net.isIP(localAddress) === 0)) {\n      throw new InvalidArgumentError('localAddress must be valid string IP address')\n    }\n\n    if (maxResponseSize != null && (!Number.isInteger(maxResponseSize) || maxResponseSize < -1)) {\n      throw new InvalidArgumentError('maxResponseSize must be a positive number')\n    }\n\n    if (typeof connect !== 'function') {\n      connect = buildConnector({\n        ...tls,\n        maxCachedSessions,\n        socketPath,\n        timeout: connectTimeout,\n        ...connect\n      })\n    }\n\n    this[kInterceptors] = interceptors && interceptors.Client && Array.isArray(interceptors.Client)\n      ? interceptors.Client\n      : [createRedirectInterceptor({ maxRedirections })]\n    this[kUrl] = util.parseOrigin(url)\n    this[kConnector] = connect\n    this[kSocket] = null\n    this[kPipelining] = pipelining != null ? pipelining : 1\n    this[kMaxHeadersSize] = maxHeaderSize || 16384\n    this[kKeepAliveDefaultTimeout] = keepAliveTimeout == null ? 4e3 : keepAliveTimeout\n    this[kKeepAliveMaxTimeout] = keepAliveMaxTimeout == null ? 600e3 : keepAliveMaxTimeout\n    this[kKeepAliveTimeoutThreshold] = keepAliveTimeoutThreshold == null ? 1e3 : keepAliveTimeoutThreshold\n    this[kKeepAliveTimeoutValue] = this[kKeepAliveDefaultTimeout]\n    this[kServerName] = null\n    this[kLocalAddress] = localAddress != null ? localAddress : null\n    this[kResuming] = 0 // 0, idle, 1, scheduled, 2 resuming\n    this[kNeedDrain] = 0 // 0, idle, 1, scheduled, 2 resuming\n    this[kHostHeader] = `host: ${this[kUrl].hostname}${this[kUrl].port ? `:${this[kUrl].port}` : ''}\\r\\n`\n    this[kBodyTimeout] = bodyTimeout != null ? bodyTimeout : 30e3\n    this[kHeadersTimeout] = headersTimeout != null ? headersTimeout : 30e3\n    this[kStrictContentLength] = strictContentLength == null ? true : strictContentLength\n    this[kMaxRedirections] = maxRedirections\n    this[kMaxRequests] = maxRequestsPerClient\n    this[kClosedResolve] = null\n    this[kMaxResponseSize] = maxResponseSize > -1 ? maxResponseSize : -1\n\n    // kQueue is built up of 3 sections separated by\n    // the kRunningIdx and kPendingIdx indices.\n    // |   complete   |   running   |   pending   |\n    //                ^ kRunningIdx ^ kPendingIdx ^ kQueue.length\n    // kRunningIdx points to the first running element.\n    // kPendingIdx points to the first pending element.\n    // This implements a fast queue with an amortized\n    // time of O(1).\n\n    this[kQueue] = []\n    this[kRunningIdx] = 0\n    this[kPendingIdx] = 0\n  }\n\n  get pipelining () {\n    return this[kPipelining]\n  }\n\n  set pipelining (value) {\n    this[kPipelining] = value\n    resume(this, true)\n  }\n\n  get [kPending] () {\n    return this[kQueue].length - this[kPendingIdx]\n  }\n\n  get [kRunning] () {\n    return this[kPendingIdx] - this[kRunningIdx]\n  }\n\n  get [kSize] () {\n    return this[kQueue].length - this[kRunningIdx]\n  }\n\n  get [kConnected] () {\n    return !!this[kSocket] && !this[kConnecting] && !this[kSocket].destroyed\n  }\n\n  get [kBusy] () {\n    const socket = this[kSocket]\n    return (\n      (socket && (socket[kReset] || socket[kWriting] || socket[kBlocking])) ||\n      (this[kSize] >= (this[kPipelining] || 1)) ||\n      this[kPending] > 0\n    )\n  }\n\n  /* istanbul ignore: only used for test */\n  [kConnect] (cb) {\n    connect(this)\n    this.once('connect', cb)\n  }\n\n  [kDispatch] (opts, handler) {\n    const origin = opts.origin || this[kUrl].origin\n\n    const request = new Request(origin, opts, handler)\n\n    this[kQueue].push(request)\n    if (this[kResuming]) {\n      // Do nothing.\n    } else if (util.bodyLength(request.body) == null && util.isIterable(request.body)) {\n      // Wait a tick in case stream/iterator is ended in the same tick.\n      this[kResuming] = 1\n      process.nextTick(resume, this)\n    } else {\n      resume(this, true)\n    }\n\n    if (this[kResuming] && this[kNeedDrain] !== 2 && this[kBusy]) {\n      this[kNeedDrain] = 2\n    }\n\n    return this[kNeedDrain] < 2\n  }\n\n  async [kClose] () {\n    return new Promise((resolve) => {\n      if (!this[kSize]) {\n        this.destroy(resolve)\n      } else {\n        this[kClosedResolve] = resolve\n      }\n    })\n  }\n\n  async [kDestroy] (err) {\n    return new Promise((resolve) => {\n      const requests = this[kQueue].splice(this[kPendingIdx])\n      for (let i = 0; i < requests.length; i++) {\n        const request = requests[i]\n        errorRequest(this, request, err)\n      }\n\n      const callback = () => {\n        if (this[kClosedResolve]) {\n          this[kClosedResolve]()\n          this[kClosedResolve] = null\n        }\n        resolve()\n      }\n\n      if (!this[kSocket]) {\n        queueMicrotask(callback)\n      } else {\n        util.destroy(this[kSocket].on('close', callback), err)\n      }\n\n      resume(this)\n    })\n  }\n}\n\nconst constants = require('./llhttp/constants')\nconst createRedirectInterceptor = require('./interceptor/redirectInterceptor')\nconst EMPTY_BUF = Buffer.alloc(0)\n\nasync function lazyllhttp () {\n  const llhttpWasmData = process.env.JEST_WORKER_ID ? require('./llhttp/llhttp.wasm.js') : undefined\n\n  let mod\n  try {\n    mod = await WebAssembly.compile(Buffer.from(require('./llhttp/llhttp_simd.wasm.js'), 'base64'))\n  } catch (e) {\n    /* istanbul ignore next */\n\n    // We could check if the error was caused by the simd option not\n    // being enabled, but the occurring of this other error\n    // * https://github.com/emscripten-core/emscripten/issues/11495\n    // got me to remove that check to avoid breaking Node 12.\n    mod = await WebAssembly.compile(Buffer.from(llhttpWasmData || require('./llhttp/llhttp.wasm.js'), 'base64'))\n  }\n\n  return await WebAssembly.instantiate(mod, {\n    env: {\n      /* eslint-disable camelcase */\n\n      wasm_on_url: (p, at, len) => {\n        /* istanbul ignore next */\n        return 0\n      },\n      wasm_on_status: (p, at, len) => {\n        assert.strictEqual(currentParser.ptr, p)\n        const start = at - currentBufferPtr\n        const end = start + len\n        return currentParser.onStatus(currentBufferRef.slice(start, end)) || 0\n      },\n      wasm_on_message_begin: (p) => {\n        assert.strictEqual(currentParser.ptr, p)\n        return currentParser.onMessageBegin() || 0\n      },\n      wasm_on_header_field: (p, at, len) => {\n        assert.strictEqual(currentParser.ptr, p)\n        const start = at - currentBufferPtr\n        const end = start + len\n        return currentParser.onHeaderField(currentBufferRef.slice(start, end)) || 0\n      },\n      wasm_on_header_value: (p, at, len) => {\n        assert.strictEqual(currentParser.ptr, p)\n        const start = at - currentBufferPtr\n        const end = start + len\n        return currentParser.onHeaderValue(currentBufferRef.slice(start, end)) || 0\n      },\n      wasm_on_headers_complete: (p, statusCode, upgrade, shouldKeepAlive) => {\n        assert.strictEqual(currentParser.ptr, p)\n        return currentParser.onHeadersComplete(statusCode, Boolean(upgrade), Boolean(shouldKeepAlive)) || 0\n      },\n      wasm_on_body: (p, at, len) => {\n        assert.strictEqual(currentParser.ptr, p)\n        const start = at - currentBufferPtr\n        const end = start + len\n        return currentParser.onBody(currentBufferRef.slice(start, end)) || 0\n      },\n      wasm_on_message_complete: (p) => {\n        assert.strictEqual(currentParser.ptr, p)\n        return currentParser.onMessageComplete() || 0\n      }\n\n      /* eslint-enable camelcase */\n    }\n  })\n}\n\nlet llhttpInstance = null\nlet llhttpPromise = lazyllhttp()\n  .catch(() => {\n  })\n\nlet currentParser = null\nlet currentBufferRef = null\nlet currentBufferSize = 0\nlet currentBufferPtr = null\n\nconst TIMEOUT_HEADERS = 1\nconst TIMEOUT_BODY = 2\nconst TIMEOUT_IDLE = 3\n\nclass Parser {\n  constructor (client, socket, { exports }) {\n    assert(Number.isFinite(client[kMaxHeadersSize]) && client[kMaxHeadersSize] > 0)\n\n    this.llhttp = exports\n    this.ptr = this.llhttp.llhttp_alloc(constants.TYPE.RESPONSE)\n    this.client = client\n    this.socket = socket\n    this.timeout = null\n    this.timeoutValue = null\n    this.timeoutType = null\n    this.statusCode = null\n    this.statusText = ''\n    this.upgrade = false\n    this.headers = []\n    this.headersSize = 0\n    this.headersMaxSize = client[kMaxHeadersSize]\n    this.shouldKeepAlive = false\n    this.paused = false\n    this.resume = this.resume.bind(this)\n\n    this.bytesRead = 0\n\n    this.keepAlive = ''\n    this.contentLength = ''\n    this.maxResponseSize = client[kMaxResponseSize]\n  }\n\n  setTimeout (value, type) {\n    this.timeoutType = type\n    if (value !== this.timeoutValue) {\n      clearTimeout(this.timeout)\n      if (value) {\n        this.timeout = setTimeout(onParserTimeout, value, this)\n        // istanbul ignore else: only for jest\n        if (this.timeout.unref) {\n          this.timeout.unref()\n        }\n      } else {\n        this.timeout = null\n      }\n      this.timeoutValue = value\n    } else if (this.timeout) {\n      // istanbul ignore else: only for jest\n      if (this.timeout.refresh) {\n        this.timeout.refresh()\n      }\n    }\n  }\n\n  resume () {\n    if (this.socket.destroyed || !this.paused) {\n      return\n    }\n\n    assert(this.ptr != null)\n    assert(currentParser == null)\n\n    this.llhttp.llhttp_resume(this.ptr)\n\n    assert(this.timeoutType === TIMEOUT_BODY)\n    if (this.timeout) {\n      // istanbul ignore else: only for jest\n      if (this.timeout.refresh) {\n        this.timeout.refresh()\n      }\n    }\n\n    this.paused = false\n    this.execute(this.socket.read() || EMPTY_BUF) // Flush parser.\n    this.readMore()\n  }\n\n  readMore () {\n    while (!this.paused && this.ptr) {\n      const chunk = this.socket.read()\n      if (chunk === null) {\n        break\n      }\n      this.execute(chunk)\n    }\n  }\n\n  execute (data) {\n    assert(this.ptr != null)\n    assert(currentParser == null)\n    assert(!this.paused)\n\n    const { socket, llhttp } = this\n\n    if (data.length > currentBufferSize) {\n      if (currentBufferPtr) {\n        llhttp.free(currentBufferPtr)\n      }\n      currentBufferSize = Math.ceil(data.length / 4096) * 4096\n      currentBufferPtr = llhttp.malloc(currentBufferSize)\n    }\n\n    new Uint8Array(llhttp.memory.buffer, currentBufferPtr, currentBufferSize).set(data)\n\n    // Call `execute` on the wasm parser.\n    // We pass the `llhttp_parser` pointer address, the pointer address of buffer view data,\n    // and finally the length of bytes to parse.\n    // The return value is an error code or `constants.ERROR.OK`.\n    try {\n      let ret\n\n      try {\n        currentBufferRef = data\n        currentParser = this\n        ret = llhttp.llhttp_execute(this.ptr, currentBufferPtr, data.length)\n        /* eslint-disable-next-line no-useless-catch */\n      } catch (err) {\n        /* istanbul ignore next: difficult to make a test case for */\n        throw err\n      } finally {\n        currentParser = null\n        currentBufferRef = null\n      }\n\n      const offset = llhttp.llhttp_get_error_pos(this.ptr) - currentBufferPtr\n\n      if (ret === constants.ERROR.PAUSED_UPGRADE) {\n        this.onUpgrade(data.slice(offset))\n      } else if (ret === constants.ERROR.PAUSED) {\n        this.paused = true\n        socket.unshift(data.slice(offset))\n      } else if (ret !== constants.ERROR.OK) {\n        const ptr = llhttp.llhttp_get_error_reason(this.ptr)\n        let message = ''\n        /* istanbul ignore else: difficult to make a test case for */\n        if (ptr) {\n          const len = new Uint8Array(llhttp.memory.buffer, ptr).indexOf(0)\n          message = Buffer.from(llhttp.memory.buffer, ptr, len).toString()\n        }\n        throw new HTTPParserError(message, constants.ERROR[ret], data.slice(offset))\n      }\n    } catch (err) {\n      util.destroy(socket, err)\n    }\n  }\n\n  destroy () {\n    assert(this.ptr != null)\n    assert(currentParser == null)\n\n    this.llhttp.llhttp_free(this.ptr)\n    this.ptr = null\n\n    clearTimeout(this.timeout)\n    this.timeout = null\n    this.timeoutValue = null\n    this.timeoutType = null\n\n    this.paused = false\n  }\n\n  onStatus (buf) {\n    this.statusText = buf.toString()\n  }\n\n  onMessageBegin () {\n    const { socket, client } = this\n\n    /* istanbul ignore next: difficult to make a test case for */\n    if (socket.destroyed) {\n      return -1\n    }\n\n    const request = client[kQueue][client[kRunningIdx]]\n    if (!request) {\n      return -1\n    }\n  }\n\n  onHeaderField (buf) {\n    const len = this.headers.length\n\n    if ((len & 1) === 0) {\n      this.headers.push(buf)\n    } else {\n      this.headers[len - 1] = Buffer.concat([this.headers[len - 1], buf])\n    }\n\n    this.trackHeader(buf.length)\n  }\n\n  onHeaderValue (buf) {\n    let len = this.headers.length\n\n    if ((len & 1) === 1) {\n      this.headers.push(buf)\n      len += 1\n    } else {\n      this.headers[len - 1] = Buffer.concat([this.headers[len - 1], buf])\n    }\n\n    const key = this.headers[len - 2]\n    if (key.length === 10 && key.toString().toLowerCase() === 'keep-alive') {\n      this.keepAlive += buf.toString()\n    } else if (key.length === 14 && key.toString().toLowerCase() === 'content-length') {\n      this.contentLength += buf.toString()\n    }\n\n    this.trackHeader(buf.length)\n  }\n\n  trackHeader (len) {\n    this.headersSize += len\n    if (this.headersSize >= this.headersMaxSize) {\n      util.destroy(this.socket, new HeadersOverflowError())\n    }\n  }\n\n  onUpgrade (head) {\n    const { upgrade, client, socket, headers, statusCode } = this\n\n    assert(upgrade)\n\n    const request = client[kQueue][client[kRunningIdx]]\n    assert(request)\n\n    assert(!socket.destroyed)\n    assert(socket === client[kSocket])\n    assert(!this.paused)\n    assert(request.upgrade || request.method === 'CONNECT')\n\n    this.statusCode = null\n    this.statusText = ''\n    this.shouldKeepAlive = null\n\n    assert(this.headers.length % 2 === 0)\n    this.headers = []\n    this.headersSize = 0\n\n    socket.unshift(head)\n\n    socket[kParser].destroy()\n    socket[kParser] = null\n\n    socket[kClient] = null\n    socket[kError] = null\n    socket\n      .removeListener('error', onSocketError)\n      .removeListener('readable', onSocketReadable)\n      .removeListener('end', onSocketEnd)\n      .removeListener('close', onSocketClose)\n\n    client[kSocket] = null\n    client[kQueue][client[kRunningIdx]++] = null\n    client.emit('disconnect', client[kUrl], [client], new InformationalError('upgrade'))\n\n    try {\n      request.onUpgrade(statusCode, headers, socket)\n    } catch (err) {\n      util.destroy(socket, err)\n    }\n\n    resume(client)\n  }\n\n  onHeadersComplete (statusCode, upgrade, shouldKeepAlive) {\n    const { client, socket, headers, statusText } = this\n\n    /* istanbul ignore next: difficult to make a test case for */\n    if (socket.destroyed) {\n      return -1\n    }\n\n    const request = client[kQueue][client[kRunningIdx]]\n\n    /* istanbul ignore next: difficult to make a test case for */\n    if (!request) {\n      return -1\n    }\n\n    assert(!this.upgrade)\n    assert(this.statusCode < 200)\n\n    if (statusCode === 100) {\n      util.destroy(socket, new SocketError('bad response', util.getSocketInfo(socket)))\n      return -1\n    }\n\n    /* this can only happen if server is misbehaving */\n    if (upgrade && !request.upgrade) {\n      util.destroy(socket, new SocketError('bad upgrade', util.getSocketInfo(socket)))\n      return -1\n    }\n\n    assert.strictEqual(this.timeoutType, TIMEOUT_HEADERS)\n\n    this.statusCode = statusCode\n    this.shouldKeepAlive = shouldKeepAlive\n\n    if (this.statusCode >= 200) {\n      const bodyTimeout = request.bodyTimeout != null\n        ? request.bodyTimeout\n        : client[kBodyTimeout]\n      this.setTimeout(bodyTimeout, TIMEOUT_BODY)\n    } else if (this.timeout) {\n      // istanbul ignore else: only for jest\n      if (this.timeout.refresh) {\n        this.timeout.refresh()\n      }\n    }\n\n    if (request.method === 'CONNECT') {\n      assert(client[kRunning] === 1)\n      this.upgrade = true\n      return 2\n    }\n\n    if (upgrade) {\n      assert(client[kRunning] === 1)\n      this.upgrade = true\n      return 2\n    }\n\n    assert(this.headers.length % 2 === 0)\n    this.headers = []\n    this.headersSize = 0\n\n    if (shouldKeepAlive && client[kPipelining]) {\n      const keepAliveTimeout = this.keepAlive ? util.parseKeepAliveTimeout(this.keepAlive) : null\n\n      if (keepAliveTimeout != null) {\n        const timeout = Math.min(\n          keepAliveTimeout - client[kKeepAliveTimeoutThreshold],\n          client[kKeepAliveMaxTimeout]\n        )\n        if (timeout <= 0) {\n          socket[kReset] = true\n        } else {\n          client[kKeepAliveTimeoutValue] = timeout\n        }\n      } else {\n        client[kKeepAliveTimeoutValue] = client[kKeepAliveDefaultTimeout]\n      }\n    } else {\n      // Stop more requests from being dispatched.\n      socket[kReset] = true\n    }\n\n    let pause\n    try {\n      pause = request.onHeaders(statusCode, headers, this.resume, statusText) === false\n    } catch (err) {\n      util.destroy(socket, err)\n      return -1\n    }\n\n    if (request.method === 'HEAD') {\n      assert(socket[kReset])\n      return 1\n    }\n\n    if (statusCode < 200) {\n      return 1\n    }\n\n    if (socket[kBlocking]) {\n      socket[kBlocking] = false\n      resume(client)\n    }\n\n    return pause ? constants.ERROR.PAUSED : 0\n  }\n\n  onBody (buf) {\n    const { client, socket, statusCode, maxResponseSize } = this\n\n    if (socket.destroyed) {\n      return -1\n    }\n\n    const request = client[kQueue][client[kRunningIdx]]\n    assert(request)\n\n    assert.strictEqual(this.timeoutType, TIMEOUT_BODY)\n    if (this.timeout) {\n      // istanbul ignore else: only for jest\n      if (this.timeout.refresh) {\n        this.timeout.refresh()\n      }\n    }\n\n    assert(statusCode >= 200)\n\n    if (maxResponseSize > -1 && this.bytesRead + buf.length > maxResponseSize) {\n      util.destroy(socket, new ResponseExceededMaxSizeError())\n      return -1\n    }\n\n    this.bytesRead += buf.length\n\n    try {\n      if (request.onData(buf) === false) {\n        return constants.ERROR.PAUSED\n      }\n    } catch (err) {\n      util.destroy(socket, err)\n      return -1\n    }\n  }\n\n  onMessageComplete () {\n    const { client, socket, statusCode, upgrade, headers, contentLength, bytesRead, shouldKeepAlive } = this\n\n    if (socket.destroyed && (!statusCode || shouldKeepAlive)) {\n      return -1\n    }\n\n    if (upgrade) {\n      return\n    }\n\n    const request = client[kQueue][client[kRunningIdx]]\n    assert(request)\n\n    assert(statusCode >= 100)\n\n    this.statusCode = null\n    this.statusText = ''\n    this.bytesRead = 0\n    this.contentLength = ''\n    this.keepAlive = ''\n\n    assert(this.headers.length % 2 === 0)\n    this.headers = []\n    this.headersSize = 0\n\n    if (statusCode < 200) {\n      return\n    }\n\n    /* istanbul ignore next: should be handled by llhttp? */\n    if (request.method !== 'HEAD' && contentLength && bytesRead !== parseInt(contentLength, 10)) {\n      util.destroy(socket, new ResponseContentLengthMismatchError())\n      return -1\n    }\n\n    try {\n      request.onComplete(headers)\n    } catch (err) {\n      errorRequest(client, request, err)\n    }\n\n    client[kQueue][client[kRunningIdx]++] = null\n\n    if (socket[kWriting]) {\n      assert.strictEqual(client[kRunning], 0)\n      // Response completed before request.\n      util.destroy(socket, new InformationalError('reset'))\n      return constants.ERROR.PAUSED\n    } else if (!shouldKeepAlive) {\n      util.destroy(socket, new InformationalError('reset'))\n      return constants.ERROR.PAUSED\n    } else if (socket[kReset] && client[kRunning] === 0) {\n      // Destroy socket once all requests have completed.\n      // The request at the tail of the pipeline is the one\n      // that requested reset and no further requests should\n      // have been queued since then.\n      util.destroy(socket, new InformationalError('reset'))\n      return constants.ERROR.PAUSED\n    } else if (client[kPipelining] === 1) {\n      // We must wait a full event loop cycle to reuse this socket to make sure\n      // that non-spec compliant servers are not closing the connection even if they\n      // said they won't.\n      setImmediate(resume, client)\n    } else {\n      resume(client)\n    }\n  }\n}\n\nfunction onParserTimeout (parser) {\n  const { socket, timeoutType, client } = parser\n\n  /* istanbul ignore else */\n  if (timeoutType === TIMEOUT_HEADERS) {\n    if (!socket[kWriting] || socket.writableNeedDrain || client[kRunning] > 1) {\n      assert(!parser.paused, 'cannot be paused while waiting for headers')\n      util.destroy(socket, new HeadersTimeoutError())\n    }\n  } else if (timeoutType === TIMEOUT_BODY) {\n    if (!parser.paused) {\n      util.destroy(socket, new BodyTimeoutError())\n    }\n  } else if (timeoutType === TIMEOUT_IDLE) {\n    assert(client[kRunning] === 0 && client[kKeepAliveTimeoutValue])\n    util.destroy(socket, new InformationalError('socket idle timeout'))\n  }\n}\n\nfunction onSocketReadable () {\n  const { [kParser]: parser } = this\n  parser.readMore()\n}\n\nfunction onSocketError (err) {\n  const { [kParser]: parser } = this\n\n  assert(err.code !== 'ERR_TLS_CERT_ALTNAME_INVALID')\n\n  // On Mac OS, we get an ECONNRESET even if there is a full body to be forwarded\n  // to the user.\n  if (err.code === 'ECONNRESET' && parser.statusCode && !parser.shouldKeepAlive) {\n    // We treat all incoming data so for as a valid response.\n    parser.onMessageComplete()\n    return\n  }\n\n  this[kError] = err\n\n  onError(this[kClient], err)\n}\n\nfunction onError (client, err) {\n  if (\n    client[kRunning] === 0 &&\n    err.code !== 'UND_ERR_INFO' &&\n    err.code !== 'UND_ERR_SOCKET'\n  ) {\n    // Error is not caused by running request and not a recoverable\n    // socket error.\n\n    assert(client[kPendingIdx] === client[kRunningIdx])\n\n    const requests = client[kQueue].splice(client[kRunningIdx])\n    for (let i = 0; i < requests.length; i++) {\n      const request = requests[i]\n      errorRequest(client, request, err)\n    }\n    assert(client[kSize] === 0)\n  }\n}\n\nfunction onSocketEnd () {\n  const { [kParser]: parser } = this\n\n  if (parser.statusCode && !parser.shouldKeepAlive) {\n    // We treat all incoming data so far as a valid response.\n    parser.onMessageComplete()\n    return\n  }\n\n  util.destroy(this, new SocketError('other side closed', util.getSocketInfo(this)))\n}\n\nfunction onSocketClose () {\n  const { [kClient]: client } = this\n\n  if (!this[kError] && this[kParser].statusCode && !this[kParser].shouldKeepAlive) {\n    // We treat all incoming data so far as a valid response.\n    this[kParser].onMessageComplete()\n  }\n\n  this[kParser].destroy()\n  this[kParser] = null\n\n  const err = this[kError] || new SocketError('closed', util.getSocketInfo(this))\n\n  client[kSocket] = null\n\n  if (client.destroyed) {\n    assert(client[kPending] === 0)\n\n    // Fail entire queue.\n    const requests = client[kQueue].splice(client[kRunningIdx])\n    for (let i = 0; i < requests.length; i++) {\n      const request = requests[i]\n      errorRequest(client, request, err)\n    }\n  } else if (client[kRunning] > 0 && err.code !== 'UND_ERR_INFO') {\n    // Fail head of pipeline.\n    const request = client[kQueue][client[kRunningIdx]]\n    client[kQueue][client[kRunningIdx]++] = null\n\n    errorRequest(client, request, err)\n  }\n\n  client[kPendingIdx] = client[kRunningIdx]\n\n  assert(client[kRunning] === 0)\n\n  client.emit('disconnect', client[kUrl], [client], err)\n\n  resume(client)\n}\n\nasync function connect (client) {\n  assert(!client[kConnecting])\n  assert(!client[kSocket])\n\n  let { host, hostname, protocol, port } = client[kUrl]\n\n  // Resolve ipv6\n  if (hostname[0] === '[') {\n    const idx = hostname.indexOf(']')\n\n    assert(idx !== -1)\n    const ip = hostname.substr(1, idx - 1)\n\n    assert(net.isIP(ip))\n    hostname = ip\n  }\n\n  client[kConnecting] = true\n\n  if (channels.beforeConnect.hasSubscribers) {\n    channels.beforeConnect.publish({\n      connectParams: {\n        host,\n        hostname,\n        protocol,\n        port,\n        servername: client[kServerName],\n        localAddress: client[kLocalAddress]\n      },\n      connector: client[kConnector]\n    })\n  }\n\n  try {\n    const socket = await new Promise((resolve, reject) => {\n      client[kConnector]({\n        host,\n        hostname,\n        protocol,\n        port,\n        servername: client[kServerName],\n        localAddress: client[kLocalAddress]\n      }, (err, socket) => {\n        if (err) {\n          reject(err)\n        } else {\n          resolve(socket)\n        }\n      })\n    })\n\n    if (!llhttpInstance) {\n      llhttpInstance = await llhttpPromise\n      llhttpPromise = null\n    }\n\n    client[kConnecting] = false\n\n    assert(socket)\n\n    client[kSocket] = socket\n\n    socket[kNoRef] = false\n    socket[kWriting] = false\n    socket[kReset] = false\n    socket[kBlocking] = false\n    socket[kError] = null\n    socket[kParser] = new Parser(client, socket, llhttpInstance)\n    socket[kClient] = client\n    socket[kCounter] = 0\n    socket[kMaxRequests] = client[kMaxRequests]\n    socket\n      .on('error', onSocketError)\n      .on('readable', onSocketReadable)\n      .on('end', onSocketEnd)\n      .on('close', onSocketClose)\n\n    if (channels.connected.hasSubscribers) {\n      channels.connected.publish({\n        connectParams: {\n          host,\n          hostname,\n          protocol,\n          port,\n          servername: client[kServerName],\n          localAddress: client[kLocalAddress]\n        },\n        connector: client[kConnector],\n        socket\n      })\n    }\n    client.emit('connect', client[kUrl], [client])\n  } catch (err) {\n    client[kConnecting] = false\n\n    if (channels.connectError.hasSubscribers) {\n      channels.connectError.publish({\n        connectParams: {\n          host,\n          hostname,\n          protocol,\n          port,\n          servername: client[kServerName],\n          localAddress: client[kLocalAddress]\n        },\n        connector: client[kConnector],\n        error: err\n      })\n    }\n\n    if (err.code === 'ERR_TLS_CERT_ALTNAME_INVALID') {\n      assert(client[kRunning] === 0)\n      while (client[kPending] > 0 && client[kQueue][client[kPendingIdx]].servername === client[kServerName]) {\n        const request = client[kQueue][client[kPendingIdx]++]\n        errorRequest(client, request, err)\n      }\n    } else {\n      onError(client, err)\n    }\n\n    client.emit('connectionError', client[kUrl], [client], err)\n  }\n\n  resume(client)\n}\n\nfunction emitDrain (client) {\n  client[kNeedDrain] = 0\n  client.emit('drain', client[kUrl], [client])\n}\n\nfunction resume (client, sync) {\n  if (client[kResuming] === 2) {\n    return\n  }\n\n  client[kResuming] = 2\n\n  _resume(client, sync)\n  client[kResuming] = 0\n\n  if (client[kRunningIdx] > 256) {\n    client[kQueue].splice(0, client[kRunningIdx])\n    client[kPendingIdx] -= client[kRunningIdx]\n    client[kRunningIdx] = 0\n  }\n}\n\nfunction _resume (client, sync) {\n  while (true) {\n    if (client.destroyed) {\n      assert(client[kPending] === 0)\n      return\n    }\n\n    if (client.closed && !client[kSize]) {\n      client.destroy()\n      return\n    }\n\n    const socket = client[kSocket]\n\n    if (socket) {\n      if (client[kSize] === 0) {\n        if (!socket[kNoRef] && socket.unref) {\n          socket.unref()\n          socket[kNoRef] = true\n        }\n      } else if (socket[kNoRef] && socket.ref) {\n        socket.ref()\n        socket[kNoRef] = false\n      }\n\n      if (client[kSize] === 0) {\n        if (socket[kParser].timeoutType !== TIMEOUT_IDLE) {\n          socket[kParser].setTimeout(client[kKeepAliveTimeoutValue], TIMEOUT_IDLE)\n        }\n      } else if (client[kRunning] > 0 && socket[kParser].statusCode < 200) {\n        if (socket[kParser].timeoutType !== TIMEOUT_HEADERS) {\n          const request = client[kQueue][client[kRunningIdx]]\n          const headersTimeout = request.headersTimeout != null\n            ? request.headersTimeout\n            : client[kHeadersTimeout]\n          socket[kParser].setTimeout(headersTimeout, TIMEOUT_HEADERS)\n        }\n      }\n    }\n\n    if (client[kBusy]) {\n      client[kNeedDrain] = 2\n    } else if (client[kNeedDrain] === 2) {\n      if (sync) {\n        client[kNeedDrain] = 1\n        process.nextTick(emitDrain, client)\n      } else {\n        emitDrain(client)\n      }\n      continue\n    }\n\n    if (client[kPending] === 0) {\n      return\n    }\n\n    if (client[kRunning] >= (client[kPipelining] || 1)) {\n      return\n    }\n\n    const request = client[kQueue][client[kPendingIdx]]\n\n    if (client[kUrl].protocol === 'https:' && client[kServerName] !== request.servername) {\n      if (client[kRunning] > 0) {\n        return\n      }\n\n      client[kServerName] = request.servername\n\n      if (socket && socket.servername !== request.servername) {\n        util.destroy(socket, new InformationalError('servername changed'))\n        return\n      }\n    }\n\n    if (client[kConnecting]) {\n      return\n    }\n\n    if (!socket) {\n      connect(client)\n      continue\n    }\n\n    if (socket.destroyed || socket[kWriting] || socket[kReset] || socket[kBlocking]) {\n      return\n    }\n\n    if (client[kRunning] > 0 && !request.idempotent) {\n      // Non-idempotent request cannot be retried.\n      // Ensure that no other requests are inflight and\n      // could cause failure.\n      return\n    }\n\n    if (client[kRunning] > 0 && (request.upgrade || request.method === 'CONNECT')) {\n      // Don't dispatch an upgrade until all preceding requests have completed.\n      // A misbehaving server might upgrade the connection before all pipelined\n      // request has completed.\n      return\n    }\n\n    if (util.isStream(request.body) && util.bodyLength(request.body) === 0) {\n      request.body\n        .on('data', /* istanbul ignore next */ function () {\n          /* istanbul ignore next */\n          assert(false)\n        })\n        .on('error', function (err) {\n          errorRequest(client, request, err)\n        })\n        .on('end', function () {\n          util.destroy(this)\n        })\n\n      request.body = null\n    }\n\n    if (client[kRunning] > 0 &&\n      (util.isStream(request.body) || util.isAsyncIterable(request.body))) {\n      // Request with stream or iterator body can error while other requests\n      // are inflight and indirectly error those as well.\n      // Ensure this doesn't happen by waiting for inflight\n      // to complete before dispatching.\n\n      // Request with stream or iterator body cannot be retried.\n      // Ensure that no other requests are inflight and\n      // could cause failure.\n      return\n    }\n\n    if (!request.aborted && write(client, request)) {\n      client[kPendingIdx]++\n    } else {\n      client[kQueue].splice(client[kPendingIdx], 1)\n    }\n  }\n}\n\nfunction write (client, request) {\n  const { body, method, path, host, upgrade, headers, blocking, reset } = request\n\n  // https://tools.ietf.org/html/rfc7231#section-4.3.1\n  // https://tools.ietf.org/html/rfc7231#section-4.3.2\n  // https://tools.ietf.org/html/rfc7231#section-4.3.5\n\n  // Sending a payload body on a request that does not\n  // expect it can cause undefined behavior on some\n  // servers and corrupt connection state. Do not\n  // re-use the connection for further requests.\n\n  const expectsPayload = (\n    method === 'PUT' ||\n    method === 'POST' ||\n    method === 'PATCH'\n  )\n\n  if (body && typeof body.read === 'function') {\n    // Try to read EOF in order to get length.\n    body.read(0)\n  }\n\n  let contentLength = util.bodyLength(body)\n\n  if (contentLength === null) {\n    contentLength = request.contentLength\n  }\n\n  if (contentLength === 0 && !expectsPayload) {\n    // https://tools.ietf.org/html/rfc7230#section-3.3.2\n    // A user agent SHOULD NOT send a Content-Length header field when\n    // the request message does not contain a payload body and the method\n    // semantics do not anticipate such a body.\n\n    contentLength = null\n  }\n\n  if (request.contentLength !== null && request.contentLength !== contentLength) {\n    if (client[kStrictContentLength]) {\n      errorRequest(client, request, new RequestContentLengthMismatchError())\n      return false\n    }\n\n    process.emitWarning(new RequestContentLengthMismatchError())\n  }\n\n  const socket = client[kSocket]\n\n  try {\n    request.onConnect((err) => {\n      if (request.aborted || request.completed) {\n        return\n      }\n\n      errorRequest(client, request, err || new RequestAbortedError())\n\n      util.destroy(socket, new InformationalError('aborted'))\n    })\n  } catch (err) {\n    errorRequest(client, request, err)\n  }\n\n  if (request.aborted) {\n    return false\n  }\n\n  if (method === 'HEAD') {\n    // https://github.com/mcollina/undici/issues/258\n    // Close after a HEAD request to interop with misbehaving servers\n    // that may send a body in the response.\n\n    socket[kReset] = true\n  }\n\n  if (upgrade || method === 'CONNECT') {\n    // On CONNECT or upgrade, block pipeline from dispatching further\n    // requests on this connection.\n\n    socket[kReset] = true\n  }\n\n  if (reset) {\n    socket[kReset] = true\n  }\n\n  if (client[kMaxRequests] && socket[kCounter]++ >= client[kMaxRequests]) {\n    socket[kReset] = true\n  }\n\n  if (blocking) {\n    socket[kBlocking] = true\n  }\n\n  let header = `${method} ${path} HTTP/1.1\\r\\n`\n\n  if (typeof host === 'string') {\n    header += `host: ${host}\\r\\n`\n  } else {\n    header += client[kHostHeader]\n  }\n\n  if (upgrade) {\n    header += `connection: upgrade\\r\\nupgrade: ${upgrade}\\r\\n`\n  } else if (client[kPipelining] && !socket[kReset]) {\n    header += 'connection: keep-alive\\r\\n'\n  } else {\n    header += 'connection: close\\r\\n'\n  }\n\n  if (headers) {\n    header += headers\n  }\n\n  if (channels.sendHeaders.hasSubscribers) {\n    channels.sendHeaders.publish({ request, headers: header, socket })\n  }\n\n  /* istanbul ignore else: assertion */\n  if (!body) {\n    if (contentLength === 0) {\n      socket.write(`${header}content-length: 0\\r\\n\\r\\n`, 'ascii')\n    } else {\n      assert(contentLength === null, 'no body must not have content length')\n      socket.write(`${header}\\r\\n`, 'ascii')\n    }\n    request.onRequestSent()\n  } else if (util.isBuffer(body)) {\n    assert(contentLength === body.byteLength, 'buffer body must have content length')\n\n    socket.cork()\n    socket.write(`${header}content-length: ${contentLength}\\r\\n\\r\\n`, 'ascii')\n    socket.write(body)\n    socket.uncork()\n    request.onBodySent(body)\n    request.onRequestSent()\n    if (!expectsPayload) {\n      socket[kReset] = true\n    }\n  } else if (util.isBlobLike(body)) {\n    if (typeof body.stream === 'function') {\n      writeIterable({ body: body.stream(), client, request, socket, contentLength, header, expectsPayload })\n    } else {\n      writeBlob({ body, client, request, socket, contentLength, header, expectsPayload })\n    }\n  } else if (util.isStream(body)) {\n    writeStream({ body, client, request, socket, contentLength, header, expectsPayload })\n  } else if (util.isIterable(body)) {\n    writeIterable({ body, client, request, socket, contentLength, header, expectsPayload })\n  } else {\n    assert(false)\n  }\n\n  return true\n}\n\nfunction writeStream ({ body, client, request, socket, contentLength, header, expectsPayload }) {\n  assert(contentLength !== 0 || client[kRunning] === 0, 'stream body cannot be pipelined')\n\n  let finished = false\n\n  const writer = new AsyncWriter({ socket, request, contentLength, client, expectsPayload, header })\n\n  const onData = function (chunk) {\n    try {\n      assert(!finished)\n\n      if (!writer.write(chunk) && this.pause) {\n        this.pause()\n      }\n    } catch (err) {\n      util.destroy(this, err)\n    }\n  }\n  const onDrain = function () {\n    assert(!finished)\n\n    if (body.resume) {\n      body.resume()\n    }\n  }\n  const onAbort = function () {\n    onFinished(new RequestAbortedError())\n  }\n  const onFinished = function (err) {\n    if (finished) {\n      return\n    }\n\n    finished = true\n\n    assert(socket.destroyed || (socket[kWriting] && client[kRunning] <= 1))\n\n    socket\n      .off('drain', onDrain)\n      .off('error', onFinished)\n\n    body\n      .removeListener('data', onData)\n      .removeListener('end', onFinished)\n      .removeListener('error', onFinished)\n      .removeListener('close', onAbort)\n\n    if (!err) {\n      try {\n        writer.end()\n      } catch (er) {\n        err = er\n      }\n    }\n\n    writer.destroy(err)\n\n    if (err && (err.code !== 'UND_ERR_INFO' || err.message !== 'reset')) {\n      util.destroy(body, err)\n    } else {\n      util.destroy(body)\n    }\n  }\n\n  body\n    .on('data', onData)\n    .on('end', onFinished)\n    .on('error', onFinished)\n    .on('close', onAbort)\n\n  if (body.resume) {\n    body.resume()\n  }\n\n  socket\n    .on('drain', onDrain)\n    .on('error', onFinished)\n}\n\nasync function writeBlob ({ body, client, request, socket, contentLength, header, expectsPayload }) {\n  assert(contentLength === body.size, 'blob body must have content length')\n\n  try {\n    if (contentLength != null && contentLength !== body.size) {\n      throw new RequestContentLengthMismatchError()\n    }\n\n    const buffer = Buffer.from(await body.arrayBuffer())\n\n    socket.cork()\n    socket.write(`${header}content-length: ${contentLength}\\r\\n\\r\\n`, 'ascii')\n    socket.write(buffer)\n    socket.uncork()\n\n    request.onBodySent(buffer)\n    request.onRequestSent()\n\n    if (!expectsPayload) {\n      socket[kReset] = true\n    }\n\n    resume(client)\n  } catch (err) {\n    util.destroy(socket, err)\n  }\n}\n\nasync function writeIterable ({ body, client, request, socket, contentLength, header, expectsPayload }) {\n  assert(contentLength !== 0 || client[kRunning] === 0, 'iterator body cannot be pipelined')\n\n  let callback = null\n  function onDrain () {\n    if (callback) {\n      const cb = callback\n      callback = null\n      cb()\n    }\n  }\n\n  const waitForDrain = () => new Promise((resolve, reject) => {\n    assert(callback === null)\n\n    if (socket[kError]) {\n      reject(socket[kError])\n    } else {\n      callback = resolve\n    }\n  })\n\n  socket\n    .on('close', onDrain)\n    .on('drain', onDrain)\n\n  const writer = new AsyncWriter({ socket, request, contentLength, client, expectsPayload, header })\n  try {\n    // It's up to the user to somehow abort the async iterable.\n    for await (const chunk of body) {\n      if (socket[kError]) {\n        throw socket[kError]\n      }\n\n      if (!writer.write(chunk)) {\n        await waitForDrain()\n      }\n    }\n\n    writer.end()\n  } catch (err) {\n    writer.destroy(err)\n  } finally {\n    socket\n      .off('close', onDrain)\n      .off('drain', onDrain)\n  }\n}\n\nclass AsyncWriter {\n  constructor ({ socket, request, contentLength, client, expectsPayload, header }) {\n    this.socket = socket\n    this.request = request\n    this.contentLength = contentLength\n    this.client = client\n    this.bytesWritten = 0\n    this.expectsPayload = expectsPayload\n    this.header = header\n\n    socket[kWriting] = true\n  }\n\n  write (chunk) {\n    const { socket, request, contentLength, client, bytesWritten, expectsPayload, header } = this\n\n    if (socket[kError]) {\n      throw socket[kError]\n    }\n\n    if (socket.destroyed) {\n      return false\n    }\n\n    const len = Buffer.byteLength(chunk)\n    if (!len) {\n      return true\n    }\n\n    // We should defer writing chunks.\n    if (contentLength !== null && bytesWritten + len > contentLength) {\n      if (client[kStrictContentLength]) {\n        throw new RequestContentLengthMismatchError()\n      }\n\n      process.emitWarning(new RequestContentLengthMismatchError())\n    }\n\n    if (bytesWritten === 0) {\n      if (!expectsPayload) {\n        socket[kReset] = true\n      }\n\n      if (contentLength === null) {\n        socket.write(`${header}transfer-encoding: chunked\\r\\n`, 'ascii')\n      } else {\n        socket.write(`${header}content-length: ${contentLength}\\r\\n\\r\\n`, 'ascii')\n      }\n    }\n\n    if (contentLength === null) {\n      socket.write(`\\r\\n${len.toString(16)}\\r\\n`, 'ascii')\n    }\n\n    this.bytesWritten += len\n\n    const ret = socket.write(chunk)\n\n    request.onBodySent(chunk)\n\n    if (!ret) {\n      if (socket[kParser].timeout && socket[kParser].timeoutType === TIMEOUT_HEADERS) {\n        // istanbul ignore else: only for jest\n        if (socket[kParser].timeout.refresh) {\n          socket[kParser].timeout.refresh()\n        }\n      }\n    }\n\n    return ret\n  }\n\n  end () {\n    const { socket, contentLength, client, bytesWritten, expectsPayload, header, request } = this\n    request.onRequestSent()\n\n    socket[kWriting] = false\n\n    if (socket[kError]) {\n      throw socket[kError]\n    }\n\n    if (socket.destroyed) {\n      return\n    }\n\n    if (bytesWritten === 0) {\n      if (expectsPayload) {\n        // https://tools.ietf.org/html/rfc7230#section-3.3.2\n        // A user agent SHOULD send a Content-Length in a request message when\n        // no Transfer-Encoding is sent and the request method defines a meaning\n        // for an enclosed payload body.\n\n        socket.write(`${header}content-length: 0\\r\\n\\r\\n`, 'ascii')\n      } else {\n        socket.write(`${header}\\r\\n`, 'ascii')\n      }\n    } else if (contentLength === null) {\n      socket.write('\\r\\n0\\r\\n\\r\\n', 'ascii')\n    }\n\n    if (contentLength !== null && bytesWritten !== contentLength) {\n      if (client[kStrictContentLength]) {\n        throw new RequestContentLengthMismatchError()\n      } else {\n        process.emitWarning(new RequestContentLengthMismatchError())\n      }\n    }\n\n    if (socket[kParser].timeout && socket[kParser].timeoutType === TIMEOUT_HEADERS) {\n      // istanbul ignore else: only for jest\n      if (socket[kParser].timeout.refresh) {\n        socket[kParser].timeout.refresh()\n      }\n    }\n\n    resume(client)\n  }\n\n  destroy (err) {\n    const { socket, client } = this\n\n    socket[kWriting] = false\n\n    if (err) {\n      assert(client[kRunning] <= 1, 'pipeline should only contain this request')\n      util.destroy(socket, err)\n    }\n  }\n}\n\nfunction errorRequest (client, request, err) {\n  try {\n    request.onError(err)\n    assert(request.aborted)\n  } catch (err) {\n    client.emit('error', err)\n  }\n}\n\nmodule.exports = Client\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}