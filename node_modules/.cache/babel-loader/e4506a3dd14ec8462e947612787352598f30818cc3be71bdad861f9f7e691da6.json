{"ast":null,"code":"'use strict';\n\nconst {\n  setInterval,\n  clearInterval\n} = require('node:timers');\nconst {\n  ThreadChannelTypes,\n  SweeperKeys\n} = require('./Constants');\nconst Events = require('./Events');\nconst {\n  DiscordjsTypeError,\n  ErrorCodes\n} = require('../errors');\n\n/**\n * @typedef {Function} GlobalSweepFilter\n * @returns {Function|null} Return `null` to skip sweeping, otherwise a function passed to `sweep()`,\n * See {@link [Collection#sweep](https://discord.js.org/#/docs/collection/main/class/Collection?scrollTo=sweep)}\n * for the definition of this function.\n */\n\n/**\n * A container for all cache sweeping intervals and their associated sweep methods.\n */\nclass Sweepers {\n  constructor(client, options) {\n    /**\n     * The client that instantiated this\n     * @type {Client}\n     * @readonly\n     */\n    Object.defineProperty(this, 'client', {\n      value: client\n    });\n\n    /**\n     * The options the sweepers were instantiated with\n     * @type {SweeperOptions}\n     */\n    this.options = options;\n\n    /**\n     * A record of interval timeout that is used to sweep the indicated items, or null if not being swept\n     * @type {Object<SweeperKey, ?Timeout>}\n     */\n    this.intervals = Object.fromEntries(SweeperKeys.map(key => [key, null]));\n    for (const key of SweeperKeys) {\n      if (!(key in options)) continue;\n      this._validateProperties(key);\n      const clonedOptions = {\n        ...this.options[key]\n      };\n\n      // Handle cases that have a \"lifetime\"\n      if (!('filter' in clonedOptions)) {\n        switch (key) {\n          case 'invites':\n            clonedOptions.filter = this.constructor.expiredInviteSweepFilter(clonedOptions.lifetime);\n            break;\n          case 'messages':\n            clonedOptions.filter = this.constructor.outdatedMessageSweepFilter(clonedOptions.lifetime);\n            break;\n          case 'threads':\n            clonedOptions.filter = this.constructor.archivedThreadSweepFilter(clonedOptions.lifetime);\n        }\n      }\n      this._initInterval(key, `sweep${key[0].toUpperCase()}${key.slice(1)}`, clonedOptions);\n    }\n  }\n\n  /**\n   * Sweeps all guild and global application commands and removes the ones which are indicated by the filter.\n   * @param {Function} filter The function used to determine which commands will be removed from the caches.\n   * @returns {number} Amount of commands that were removed from the caches\n   */\n  sweepApplicationCommands(filter) {\n    const {\n      guilds,\n      items: guildCommands\n    } = this._sweepGuildDirectProp('commands', filter, {\n      emit: false\n    });\n    const globalCommands = this.client.application?.commands.cache.sweep(filter) ?? 0;\n    this.client.emit(Events.CacheSweep, `Swept ${globalCommands} global application commands and ${guildCommands} guild commands in ${guilds} guilds.`);\n    return guildCommands + globalCommands;\n  }\n\n  /**\n   * Sweeps all auto moderation rules and removes the ones which are indicated by the filter.\n   * @param {Function} filter The function used to determine\n   * which auto moderation rules will be removed from the caches\n   * @returns {number} Amount of auto moderation rules that were removed from the caches\n   */\n  sweepAutoModerationRules(filter) {\n    return this._sweepGuildDirectProp('autoModerationRules', filter).items;\n  }\n\n  /**\n   * Sweeps all guild bans and removes the ones which are indicated by the filter.\n   * @param {Function} filter The function used to determine which bans will be removed from the caches.\n   * @returns {number} Amount of bans that were removed from the caches\n   */\n  sweepBans(filter) {\n    return this._sweepGuildDirectProp('bans', filter).items;\n  }\n\n  /**\n   * Sweeps all guild emojis and removes the ones which are indicated by the filter.\n   * @param {Function} filter The function used to determine which emojis will be removed from the caches.\n   * @returns {number} Amount of emojis that were removed from the caches\n   */\n  sweepEmojis(filter) {\n    return this._sweepGuildDirectProp('emojis', filter).items;\n  }\n\n  /**\n   * Sweeps all guild invites and removes the ones which are indicated by the filter.\n   * @param {Function} filter The function used to determine which invites will be removed from the caches.\n   * @returns {number} Amount of invites that were removed from the caches\n   */\n  sweepInvites(filter) {\n    return this._sweepGuildDirectProp('invites', filter).items;\n  }\n\n  /**\n   * Sweeps all guild members and removes the ones which are indicated by the filter.\n   * <info>It is highly recommended to keep the client guild member cached</info>\n   * @param {Function} filter The function used to determine which guild members will be removed from the caches.\n   * @returns {number} Amount of guild members that were removed from the caches\n   */\n  sweepGuildMembers(filter) {\n    return this._sweepGuildDirectProp('members', filter, {\n      outputName: 'guild members'\n    }).items;\n  }\n\n  /**\n   * Sweeps all text-based channels' messages and removes the ones which are indicated by the filter.\n   * @param {Function} filter The function used to determine which messages will be removed from the caches.\n   * @returns {number} Amount of messages that were removed from the caches\n   * @example\n   * // Remove all messages older than 1800 seconds from the messages cache\n   * const amount = sweepers.sweepMessages(\n   *   Sweepers.filterByLifetime({\n   *     lifetime: 1800,\n   *     getComparisonTimestamp: m => m.editedTimestamp ?? m.createdTimestamp,\n   *   })(),\n   * );\n   * console.log(`Successfully removed ${amount} messages from the cache.`);\n   */\n  sweepMessages(filter) {\n    if (typeof filter !== 'function') {\n      throw new DiscordjsTypeError(ErrorCodes.InvalidType, 'filter', 'function');\n    }\n    let channels = 0;\n    let messages = 0;\n    for (const channel of this.client.channels.cache.values()) {\n      if (!channel.isTextBased()) continue;\n      channels++;\n      messages += channel.messages.cache.sweep(filter);\n    }\n    this.client.emit(Events.CacheSweep, `Swept ${messages} messages in ${channels} text-based channels.`);\n    return messages;\n  }\n\n  /**\n   * Sweeps all presences and removes the ones which are indicated by the filter.\n   * @param {Function} filter The function used to determine which presences will be removed from the caches.\n   * @returns {number} Amount of presences that were removed from the caches\n   */\n  sweepPresences(filter) {\n    return this._sweepGuildDirectProp('presences', filter).items;\n  }\n\n  /**\n   * Sweeps all message reactions and removes the ones which are indicated by the filter.\n   * @param {Function} filter The function used to determine which reactions will be removed from the caches.\n   * @returns {number} Amount of reactions that were removed from the caches\n   */\n  sweepReactions(filter) {\n    if (typeof filter !== 'function') {\n      throw new DiscordjsTypeError(ErrorCodes.InvalidType, 'filter', 'function');\n    }\n    let channels = 0;\n    let messages = 0;\n    let reactions = 0;\n    for (const channel of this.client.channels.cache.values()) {\n      if (!channel.isTextBased()) continue;\n      channels++;\n      for (const message of channel.messages.cache.values()) {\n        messages++;\n        reactions += message.reactions.cache.sweep(filter);\n      }\n    }\n    this.client.emit(Events.CacheSweep, `Swept ${reactions} reactions on ${messages} messages in ${channels} text-based channels.`);\n    return reactions;\n  }\n\n  /**\n   * Sweeps all guild stage instances and removes the ones which are indicated by the filter.\n   * @param {Function} filter The function used to determine which stage instances will be removed from the caches.\n   * @returns {number} Amount of stage instances that were removed from the caches\n   */\n  sweepStageInstances(filter) {\n    return this._sweepGuildDirectProp('stageInstances', filter, {\n      outputName: 'stage instances'\n    }).items;\n  }\n\n  /**\n   * Sweeps all guild stickers and removes the ones which are indicated by the filter.\n   * @param {Function} filter The function used to determine which stickers will be removed from the caches.\n   * @returns {number} Amount of stickers that were removed from the caches\n   */\n  sweepStickers(filter) {\n    return this._sweepGuildDirectProp('stickers', filter).items;\n  }\n\n  /**\n   * Sweeps all thread members and removes the ones which are indicated by the filter.\n   * <info>It is highly recommended to keep the client thread member cached</info>\n   * @param {Function} filter The function used to determine which thread members will be removed from the caches.\n   * @returns {number} Amount of thread members that were removed from the caches\n   */\n  sweepThreadMembers(filter) {\n    if (typeof filter !== 'function') {\n      throw new DiscordjsTypeError(ErrorCodes.InvalidType, 'filter', 'function');\n    }\n    let threads = 0;\n    let members = 0;\n    for (const channel of this.client.channels.cache.values()) {\n      if (!ThreadChannelTypes.includes(channel.type)) continue;\n      threads++;\n      members += channel.members.cache.sweep(filter);\n    }\n    this.client.emit(Events.CacheSweep, `Swept ${members} thread members in ${threads} threads.`);\n    return members;\n  }\n\n  /**\n   * Sweeps all threads and removes the ones which are indicated by the filter.\n   * @param {Function} filter The function used to determine which threads will be removed from the caches.\n   * @returns {number} filter Amount of threads that were removed from the caches\n   * @example\n   * // Remove all threads archived greater than 1 day ago from all the channel caches\n   * const amount = sweepers.sweepThreads(\n   *   Sweepers.filterByLifetime({\n   *     getComparisonTimestamp: t => t.archivedTimestamp,\n   *     excludeFromSweep: t => !t.archived,\n   *   })(),\n   * );\n   * console.log(`Successfully removed ${amount} threads from the cache.`);\n   */\n  sweepThreads(filter) {\n    if (typeof filter !== 'function') {\n      throw new DiscordjsTypeError(ErrorCodes.InvalidType, 'filter', 'function');\n    }\n    let threads = 0;\n    for (const [key, val] of this.client.channels.cache.entries()) {\n      if (!ThreadChannelTypes.includes(val.type)) continue;\n      if (filter(val, key, this.client.channels.cache)) {\n        threads++;\n        this.client.channels._remove(key);\n      }\n    }\n    this.client.emit(Events.CacheSweep, `Swept ${threads} threads.`);\n    return threads;\n  }\n\n  /**\n   * Sweeps all users and removes the ones which are indicated by the filter.\n   * @param {Function} filter The function used to determine which users will be removed from the caches.\n   * @returns {number} Amount of users that were removed from the caches\n   */\n  sweepUsers(filter) {\n    if (typeof filter !== 'function') {\n      throw new DiscordjsTypeError(ErrorCodes.InvalidType, 'filter', 'function');\n    }\n    const users = this.client.users.cache.sweep(filter);\n    this.client.emit(Events.CacheSweep, `Swept ${users} users.`);\n    return users;\n  }\n\n  /**\n   * Sweeps all guild voice states and removes the ones which are indicated by the filter.\n   * @param {Function} filter The function used to determine which voice states will be removed from the caches.\n   * @returns {number} Amount of voice states that were removed from the caches\n   */\n  sweepVoiceStates(filter) {\n    return this._sweepGuildDirectProp('voiceStates', filter, {\n      outputName: 'voice states'\n    }).items;\n  }\n\n  /**\n   * Cancels all sweeping intervals\n   * @returns {void}\n   */\n  destroy() {\n    for (const key of SweeperKeys) {\n      if (this.intervals[key]) clearInterval(this.intervals[key]);\n    }\n  }\n\n  /**\n   * Options for generating a filter function based on lifetime\n   * @typedef {Object} LifetimeFilterOptions\n   * @property {number} [lifetime=14400] How long, in seconds, an entry should stay in the collection\n   * before it is considered sweepable.\n   * @property {Function} [getComparisonTimestamp=e => e?.createdTimestamp] A function that takes an entry, key,\n   * and the collection and returns a timestamp to compare against in order to determine the lifetime of the entry.\n   * @property {Function} [excludeFromSweep=() => false] A function that takes an entry, key, and the collection\n   * and returns a boolean, `true` when the entry should not be checked for sweepability.\n   */\n\n  /**\n   * Create a sweepFilter function that uses a lifetime to determine sweepability.\n   * @param {LifetimeFilterOptions} [options={}] The options used to generate the filter function\n   * @returns {GlobalSweepFilter}\n   */\n  static filterByLifetime() {\n    let {\n      lifetime = 14400,\n      getComparisonTimestamp = e => e?.createdTimestamp,\n      excludeFromSweep = () => false\n    } = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    if (typeof lifetime !== 'number') {\n      throw new DiscordjsTypeError(ErrorCodes.InvalidType, 'lifetime', 'number');\n    }\n    if (typeof getComparisonTimestamp !== 'function') {\n      throw new DiscordjsTypeError(ErrorCodes.InvalidType, 'getComparisonTimestamp', 'function');\n    }\n    if (typeof excludeFromSweep !== 'function') {\n      throw new DiscordjsTypeError(ErrorCodes.InvalidType, 'excludeFromSweep', 'function');\n    }\n    return () => {\n      if (lifetime <= 0) return null;\n      const lifetimeMs = lifetime * 1_000;\n      const now = Date.now();\n      return (entry, key, coll) => {\n        if (excludeFromSweep(entry, key, coll)) {\n          return false;\n        }\n        const comparisonTimestamp = getComparisonTimestamp(entry, key, coll);\n        if (!comparisonTimestamp || typeof comparisonTimestamp !== 'number') return false;\n        return now - comparisonTimestamp > lifetimeMs;\n      };\n    };\n  }\n\n  /**\n   * Creates a sweep filter that sweeps archived threads\n   * @param {number} [lifetime=14400] How long a thread has to be archived to be valid for sweeping\n   * @returns {GlobalSweepFilter}\n   */\n  static archivedThreadSweepFilter() {\n    let lifetime = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 14400;\n    return this.filterByLifetime({\n      lifetime,\n      getComparisonTimestamp: e => e.archiveTimestamp,\n      excludeFromSweep: e => !e.archived\n    });\n  }\n\n  /**\n   * Creates a sweep filter that sweeps expired invites\n   * @param {number} [lifetime=14400] How long ago an invite has to have expired to be valid for sweeping\n   * @returns {GlobalSweepFilter}\n   */\n  static expiredInviteSweepFilter() {\n    let lifetime = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 14400;\n    return this.filterByLifetime({\n      lifetime,\n      getComparisonTimestamp: i => i.expiresTimestamp\n    });\n  }\n\n  /**\n   * Creates a sweep filter that sweeps outdated messages (edits taken into account)\n   * @param {number} [lifetime=3600] How long ago a message has to have been sent or edited to be valid for sweeping\n   * @returns {GlobalSweepFilter}\n   */\n  static outdatedMessageSweepFilter() {\n    let lifetime = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 3600;\n    return this.filterByLifetime({\n      lifetime,\n      getComparisonTimestamp: m => m.editedTimestamp ?? m.createdTimestamp\n    });\n  }\n\n  /**\n   * Configuration options for emitting the cache sweep client event\n   * @typedef {Object} SweepEventOptions\n   * @property {boolean} [emit=true] Whether to emit the client event in this method\n   * @property {string} [outputName] A name to output in the client event if it should differ from the key\n   * @private\n   */\n\n  /**\n   * Sweep a direct sub property of all guilds\n   * @param {string} key The name of the property\n   * @param {Function} filter Filter function passed to sweep\n   * @param {SweepEventOptions} [eventOptions={}] Options for the Client event emitted here\n   * @returns {Object} Object containing the number of guilds swept and the number of items swept\n   * @private\n   */\n  _sweepGuildDirectProp(key, filter) {\n    let {\n      emit = true,\n      outputName\n    } = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n    if (typeof filter !== 'function') {\n      throw new DiscordjsTypeError(ErrorCodes.InvalidType, 'filter', 'function');\n    }\n    let guilds = 0;\n    let items = 0;\n    for (const guild of this.client.guilds.cache.values()) {\n      const {\n        cache\n      } = guild[key];\n      guilds++;\n      items += cache.sweep(filter);\n    }\n    if (emit) {\n      this.client.emit(Events.CacheSweep, `Swept ${items} ${outputName ?? key} in ${guilds} guilds.`);\n    }\n    return {\n      guilds,\n      items\n    };\n  }\n\n  /**\n   * Validates a set of properties\n   * @param {string} key Key of the options object to check\n   * @private\n   */\n  _validateProperties(key) {\n    const props = this.options[key];\n    if (typeof props !== 'object') {\n      throw new DiscordjsTypeError(ErrorCodes.InvalidType, `sweepers.${key}`, 'object', true);\n    }\n    if (typeof props.interval !== 'number') {\n      throw new DiscordjsTypeError(ErrorCodes.InvalidType, `sweepers.${key}.interval`, 'number');\n    }\n    // Invites, Messages, and Threads can be provided a lifetime parameter, which we use to generate the filter\n    if (['invites', 'messages', 'threads'].includes(key) && !('filter' in props)) {\n      if (typeof props.lifetime !== 'number') {\n        throw new DiscordjsTypeError(ErrorCodes.InvalidType, `sweepers.${key}.lifetime`, 'number');\n      }\n      return;\n    }\n    if (typeof props.filter !== 'function') {\n      throw new DiscordjsTypeError(ErrorCodes.InvalidType, `sweepers.${key}.filter`, 'function');\n    }\n  }\n\n  /**\n   * Initialize an interval for sweeping\n   * @param {string} intervalKey The name of the property that stores the interval for this sweeper\n   * @param {string} sweepKey The name of the function that sweeps the desired caches\n   * @param {Object} opts Validated options for a sweep\n   * @private\n   */\n  _initInterval(intervalKey, sweepKey, opts) {\n    if (opts.interval <= 0 || opts.interval === Infinity) return;\n    this.intervals[intervalKey] = setInterval(() => {\n      const sweepFn = opts.filter();\n      if (sweepFn === null) return;\n      if (typeof sweepFn !== 'function') throw new DiscordjsTypeError(ErrorCodes.SweepFilterReturn);\n      this[sweepKey](sweepFn);\n    }, opts.interval * 1_000).unref();\n  }\n}\nmodule.exports = Sweepers;","map":{"version":3,"names":["setInterval","clearInterval","require","ThreadChannelTypes","SweeperKeys","Events","DiscordjsTypeError","ErrorCodes","Sweepers","constructor","client","options","Object","defineProperty","value","intervals","fromEntries","map","key","_validateProperties","clonedOptions","filter","expiredInviteSweepFilter","lifetime","outdatedMessageSweepFilter","archivedThreadSweepFilter","_initInterval","toUpperCase","slice","sweepApplicationCommands","guilds","items","guildCommands","_sweepGuildDirectProp","emit","globalCommands","application","commands","cache","sweep","CacheSweep","sweepAutoModerationRules","sweepBans","sweepEmojis","sweepInvites","sweepGuildMembers","outputName","sweepMessages","InvalidType","channels","messages","channel","values","isTextBased","sweepPresences","sweepReactions","reactions","message","sweepStageInstances","sweepStickers","sweepThreadMembers","threads","members","includes","type","sweepThreads","val","entries","_remove","sweepUsers","users","sweepVoiceStates","destroy","filterByLifetime","getComparisonTimestamp","e","createdTimestamp","excludeFromSweep","lifetimeMs","now","Date","entry","coll","comparisonTimestamp","archiveTimestamp","archived","i","expiresTimestamp","m","editedTimestamp","guild","props","interval","intervalKey","sweepKey","opts","Infinity","sweepFn","SweepFilterReturn","unref","module","exports"],"sources":["J:/Coding/Projekts/Web/JavaScript/sillcode.tech/node_modules/discord.js/src/util/Sweepers.js"],"sourcesContent":["'use strict';\n\nconst { setInterval, clearInterval } = require('node:timers');\nconst { ThreadChannelTypes, SweeperKeys } = require('./Constants');\nconst Events = require('./Events');\nconst { DiscordjsTypeError, ErrorCodes } = require('../errors');\n\n/**\n * @typedef {Function} GlobalSweepFilter\n * @returns {Function|null} Return `null` to skip sweeping, otherwise a function passed to `sweep()`,\n * See {@link [Collection#sweep](https://discord.js.org/#/docs/collection/main/class/Collection?scrollTo=sweep)}\n * for the definition of this function.\n */\n\n/**\n * A container for all cache sweeping intervals and their associated sweep methods.\n */\nclass Sweepers {\n  constructor(client, options) {\n    /**\n     * The client that instantiated this\n     * @type {Client}\n     * @readonly\n     */\n    Object.defineProperty(this, 'client', { value: client });\n\n    /**\n     * The options the sweepers were instantiated with\n     * @type {SweeperOptions}\n     */\n    this.options = options;\n\n    /**\n     * A record of interval timeout that is used to sweep the indicated items, or null if not being swept\n     * @type {Object<SweeperKey, ?Timeout>}\n     */\n    this.intervals = Object.fromEntries(SweeperKeys.map(key => [key, null]));\n\n    for (const key of SweeperKeys) {\n      if (!(key in options)) continue;\n\n      this._validateProperties(key);\n\n      const clonedOptions = { ...this.options[key] };\n\n      // Handle cases that have a \"lifetime\"\n      if (!('filter' in clonedOptions)) {\n        switch (key) {\n          case 'invites':\n            clonedOptions.filter = this.constructor.expiredInviteSweepFilter(clonedOptions.lifetime);\n            break;\n          case 'messages':\n            clonedOptions.filter = this.constructor.outdatedMessageSweepFilter(clonedOptions.lifetime);\n            break;\n          case 'threads':\n            clonedOptions.filter = this.constructor.archivedThreadSweepFilter(clonedOptions.lifetime);\n        }\n      }\n\n      this._initInterval(key, `sweep${key[0].toUpperCase()}${key.slice(1)}`, clonedOptions);\n    }\n  }\n\n  /**\n   * Sweeps all guild and global application commands and removes the ones which are indicated by the filter.\n   * @param {Function} filter The function used to determine which commands will be removed from the caches.\n   * @returns {number} Amount of commands that were removed from the caches\n   */\n  sweepApplicationCommands(filter) {\n    const { guilds, items: guildCommands } = this._sweepGuildDirectProp('commands', filter, { emit: false });\n\n    const globalCommands = this.client.application?.commands.cache.sweep(filter) ?? 0;\n\n    this.client.emit(\n      Events.CacheSweep,\n      `Swept ${globalCommands} global application commands and ${guildCommands} guild commands in ${guilds} guilds.`,\n    );\n    return guildCommands + globalCommands;\n  }\n\n  /**\n   * Sweeps all auto moderation rules and removes the ones which are indicated by the filter.\n   * @param {Function} filter The function used to determine\n   * which auto moderation rules will be removed from the caches\n   * @returns {number} Amount of auto moderation rules that were removed from the caches\n   */\n  sweepAutoModerationRules(filter) {\n    return this._sweepGuildDirectProp('autoModerationRules', filter).items;\n  }\n\n  /**\n   * Sweeps all guild bans and removes the ones which are indicated by the filter.\n   * @param {Function} filter The function used to determine which bans will be removed from the caches.\n   * @returns {number} Amount of bans that were removed from the caches\n   */\n  sweepBans(filter) {\n    return this._sweepGuildDirectProp('bans', filter).items;\n  }\n\n  /**\n   * Sweeps all guild emojis and removes the ones which are indicated by the filter.\n   * @param {Function} filter The function used to determine which emojis will be removed from the caches.\n   * @returns {number} Amount of emojis that were removed from the caches\n   */\n  sweepEmojis(filter) {\n    return this._sweepGuildDirectProp('emojis', filter).items;\n  }\n\n  /**\n   * Sweeps all guild invites and removes the ones which are indicated by the filter.\n   * @param {Function} filter The function used to determine which invites will be removed from the caches.\n   * @returns {number} Amount of invites that were removed from the caches\n   */\n  sweepInvites(filter) {\n    return this._sweepGuildDirectProp('invites', filter).items;\n  }\n\n  /**\n   * Sweeps all guild members and removes the ones which are indicated by the filter.\n   * <info>It is highly recommended to keep the client guild member cached</info>\n   * @param {Function} filter The function used to determine which guild members will be removed from the caches.\n   * @returns {number} Amount of guild members that were removed from the caches\n   */\n  sweepGuildMembers(filter) {\n    return this._sweepGuildDirectProp('members', filter, { outputName: 'guild members' }).items;\n  }\n\n  /**\n   * Sweeps all text-based channels' messages and removes the ones which are indicated by the filter.\n   * @param {Function} filter The function used to determine which messages will be removed from the caches.\n   * @returns {number} Amount of messages that were removed from the caches\n   * @example\n   * // Remove all messages older than 1800 seconds from the messages cache\n   * const amount = sweepers.sweepMessages(\n   *   Sweepers.filterByLifetime({\n   *     lifetime: 1800,\n   *     getComparisonTimestamp: m => m.editedTimestamp ?? m.createdTimestamp,\n   *   })(),\n   * );\n   * console.log(`Successfully removed ${amount} messages from the cache.`);\n   */\n  sweepMessages(filter) {\n    if (typeof filter !== 'function') {\n      throw new DiscordjsTypeError(ErrorCodes.InvalidType, 'filter', 'function');\n    }\n    let channels = 0;\n    let messages = 0;\n\n    for (const channel of this.client.channels.cache.values()) {\n      if (!channel.isTextBased()) continue;\n\n      channels++;\n      messages += channel.messages.cache.sweep(filter);\n    }\n    this.client.emit(Events.CacheSweep, `Swept ${messages} messages in ${channels} text-based channels.`);\n    return messages;\n  }\n\n  /**\n   * Sweeps all presences and removes the ones which are indicated by the filter.\n   * @param {Function} filter The function used to determine which presences will be removed from the caches.\n   * @returns {number} Amount of presences that were removed from the caches\n   */\n  sweepPresences(filter) {\n    return this._sweepGuildDirectProp('presences', filter).items;\n  }\n\n  /**\n   * Sweeps all message reactions and removes the ones which are indicated by the filter.\n   * @param {Function} filter The function used to determine which reactions will be removed from the caches.\n   * @returns {number} Amount of reactions that were removed from the caches\n   */\n  sweepReactions(filter) {\n    if (typeof filter !== 'function') {\n      throw new DiscordjsTypeError(ErrorCodes.InvalidType, 'filter', 'function');\n    }\n    let channels = 0;\n    let messages = 0;\n    let reactions = 0;\n\n    for (const channel of this.client.channels.cache.values()) {\n      if (!channel.isTextBased()) continue;\n      channels++;\n\n      for (const message of channel.messages.cache.values()) {\n        messages++;\n        reactions += message.reactions.cache.sweep(filter);\n      }\n    }\n    this.client.emit(\n      Events.CacheSweep,\n      `Swept ${reactions} reactions on ${messages} messages in ${channels} text-based channels.`,\n    );\n    return reactions;\n  }\n\n  /**\n   * Sweeps all guild stage instances and removes the ones which are indicated by the filter.\n   * @param {Function} filter The function used to determine which stage instances will be removed from the caches.\n   * @returns {number} Amount of stage instances that were removed from the caches\n   */\n  sweepStageInstances(filter) {\n    return this._sweepGuildDirectProp('stageInstances', filter, { outputName: 'stage instances' }).items;\n  }\n\n  /**\n   * Sweeps all guild stickers and removes the ones which are indicated by the filter.\n   * @param {Function} filter The function used to determine which stickers will be removed from the caches.\n   * @returns {number} Amount of stickers that were removed from the caches\n   */\n  sweepStickers(filter) {\n    return this._sweepGuildDirectProp('stickers', filter).items;\n  }\n\n  /**\n   * Sweeps all thread members and removes the ones which are indicated by the filter.\n   * <info>It is highly recommended to keep the client thread member cached</info>\n   * @param {Function} filter The function used to determine which thread members will be removed from the caches.\n   * @returns {number} Amount of thread members that were removed from the caches\n   */\n  sweepThreadMembers(filter) {\n    if (typeof filter !== 'function') {\n      throw new DiscordjsTypeError(ErrorCodes.InvalidType, 'filter', 'function');\n    }\n\n    let threads = 0;\n    let members = 0;\n    for (const channel of this.client.channels.cache.values()) {\n      if (!ThreadChannelTypes.includes(channel.type)) continue;\n      threads++;\n      members += channel.members.cache.sweep(filter);\n    }\n    this.client.emit(Events.CacheSweep, `Swept ${members} thread members in ${threads} threads.`);\n    return members;\n  }\n\n  /**\n   * Sweeps all threads and removes the ones which are indicated by the filter.\n   * @param {Function} filter The function used to determine which threads will be removed from the caches.\n   * @returns {number} filter Amount of threads that were removed from the caches\n   * @example\n   * // Remove all threads archived greater than 1 day ago from all the channel caches\n   * const amount = sweepers.sweepThreads(\n   *   Sweepers.filterByLifetime({\n   *     getComparisonTimestamp: t => t.archivedTimestamp,\n   *     excludeFromSweep: t => !t.archived,\n   *   })(),\n   * );\n   * console.log(`Successfully removed ${amount} threads from the cache.`);\n   */\n  sweepThreads(filter) {\n    if (typeof filter !== 'function') {\n      throw new DiscordjsTypeError(ErrorCodes.InvalidType, 'filter', 'function');\n    }\n\n    let threads = 0;\n    for (const [key, val] of this.client.channels.cache.entries()) {\n      if (!ThreadChannelTypes.includes(val.type)) continue;\n      if (filter(val, key, this.client.channels.cache)) {\n        threads++;\n        this.client.channels._remove(key);\n      }\n    }\n    this.client.emit(Events.CacheSweep, `Swept ${threads} threads.`);\n    return threads;\n  }\n\n  /**\n   * Sweeps all users and removes the ones which are indicated by the filter.\n   * @param {Function} filter The function used to determine which users will be removed from the caches.\n   * @returns {number} Amount of users that were removed from the caches\n   */\n  sweepUsers(filter) {\n    if (typeof filter !== 'function') {\n      throw new DiscordjsTypeError(ErrorCodes.InvalidType, 'filter', 'function');\n    }\n\n    const users = this.client.users.cache.sweep(filter);\n\n    this.client.emit(Events.CacheSweep, `Swept ${users} users.`);\n\n    return users;\n  }\n\n  /**\n   * Sweeps all guild voice states and removes the ones which are indicated by the filter.\n   * @param {Function} filter The function used to determine which voice states will be removed from the caches.\n   * @returns {number} Amount of voice states that were removed from the caches\n   */\n  sweepVoiceStates(filter) {\n    return this._sweepGuildDirectProp('voiceStates', filter, { outputName: 'voice states' }).items;\n  }\n\n  /**\n   * Cancels all sweeping intervals\n   * @returns {void}\n   */\n  destroy() {\n    for (const key of SweeperKeys) {\n      if (this.intervals[key]) clearInterval(this.intervals[key]);\n    }\n  }\n\n  /**\n   * Options for generating a filter function based on lifetime\n   * @typedef {Object} LifetimeFilterOptions\n   * @property {number} [lifetime=14400] How long, in seconds, an entry should stay in the collection\n   * before it is considered sweepable.\n   * @property {Function} [getComparisonTimestamp=e => e?.createdTimestamp] A function that takes an entry, key,\n   * and the collection and returns a timestamp to compare against in order to determine the lifetime of the entry.\n   * @property {Function} [excludeFromSweep=() => false] A function that takes an entry, key, and the collection\n   * and returns a boolean, `true` when the entry should not be checked for sweepability.\n   */\n\n  /**\n   * Create a sweepFilter function that uses a lifetime to determine sweepability.\n   * @param {LifetimeFilterOptions} [options={}] The options used to generate the filter function\n   * @returns {GlobalSweepFilter}\n   */\n  static filterByLifetime({\n    lifetime = 14400,\n    getComparisonTimestamp = e => e?.createdTimestamp,\n    excludeFromSweep = () => false,\n  } = {}) {\n    if (typeof lifetime !== 'number') {\n      throw new DiscordjsTypeError(ErrorCodes.InvalidType, 'lifetime', 'number');\n    }\n    if (typeof getComparisonTimestamp !== 'function') {\n      throw new DiscordjsTypeError(ErrorCodes.InvalidType, 'getComparisonTimestamp', 'function');\n    }\n    if (typeof excludeFromSweep !== 'function') {\n      throw new DiscordjsTypeError(ErrorCodes.InvalidType, 'excludeFromSweep', 'function');\n    }\n    return () => {\n      if (lifetime <= 0) return null;\n      const lifetimeMs = lifetime * 1_000;\n      const now = Date.now();\n      return (entry, key, coll) => {\n        if (excludeFromSweep(entry, key, coll)) {\n          return false;\n        }\n        const comparisonTimestamp = getComparisonTimestamp(entry, key, coll);\n        if (!comparisonTimestamp || typeof comparisonTimestamp !== 'number') return false;\n        return now - comparisonTimestamp > lifetimeMs;\n      };\n    };\n  }\n\n  /**\n   * Creates a sweep filter that sweeps archived threads\n   * @param {number} [lifetime=14400] How long a thread has to be archived to be valid for sweeping\n   * @returns {GlobalSweepFilter}\n   */\n  static archivedThreadSweepFilter(lifetime = 14400) {\n    return this.filterByLifetime({\n      lifetime,\n      getComparisonTimestamp: e => e.archiveTimestamp,\n      excludeFromSweep: e => !e.archived,\n    });\n  }\n\n  /**\n   * Creates a sweep filter that sweeps expired invites\n   * @param {number} [lifetime=14400] How long ago an invite has to have expired to be valid for sweeping\n   * @returns {GlobalSweepFilter}\n   */\n  static expiredInviteSweepFilter(lifetime = 14400) {\n    return this.filterByLifetime({\n      lifetime,\n      getComparisonTimestamp: i => i.expiresTimestamp,\n    });\n  }\n\n  /**\n   * Creates a sweep filter that sweeps outdated messages (edits taken into account)\n   * @param {number} [lifetime=3600] How long ago a message has to have been sent or edited to be valid for sweeping\n   * @returns {GlobalSweepFilter}\n   */\n  static outdatedMessageSweepFilter(lifetime = 3600) {\n    return this.filterByLifetime({\n      lifetime,\n      getComparisonTimestamp: m => m.editedTimestamp ?? m.createdTimestamp,\n    });\n  }\n\n  /**\n   * Configuration options for emitting the cache sweep client event\n   * @typedef {Object} SweepEventOptions\n   * @property {boolean} [emit=true] Whether to emit the client event in this method\n   * @property {string} [outputName] A name to output in the client event if it should differ from the key\n   * @private\n   */\n\n  /**\n   * Sweep a direct sub property of all guilds\n   * @param {string} key The name of the property\n   * @param {Function} filter Filter function passed to sweep\n   * @param {SweepEventOptions} [eventOptions={}] Options for the Client event emitted here\n   * @returns {Object} Object containing the number of guilds swept and the number of items swept\n   * @private\n   */\n  _sweepGuildDirectProp(key, filter, { emit = true, outputName } = {}) {\n    if (typeof filter !== 'function') {\n      throw new DiscordjsTypeError(ErrorCodes.InvalidType, 'filter', 'function');\n    }\n\n    let guilds = 0;\n    let items = 0;\n\n    for (const guild of this.client.guilds.cache.values()) {\n      const { cache } = guild[key];\n\n      guilds++;\n      items += cache.sweep(filter);\n    }\n\n    if (emit) {\n      this.client.emit(Events.CacheSweep, `Swept ${items} ${outputName ?? key} in ${guilds} guilds.`);\n    }\n\n    return { guilds, items };\n  }\n\n  /**\n   * Validates a set of properties\n   * @param {string} key Key of the options object to check\n   * @private\n   */\n  _validateProperties(key) {\n    const props = this.options[key];\n    if (typeof props !== 'object') {\n      throw new DiscordjsTypeError(ErrorCodes.InvalidType, `sweepers.${key}`, 'object', true);\n    }\n    if (typeof props.interval !== 'number') {\n      throw new DiscordjsTypeError(ErrorCodes.InvalidType, `sweepers.${key}.interval`, 'number');\n    }\n    // Invites, Messages, and Threads can be provided a lifetime parameter, which we use to generate the filter\n    if (['invites', 'messages', 'threads'].includes(key) && !('filter' in props)) {\n      if (typeof props.lifetime !== 'number') {\n        throw new DiscordjsTypeError(ErrorCodes.InvalidType, `sweepers.${key}.lifetime`, 'number');\n      }\n      return;\n    }\n    if (typeof props.filter !== 'function') {\n      throw new DiscordjsTypeError(ErrorCodes.InvalidType, `sweepers.${key}.filter`, 'function');\n    }\n  }\n\n  /**\n   * Initialize an interval for sweeping\n   * @param {string} intervalKey The name of the property that stores the interval for this sweeper\n   * @param {string} sweepKey The name of the function that sweeps the desired caches\n   * @param {Object} opts Validated options for a sweep\n   * @private\n   */\n  _initInterval(intervalKey, sweepKey, opts) {\n    if (opts.interval <= 0 || opts.interval === Infinity) return;\n    this.intervals[intervalKey] = setInterval(() => {\n      const sweepFn = opts.filter();\n      if (sweepFn === null) return;\n      if (typeof sweepFn !== 'function') throw new DiscordjsTypeError(ErrorCodes.SweepFilterReturn);\n      this[sweepKey](sweepFn);\n    }, opts.interval * 1_000).unref();\n  }\n}\n\nmodule.exports = Sweepers;\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}