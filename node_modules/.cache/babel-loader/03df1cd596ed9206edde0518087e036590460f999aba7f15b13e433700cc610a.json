{"ast":null,"code":"'use strict';\n\nconst process = require('node:process');\nconst {\n  DiscordjsError,\n  DiscordjsTypeError,\n  ErrorCodes\n} = require('../errors');\nconst Events = require('../util/Events');\nconst {\n  makeError,\n  makePlainError\n} = require('../util/Util');\n\n/**\n * Helper class for sharded clients spawned as a child process/worker, such as from a {@link ShardingManager}.\n * Utilises IPC to send and receive data to/from the master process and other shards.\n */\nclass ShardClientUtil {\n  constructor(client, mode) {\n    /**\n     * Client for the shard\n     * @type {Client}\n     */\n    this.client = client;\n\n    /**\n     * Mode the shard was spawned with\n     * @type {ShardingManagerMode}\n     */\n    this.mode = mode;\n\n    /**\n     * Message port for the master process (only when {@link ShardClientUtil#mode} is `worker`)\n     * @type {?MessagePort}\n     */\n    this.parentPort = null;\n    if (mode === 'process') {\n      process.on('message', this._handleMessage.bind(this));\n      client.on('ready', () => {\n        process.send({\n          _ready: true\n        });\n      });\n      client.on('disconnect', () => {\n        process.send({\n          _disconnect: true\n        });\n      });\n      client.on('reconnecting', () => {\n        process.send({\n          _reconnecting: true\n        });\n      });\n    } else if (mode === 'worker') {\n      this.parentPort = require('node:worker_threads').parentPort;\n      this.parentPort.on('message', this._handleMessage.bind(this));\n      client.on('ready', () => {\n        this.parentPort.postMessage({\n          _ready: true\n        });\n      });\n      client.on('disconnect', () => {\n        this.parentPort.postMessage({\n          _disconnect: true\n        });\n      });\n      client.on('reconnecting', () => {\n        this.parentPort.postMessage({\n          _reconnecting: true\n        });\n      });\n    }\n  }\n\n  /**\n   * Array of shard ids of this client\n   * @type {number[]}\n   * @readonly\n   */\n  get ids() {\n    return this.client.options.shards;\n  }\n\n  /**\n   * Total number of shards\n   * @type {number}\n   * @readonly\n   */\n  get count() {\n    return this.client.options.shardCount;\n  }\n\n  /**\n   * Sends a message to the master process.\n   * @param {*} message Message to send\n   * @returns {Promise<void>}\n   * @emits Shard#message\n   */\n  send(message) {\n    return new Promise((resolve, reject) => {\n      if (this.mode === 'process') {\n        process.send(message, err => {\n          if (err) reject(err);else resolve();\n        });\n      } else if (this.mode === 'worker') {\n        this.parentPort.postMessage(message);\n        resolve();\n      }\n    });\n  }\n\n  /**\n   * Fetches a client property value of each shard, or a given shard.\n   * @param {string} prop Name of the client property to get, using periods for nesting\n   * @param {number} [shard] Shard to fetch property from, all if undefined\n   * @returns {Promise<*|Array<*>>}\n   * @example\n   * client.shard.fetchClientValues('guilds.cache.size')\n   *   .then(results => console.log(`${results.reduce((prev, val) => prev + val, 0)} total guilds`))\n   *   .catch(console.error);\n   * @see {@link ShardingManager#fetchClientValues}\n   */\n  fetchClientValues(prop, shard) {\n    return new Promise((resolve, reject) => {\n      const parent = this.parentPort ?? process;\n      const listener = message => {\n        if (message?._sFetchProp !== prop || message._sFetchPropShard !== shard) return;\n        parent.removeListener('message', listener);\n        this.decrementMaxListeners(parent);\n        if (!message._error) resolve(message._result);else reject(makeError(message._error));\n      };\n      this.incrementMaxListeners(parent);\n      parent.on('message', listener);\n      this.send({\n        _sFetchProp: prop,\n        _sFetchPropShard: shard\n      }).catch(err => {\n        parent.removeListener('message', listener);\n        this.decrementMaxListeners(parent);\n        reject(err);\n      });\n    });\n  }\n\n  /**\n   * Evaluates a script or function on all shards, or a given shard, in the context of the {@link Client}s.\n   * @param {Function} script JavaScript to run on each shard\n   * @param {BroadcastEvalOptions} [options={}] The options for the broadcast\n   * @returns {Promise<*|Array<*>>} Results of the script execution\n   * @example\n   * client.shard.broadcastEval(client => client.guilds.cache.size)\n   *   .then(results => console.log(`${results.reduce((prev, val) => prev + val, 0)} total guilds`))\n   *   .catch(console.error);\n   * @see {@link ShardingManager#broadcastEval}\n   */\n  broadcastEval(script) {\n    let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    return new Promise((resolve, reject) => {\n      const parent = this.parentPort ?? process;\n      if (typeof script !== 'function') {\n        reject(new DiscordjsTypeError(ErrorCodes.ShardingInvalidEvalBroadcast));\n        return;\n      }\n      script = `(${script})(this, ${JSON.stringify(options.context)})`;\n      const listener = message => {\n        if (message?._sEval !== script || message._sEvalShard !== options.shard) return;\n        parent.removeListener('message', listener);\n        this.decrementMaxListeners(parent);\n        if (!message._error) resolve(message._result);else reject(makeError(message._error));\n      };\n      this.incrementMaxListeners(parent);\n      parent.on('message', listener);\n      this.send({\n        _sEval: script,\n        _sEvalShard: options.shard\n      }).catch(err => {\n        parent.removeListener('message', listener);\n        this.decrementMaxListeners(parent);\n        reject(err);\n      });\n    });\n  }\n\n  /**\n   * Requests a respawn of all shards.\n   * @param {MultipleShardRespawnOptions} [options] Options for respawning shards\n   * @returns {Promise<void>} Resolves upon the message being sent\n   * @see {@link ShardingManager#respawnAll}\n   */\n  respawnAll() {\n    let {\n      shardDelay = 5_000,\n      respawnDelay = 500,\n      timeout = 30_000\n    } = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    return this.send({\n      _sRespawnAll: {\n        shardDelay,\n        respawnDelay,\n        timeout\n      }\n    });\n  }\n\n  /**\n   * Handles an IPC message.\n   * @param {*} message Message received\n   * @private\n   */\n  async _handleMessage(message) {\n    if (!message) return;\n    if (message._fetchProp) {\n      try {\n        const props = message._fetchProp.split('.');\n        let value = this.client;\n        for (const prop of props) value = value[prop];\n        this._respond('fetchProp', {\n          _fetchProp: message._fetchProp,\n          _result: value\n        });\n      } catch (err) {\n        this._respond('fetchProp', {\n          _fetchProp: message._fetchProp,\n          _error: makePlainError(err)\n        });\n      }\n    } else if (message._eval) {\n      try {\n        this._respond('eval', {\n          _eval: message._eval,\n          _result: await this.client._eval(message._eval)\n        });\n      } catch (err) {\n        this._respond('eval', {\n          _eval: message._eval,\n          _error: makePlainError(err)\n        });\n      }\n    }\n  }\n\n  /**\n   * Sends a message to the master process, emitting an error from the client upon failure.\n   * @param {string} type Type of response to send\n   * @param {*} message Message to send\n   * @private\n   */\n  _respond(type, message) {\n    this.send(message).catch(err => {\n      const error = new Error(`Error when sending ${type} response to master process: ${err.message}`);\n      error.stack = err.stack;\n      /**\n       * Emitted when the client encounters an error.\n       * <warn>Errors thrown within this event do not have a catch handler, it is\n       * recommended to not use async functions as `error` event handlers. See the\n       * [Node.js docs](https://nodejs.org/api/events.html#capture-rejections-of-promises) for details.</warn>\n       * @event Client#error\n       * @param {Error} error The error encountered\n       */\n      this.client.emit(Events.Error, error);\n    });\n  }\n\n  /**\n   * Creates/gets the singleton of this class.\n   * @param {Client} client The client to use\n   * @param {ShardingManagerMode} mode Mode the shard was spawned with\n   * @returns {ShardClientUtil}\n   */\n  static singleton(client, mode) {\n    if (!this._singleton) {\n      this._singleton = new this(client, mode);\n    } else {\n      client.emit(Events.Warn, 'Multiple clients created in child process/worker; only the first will handle sharding helpers.');\n    }\n    return this._singleton;\n  }\n\n  /**\n   * Get the shard id for a given guild id.\n   * @param {Snowflake} guildId Snowflake guild id to get shard id for\n   * @param {number} shardCount Number of shards\n   * @returns {number}\n   */\n  static shardIdForGuildId(guildId, shardCount) {\n    const shard = Number(BigInt(guildId) >> 22n) % shardCount;\n    if (shard < 0) throw new DiscordjsError(ErrorCodes.ShardingShardMiscalculation, shard, guildId, shardCount);\n    return shard;\n  }\n\n  /**\n   * Increments max listeners by one for a given emitter, if they are not zero.\n   * @param {EventEmitter|process} emitter The emitter that emits the events.\n   * @private\n   */\n  incrementMaxListeners(emitter) {\n    const maxListeners = emitter.getMaxListeners();\n    if (maxListeners !== 0) {\n      emitter.setMaxListeners(maxListeners + 1);\n    }\n  }\n\n  /**\n   * Decrements max listeners by one for a given emitter, if they are not zero.\n   * @param {EventEmitter|process} emitter The emitter that emits the events.\n   * @private\n   */\n  decrementMaxListeners(emitter) {\n    const maxListeners = emitter.getMaxListeners();\n    if (maxListeners !== 0) {\n      emitter.setMaxListeners(maxListeners - 1);\n    }\n  }\n}\nmodule.exports = ShardClientUtil;","map":{"version":3,"names":["process","require","DiscordjsError","DiscordjsTypeError","ErrorCodes","Events","makeError","makePlainError","ShardClientUtil","constructor","client","mode","parentPort","on","_handleMessage","bind","send","_ready","_disconnect","_reconnecting","postMessage","ids","options","shards","count","shardCount","message","Promise","resolve","reject","err","fetchClientValues","prop","shard","parent","listener","_sFetchProp","_sFetchPropShard","removeListener","decrementMaxListeners","_error","_result","incrementMaxListeners","catch","broadcastEval","script","ShardingInvalidEvalBroadcast","JSON","stringify","context","_sEval","_sEvalShard","respawnAll","shardDelay","respawnDelay","timeout","_sRespawnAll","_fetchProp","props","split","value","_respond","_eval","type","error","Error","stack","emit","singleton","_singleton","Warn","shardIdForGuildId","guildId","Number","BigInt","ShardingShardMiscalculation","emitter","maxListeners","getMaxListeners","setMaxListeners","module","exports"],"sources":["J:/Coding/Projekts/Web/JavaScript/sillcode.tech/node_modules/discord.js/src/sharding/ShardClientUtil.js"],"sourcesContent":["'use strict';\n\nconst process = require('node:process');\nconst { DiscordjsError, DiscordjsTypeError, ErrorCodes } = require('../errors');\nconst Events = require('../util/Events');\nconst { makeError, makePlainError } = require('../util/Util');\n\n/**\n * Helper class for sharded clients spawned as a child process/worker, such as from a {@link ShardingManager}.\n * Utilises IPC to send and receive data to/from the master process and other shards.\n */\nclass ShardClientUtil {\n  constructor(client, mode) {\n    /**\n     * Client for the shard\n     * @type {Client}\n     */\n    this.client = client;\n\n    /**\n     * Mode the shard was spawned with\n     * @type {ShardingManagerMode}\n     */\n    this.mode = mode;\n\n    /**\n     * Message port for the master process (only when {@link ShardClientUtil#mode} is `worker`)\n     * @type {?MessagePort}\n     */\n    this.parentPort = null;\n\n    if (mode === 'process') {\n      process.on('message', this._handleMessage.bind(this));\n      client.on('ready', () => {\n        process.send({ _ready: true });\n      });\n      client.on('disconnect', () => {\n        process.send({ _disconnect: true });\n      });\n      client.on('reconnecting', () => {\n        process.send({ _reconnecting: true });\n      });\n    } else if (mode === 'worker') {\n      this.parentPort = require('node:worker_threads').parentPort;\n      this.parentPort.on('message', this._handleMessage.bind(this));\n      client.on('ready', () => {\n        this.parentPort.postMessage({ _ready: true });\n      });\n      client.on('disconnect', () => {\n        this.parentPort.postMessage({ _disconnect: true });\n      });\n      client.on('reconnecting', () => {\n        this.parentPort.postMessage({ _reconnecting: true });\n      });\n    }\n  }\n\n  /**\n   * Array of shard ids of this client\n   * @type {number[]}\n   * @readonly\n   */\n  get ids() {\n    return this.client.options.shards;\n  }\n\n  /**\n   * Total number of shards\n   * @type {number}\n   * @readonly\n   */\n  get count() {\n    return this.client.options.shardCount;\n  }\n\n  /**\n   * Sends a message to the master process.\n   * @param {*} message Message to send\n   * @returns {Promise<void>}\n   * @emits Shard#message\n   */\n  send(message) {\n    return new Promise((resolve, reject) => {\n      if (this.mode === 'process') {\n        process.send(message, err => {\n          if (err) reject(err);\n          else resolve();\n        });\n      } else if (this.mode === 'worker') {\n        this.parentPort.postMessage(message);\n        resolve();\n      }\n    });\n  }\n\n  /**\n   * Fetches a client property value of each shard, or a given shard.\n   * @param {string} prop Name of the client property to get, using periods for nesting\n   * @param {number} [shard] Shard to fetch property from, all if undefined\n   * @returns {Promise<*|Array<*>>}\n   * @example\n   * client.shard.fetchClientValues('guilds.cache.size')\n   *   .then(results => console.log(`${results.reduce((prev, val) => prev + val, 0)} total guilds`))\n   *   .catch(console.error);\n   * @see {@link ShardingManager#fetchClientValues}\n   */\n  fetchClientValues(prop, shard) {\n    return new Promise((resolve, reject) => {\n      const parent = this.parentPort ?? process;\n\n      const listener = message => {\n        if (message?._sFetchProp !== prop || message._sFetchPropShard !== shard) return;\n        parent.removeListener('message', listener);\n        this.decrementMaxListeners(parent);\n        if (!message._error) resolve(message._result);\n        else reject(makeError(message._error));\n      };\n      this.incrementMaxListeners(parent);\n      parent.on('message', listener);\n\n      this.send({ _sFetchProp: prop, _sFetchPropShard: shard }).catch(err => {\n        parent.removeListener('message', listener);\n        this.decrementMaxListeners(parent);\n        reject(err);\n      });\n    });\n  }\n\n  /**\n   * Evaluates a script or function on all shards, or a given shard, in the context of the {@link Client}s.\n   * @param {Function} script JavaScript to run on each shard\n   * @param {BroadcastEvalOptions} [options={}] The options for the broadcast\n   * @returns {Promise<*|Array<*>>} Results of the script execution\n   * @example\n   * client.shard.broadcastEval(client => client.guilds.cache.size)\n   *   .then(results => console.log(`${results.reduce((prev, val) => prev + val, 0)} total guilds`))\n   *   .catch(console.error);\n   * @see {@link ShardingManager#broadcastEval}\n   */\n  broadcastEval(script, options = {}) {\n    return new Promise((resolve, reject) => {\n      const parent = this.parentPort ?? process;\n      if (typeof script !== 'function') {\n        reject(new DiscordjsTypeError(ErrorCodes.ShardingInvalidEvalBroadcast));\n        return;\n      }\n      script = `(${script})(this, ${JSON.stringify(options.context)})`;\n\n      const listener = message => {\n        if (message?._sEval !== script || message._sEvalShard !== options.shard) return;\n        parent.removeListener('message', listener);\n        this.decrementMaxListeners(parent);\n        if (!message._error) resolve(message._result);\n        else reject(makeError(message._error));\n      };\n      this.incrementMaxListeners(parent);\n      parent.on('message', listener);\n      this.send({ _sEval: script, _sEvalShard: options.shard }).catch(err => {\n        parent.removeListener('message', listener);\n        this.decrementMaxListeners(parent);\n        reject(err);\n      });\n    });\n  }\n\n  /**\n   * Requests a respawn of all shards.\n   * @param {MultipleShardRespawnOptions} [options] Options for respawning shards\n   * @returns {Promise<void>} Resolves upon the message being sent\n   * @see {@link ShardingManager#respawnAll}\n   */\n  respawnAll({ shardDelay = 5_000, respawnDelay = 500, timeout = 30_000 } = {}) {\n    return this.send({ _sRespawnAll: { shardDelay, respawnDelay, timeout } });\n  }\n\n  /**\n   * Handles an IPC message.\n   * @param {*} message Message received\n   * @private\n   */\n  async _handleMessage(message) {\n    if (!message) return;\n    if (message._fetchProp) {\n      try {\n        const props = message._fetchProp.split('.');\n        let value = this.client;\n        for (const prop of props) value = value[prop];\n        this._respond('fetchProp', { _fetchProp: message._fetchProp, _result: value });\n      } catch (err) {\n        this._respond('fetchProp', { _fetchProp: message._fetchProp, _error: makePlainError(err) });\n      }\n    } else if (message._eval) {\n      try {\n        this._respond('eval', { _eval: message._eval, _result: await this.client._eval(message._eval) });\n      } catch (err) {\n        this._respond('eval', { _eval: message._eval, _error: makePlainError(err) });\n      }\n    }\n  }\n\n  /**\n   * Sends a message to the master process, emitting an error from the client upon failure.\n   * @param {string} type Type of response to send\n   * @param {*} message Message to send\n   * @private\n   */\n  _respond(type, message) {\n    this.send(message).catch(err => {\n      const error = new Error(`Error when sending ${type} response to master process: ${err.message}`);\n      error.stack = err.stack;\n      /**\n       * Emitted when the client encounters an error.\n       * <warn>Errors thrown within this event do not have a catch handler, it is\n       * recommended to not use async functions as `error` event handlers. See the\n       * [Node.js docs](https://nodejs.org/api/events.html#capture-rejections-of-promises) for details.</warn>\n       * @event Client#error\n       * @param {Error} error The error encountered\n       */\n      this.client.emit(Events.Error, error);\n    });\n  }\n\n  /**\n   * Creates/gets the singleton of this class.\n   * @param {Client} client The client to use\n   * @param {ShardingManagerMode} mode Mode the shard was spawned with\n   * @returns {ShardClientUtil}\n   */\n  static singleton(client, mode) {\n    if (!this._singleton) {\n      this._singleton = new this(client, mode);\n    } else {\n      client.emit(\n        Events.Warn,\n        'Multiple clients created in child process/worker; only the first will handle sharding helpers.',\n      );\n    }\n    return this._singleton;\n  }\n\n  /**\n   * Get the shard id for a given guild id.\n   * @param {Snowflake} guildId Snowflake guild id to get shard id for\n   * @param {number} shardCount Number of shards\n   * @returns {number}\n   */\n  static shardIdForGuildId(guildId, shardCount) {\n    const shard = Number(BigInt(guildId) >> 22n) % shardCount;\n    if (shard < 0) throw new DiscordjsError(ErrorCodes.ShardingShardMiscalculation, shard, guildId, shardCount);\n    return shard;\n  }\n\n  /**\n   * Increments max listeners by one for a given emitter, if they are not zero.\n   * @param {EventEmitter|process} emitter The emitter that emits the events.\n   * @private\n   */\n  incrementMaxListeners(emitter) {\n    const maxListeners = emitter.getMaxListeners();\n    if (maxListeners !== 0) {\n      emitter.setMaxListeners(maxListeners + 1);\n    }\n  }\n\n  /**\n   * Decrements max listeners by one for a given emitter, if they are not zero.\n   * @param {EventEmitter|process} emitter The emitter that emits the events.\n   * @private\n   */\n  decrementMaxListeners(emitter) {\n    const maxListeners = emitter.getMaxListeners();\n    if (maxListeners !== 0) {\n      emitter.setMaxListeners(maxListeners - 1);\n    }\n  }\n}\n\nmodule.exports = ShardClientUtil;\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}