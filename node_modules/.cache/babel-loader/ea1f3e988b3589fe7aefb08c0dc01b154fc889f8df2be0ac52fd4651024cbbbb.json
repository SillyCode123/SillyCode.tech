{"ast":null,"code":"\"use strict\";\n\"use strict\";\n\nvar __defProp = Object.defineProperty;\nvar __getOwnPropDesc = Object.getOwnPropertyDescriptor;\nvar __getOwnPropNames = Object.getOwnPropertyNames;\nvar __hasOwnProp = Object.prototype.hasOwnProperty;\nvar __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, {\n  enumerable: true,\n  configurable: true,\n  writable: true,\n  value\n}) : obj[key] = value;\nvar __name = (target, value) => __defProp(target, \"name\", {\n  value,\n  configurable: true\n});\nvar __export = (target, all) => {\n  for (var name in all) __defProp(target, name, {\n    get: all[name],\n    enumerable: true\n  });\n};\nvar __copyProps = (to, from, except, desc) => {\n  if (from && typeof from === \"object\" || typeof from === \"function\") {\n    for (let key of __getOwnPropNames(from)) if (!__hasOwnProp.call(to, key) && key !== except) __defProp(to, key, {\n      get: () => from[key],\n      enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable\n    });\n  }\n  return to;\n};\nvar __toCommonJS = mod => __copyProps(__defProp({}, \"__esModule\", {\n  value: true\n}), mod);\nvar __publicField = (obj, key, value) => {\n  __defNormalProp(obj, typeof key !== \"symbol\" ? key + \"\" : key, value);\n  return value;\n};\n\n// src/index.ts\nvar src_exports = {};\n__export(src_exports, {\n  AsyncQueue: () => AsyncQueue\n});\nmodule.exports = __toCommonJS(src_exports);\n\n// src/lib/AsyncQueueEntry.ts\nvar AsyncQueueEntry = class {\n  constructor(queue) {\n    __publicField(this, \"promise\");\n    __publicField(this, \"resolve\");\n    __publicField(this, \"reject\");\n    __publicField(this, \"queue\");\n    __publicField(this, \"signal\", null);\n    __publicField(this, \"signalListener\", null);\n    this.queue = queue;\n    this.promise = new Promise((resolve, reject) => {\n      this.resolve = resolve;\n      this.reject = reject;\n    });\n  }\n  setSignal(signal) {\n    if (signal.aborted) return this;\n    this.signal = signal;\n    this.signalListener = () => {\n      const index = this.queue[\"promises\"].indexOf(this);\n      if (index !== -1) this.queue[\"promises\"].splice(index, 1);\n      this.reject(new Error(\"Request aborted manually\"));\n    };\n    this.signal.addEventListener(\"abort\", this.signalListener);\n    return this;\n  }\n  use() {\n    this.dispose();\n    this.resolve();\n    return this;\n  }\n  abort() {\n    this.dispose();\n    this.reject(new Error(\"Request aborted manually\"));\n    return this;\n  }\n  dispose() {\n    if (this.signal) {\n      this.signal.removeEventListener(\"abort\", this.signalListener);\n      this.signal = null;\n      this.signalListener = null;\n    }\n  }\n};\n__name(AsyncQueueEntry, \"AsyncQueueEntry\");\n\n// src/lib/AsyncQueue.ts\nvar AsyncQueue = class {\n  constructor() {\n    __publicField(this, \"promises\", []);\n  }\n  get remaining() {\n    return this.promises.length;\n  }\n  get queued() {\n    return this.remaining === 0 ? 0 : this.remaining - 1;\n  }\n  wait(options) {\n    const entry = new AsyncQueueEntry(this);\n    if (this.promises.length === 0) {\n      this.promises.push(entry);\n      return Promise.resolve();\n    }\n    this.promises.push(entry);\n    if (options?.signal) entry.setSignal(options.signal);\n    return entry.promise;\n  }\n  shift() {\n    if (this.promises.length === 0) return;\n    if (this.promises.length === 1) {\n      this.promises.shift();\n      return;\n    }\n    this.promises.shift();\n    this.promises[0].use();\n  }\n  abortAll() {\n    if (this.queued === 0) return;\n    for (let i = 1; i < this.promises.length; ++i) {\n      this.promises[i].abort();\n    }\n    this.promises.length = 1;\n  }\n};\n__name(AsyncQueue, \"AsyncQueue\");\n// Annotate the CommonJS export names for ESM import in node:\n0 && (module.exports = {\n  AsyncQueue\n});","map":{"version":3,"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAAA;AAAAA;EAAAC;AAAA;AAAAC;;;ACKO,IAAMC,kBAAN,MAAsB;EAQrBC,YAAYC,OAAmB;IAPtCC,oBAAgB;IAChBA,oBAAQ;IACRA,oBAAQ;IACRA,oBAAiB;IACjBA,oBAAQ,UAAqC;IAC7CA,oBAAQ,kBAAsC;IAG7C,KAAKD,QAAQA;IACb,KAAKE,UAAU,IAAIC,QAAQ,CAACC,SAASC,WAAW;MAC/C,KAAKD,UAAUA;MACf,KAAKC,SAASA;IACf,CAAC;EACF;EAEOC,UAAUC,QAAqB;IACrC,IAAIA,OAAOC,SAAS,OAAO;IAE3B,KAAKD,SAASA;IACd,KAAKE,iBAAiB,MAAM;MAC3B,MAAMC,QAAQ,KAAKV,MAAM,YAAYW,QAAQ,IAAI;MACjD,IAAID,UAAU,IAAI,KAAKV,MAAM,YAAYY,OAAOF,OAAO,CAAC;MAExD,KAAKL,OAAO,IAAIQ,MAAM,0BAA0B,CAAC;IAClD;IACA,KAAKN,OAAOO,iBAAiB,SAAS,KAAKL,cAAc;IACzD,OAAO;EACR;EAEOM,MAAM;IACZ,KAAKC,SAAQ;IACb,KAAKZ,SAAQ;IACb,OAAO;EACR;EAEOa,QAAQ;IACd,KAAKD,SAAQ;IACb,KAAKX,OAAO,IAAIQ,MAAM,0BAA0B,CAAC;IACjD,OAAO;EACR;EAEQG,UAAU;IACjB,IAAI,KAAKT,QAAQ;MAChB,KAAKA,OAAOW,oBAAoB,SAAS,KAAKT,cAAe;MAC7D,KAAKF,SAAS;MACd,KAAKE,iBAAiB;IACvB;EACD;AACD;AAjDaU;;;ACAN,IAAMvB,aAAN,MAAiB;EAAjBG;IAoBNE,oBAAQ,YAA8B,EAAC;EAAA;EAfvC,IAAWmB,YAAoB;IAC9B,OAAO,KAAKC,SAASC;EACtB;EAMA,IAAWC,SAAiB;IAC3B,OAAO,KAAKH,cAAc,IAAI,IAAI,KAAKA,YAAY;EACpD;EA4BOI,KAAKC,SAA0D;IACrE,MAAMC,QAAQ,IAAI5B,gBAAgB,IAAI;IAEtC,IAAI,KAAKuB,SAASC,WAAW,GAAG;MAC/B,KAAKD,SAASM,KAAKD,KAAK;MACxB,OAAOvB,QAAQC,SAAQ;IACxB;IAEA,KAAKiB,SAASM,KAAKD,KAAK;IACxB,IAAID,SAASlB,QAAQmB,MAAMpB,UAAUmB,QAAQlB,MAAM;IACnD,OAAOmB,MAAMxB;EACd;EAKO0B,QAAc;IACpB,IAAI,KAAKP,SAASC,WAAW,GAAG;IAChC,IAAI,KAAKD,SAASC,WAAW,GAAG;MAE/B,KAAKD,SAASO,OAAM;MACpB;IACD;IAIA,KAAKP,SAASO,OAAM;IACpB,KAAKP,SAAS,GAAGN,KAAI;EACtB;EAMOc,WAAiB;IAEvB,IAAI,KAAKN,WAAW,GAAG;IAIvB,SAASO,IAAI,GAAGA,IAAI,KAAKT,SAASC,QAAQ,EAAEQ,GAAG;MAC9C,KAAKT,SAASS,GAAGb,OAAM;IACxB;IAEA,KAAKI,SAASC,SAAS;EACxB;AACD;AAzFaH","names":["__export","AsyncQueue","module","AsyncQueueEntry","constructor","queue","__publicField","promise","Promise","resolve","reject","setSignal","signal","aborted","signalListener","index","indexOf","splice","Error","addEventListener","use","dispose","abort","removeEventListener","__name","remaining","promises","length","queued","wait","options","entry","push","shift","abortAll","i"],"sources":["J:\\Coding\\Projekts\\Web\\JavaScript\\sillcode.tech\\node_modules\\@sapphire\\async-queue\\src\\index.ts","J:\\Coding\\Projekts\\Web\\JavaScript\\sillcode.tech\\node_modules\\@sapphire\\async-queue\\src\\lib\\AsyncQueueEntry.ts","J:\\Coding\\Projekts\\Web\\JavaScript\\sillcode.tech\\node_modules\\@sapphire\\async-queue\\src\\lib\\AsyncQueue.ts"],"sourcesContent":["export * from './lib/AsyncQueue';\n","import type { AsyncQueue } from './AsyncQueue';\n\n/**\n * @internal\n */\nexport class AsyncQueueEntry {\n\tpublic readonly promise: Promise<void>;\n\tprivate resolve!: () => void;\n\tprivate reject!: (error: Error) => void;\n\tprivate readonly queue: AsyncQueue;\n\tprivate signal: PolyFillAbortSignal | null = null;\n\tprivate signalListener: (() => void) | null = null;\n\n\tpublic constructor(queue: AsyncQueue) {\n\t\tthis.queue = queue;\n\t\tthis.promise = new Promise((resolve, reject) => {\n\t\t\tthis.resolve = resolve;\n\t\t\tthis.reject = reject;\n\t\t});\n\t}\n\n\tpublic setSignal(signal: AbortSignal) {\n\t\tif (signal.aborted) return this;\n\n\t\tthis.signal = signal as PolyFillAbortSignal;\n\t\tthis.signalListener = () => {\n\t\t\tconst index = this.queue['promises'].indexOf(this);\n\t\t\tif (index !== -1) this.queue['promises'].splice(index, 1);\n\n\t\t\tthis.reject(new Error('Request aborted manually'));\n\t\t};\n\t\tthis.signal.addEventListener('abort', this.signalListener);\n\t\treturn this;\n\t}\n\n\tpublic use() {\n\t\tthis.dispose();\n\t\tthis.resolve();\n\t\treturn this;\n\t}\n\n\tpublic abort() {\n\t\tthis.dispose();\n\t\tthis.reject(new Error('Request aborted manually'));\n\t\treturn this;\n\t}\n\n\tprivate dispose() {\n\t\tif (this.signal) {\n\t\t\tthis.signal.removeEventListener('abort', this.signalListener!);\n\t\t\tthis.signal = null;\n\t\t\tthis.signalListener = null;\n\t\t}\n\t}\n}\n\ninterface PolyFillAbortSignal {\n\treadonly aborted: boolean;\n\taddEventListener(type: 'abort', listener: () => void): void;\n\tremoveEventListener(type: 'abort', listener: () => void): void;\n}\n","import { AsyncQueueEntry } from './AsyncQueueEntry';\n\n/**\n * The AsyncQueue class used to sequentialize burst requests\n */\nexport class AsyncQueue {\n\t/**\n\t * The amount of entries in the queue, including the head.\n\t * @seealso {@link queued} for the queued count.\n\t */\n\tpublic get remaining(): number {\n\t\treturn this.promises.length;\n\t}\n\n\t/**\n\t * The amount of queued entries.\n\t * @seealso {@link remaining} for the count with the head.\n\t */\n\tpublic get queued(): number {\n\t\treturn this.remaining === 0 ? 0 : this.remaining - 1;\n\t}\n\n\t/**\n\t * The promises array\n\t */\n\tprivate promises: AsyncQueueEntry[] = [];\n\n\t/**\n\t * Waits for last promise and queues a new one\n\t * @example\n\t * ```typescript\n\t * const queue = new AsyncQueue();\n\t * async function request(url, options) {\n\t *     await queue.wait({ signal: options.signal });\n\t *     try {\n\t *         const result = await fetch(url, options);\n\t *         // Do some operations with 'result'\n\t *     } finally {\n\t *         // Remove first entry from the queue and resolve for the next entry\n\t *         queue.shift();\n\t *     }\n\t * }\n\t *\n\t * request(someUrl1, someOptions1); // Will call fetch() immediately\n\t * request(someUrl2, someOptions2); // Will call fetch() after the first finished\n\t * request(someUrl3, someOptions3); // Will call fetch() after the second finished\n\t * ```\n\t */\n\tpublic wait(options?: Readonly<AsyncQueueWaitOptions>): Promise<void> {\n\t\tconst entry = new AsyncQueueEntry(this);\n\n\t\tif (this.promises.length === 0) {\n\t\t\tthis.promises.push(entry);\n\t\t\treturn Promise.resolve();\n\t\t}\n\n\t\tthis.promises.push(entry);\n\t\tif (options?.signal) entry.setSignal(options.signal);\n\t\treturn entry.promise;\n\t}\n\n\t/**\n\t * Unlocks the head lock and transfers the next lock (if any) to the head.\n\t */\n\tpublic shift(): void {\n\t\tif (this.promises.length === 0) return;\n\t\tif (this.promises.length === 1) {\n\t\t\t// Remove the head entry.\n\t\t\tthis.promises.shift();\n\t\t\treturn;\n\t\t}\n\n\t\t// Remove the head entry, making the 2nd entry the new one.\n\t\t// Then use the head entry, which will unlock the promise.\n\t\tthis.promises.shift();\n\t\tthis.promises[0].use();\n\t}\n\n\t/**\n\t * Aborts all the pending promises.\n\t * @note To avoid race conditions, this does **not** unlock the head lock.\n\t */\n\tpublic abortAll(): void {\n\t\t// If there are no queued entries, skip early.\n\t\tif (this.queued === 0) return;\n\n\t\t// Abort all the entries except the head, that is why the loop starts at\n\t\t// 1 and not at 0.\n\t\tfor (let i = 1; i < this.promises.length; ++i) {\n\t\t\tthis.promises[i].abort();\n\t\t}\n\n\t\tthis.promises.length = 1;\n\t}\n}\n\nexport interface AsyncQueueWaitOptions {\n\tsignal?: AbortSignal | undefined | null;\n}\n"]},"metadata":{},"sourceType":"script","externalDependencies":[]}