{"ast":null,"code":"'use strict';\n\nconst {\n  messageLink\n} = require('@discordjs/builders');\nconst {\n  Collection\n} = require('@discordjs/collection');\nconst {\n  DiscordSnowflake\n} = require('@sapphire/snowflake');\nconst {\n  InteractionType,\n  ChannelType,\n  MessageType,\n  MessageFlags,\n  PermissionFlagsBits\n} = require('discord-api-types/v10');\nconst Attachment = require('./Attachment');\nconst Base = require('./Base');\nconst ClientApplication = require('./ClientApplication');\nconst Embed = require('./Embed');\nconst InteractionCollector = require('./InteractionCollector');\nconst Mentions = require('./MessageMentions');\nconst MessagePayload = require('./MessagePayload');\nconst ReactionCollector = require('./ReactionCollector');\nconst {\n  Sticker\n} = require('./Sticker');\nconst {\n  DiscordjsError,\n  ErrorCodes\n} = require('../errors');\nconst ReactionManager = require('../managers/ReactionManager');\nconst {\n  createComponent\n} = require('../util/Components');\nconst {\n  NonSystemMessageTypes,\n  MaxBulkDeletableMessageAge\n} = require('../util/Constants');\nconst MessageFlagsBitField = require('../util/MessageFlagsBitField');\nconst PermissionsBitField = require('../util/PermissionsBitField');\nconst {\n  cleanContent,\n  resolvePartialEmoji\n} = require('../util/Util');\n\n/**\n * Represents a message on Discord.\n * @extends {Base}\n */\nclass Message extends Base {\n  constructor(client, data) {\n    super(client);\n\n    /**\n     * The id of the channel the message was sent in\n     * @type {Snowflake}\n     */\n    this.channelId = data.channel_id;\n\n    /**\n     * The id of the guild the message was sent in, if any\n     * @type {?Snowflake}\n     */\n    this.guildId = data.guild_id ?? this.channel?.guild?.id ?? null;\n    this._patch(data);\n  }\n  _patch(data) {\n    /**\n     * The message's id\n     * @type {Snowflake}\n     */\n    this.id = data.id;\n\n    /**\n     * The timestamp the message was sent at\n     * @type {number}\n     */\n    this.createdTimestamp = DiscordSnowflake.timestampFrom(this.id);\n    if ('type' in data) {\n      /**\n       * The type of the message\n       * @type {?MessageType}\n       */\n      this.type = data.type;\n\n      /**\n       * Whether or not this message was sent by Discord, not actually a user (e.g. pin notifications)\n       * @type {?boolean}\n       */\n      this.system = !NonSystemMessageTypes.includes(this.type);\n    } else {\n      this.system ??= null;\n      this.type ??= null;\n    }\n    if ('content' in data) {\n      /**\n       * The content of the message.\n       * <info>This property requires the {@link GatewayIntentBits.MessageContent} privileged intent\n       * in a guild for messages that do not mention the client.</info>\n       * @type {?string}\n       */\n      this.content = data.content;\n    } else {\n      this.content ??= null;\n    }\n    if ('author' in data) {\n      /**\n       * The author of the message\n       * @type {?User}\n       */\n      this.author = this.client.users._add(data.author, !data.webhook_id);\n    } else {\n      this.author ??= null;\n    }\n    if ('pinned' in data) {\n      /**\n       * Whether or not this message is pinned\n       * @type {?boolean}\n       */\n      this.pinned = Boolean(data.pinned);\n    } else {\n      this.pinned ??= null;\n    }\n    if ('tts' in data) {\n      /**\n       * Whether or not the message was Text-To-Speech\n       * @type {?boolean}\n       */\n      this.tts = data.tts;\n    } else {\n      this.tts ??= null;\n    }\n    if ('nonce' in data) {\n      /**\n       * A random number or string used for checking message delivery\n       * <warn>This is only received after the message was sent successfully, and\n       * lost if re-fetched</warn>\n       * @type {?string}\n       */\n      this.nonce = data.nonce;\n    } else {\n      this.nonce ??= null;\n    }\n    if ('embeds' in data) {\n      /**\n       * An array of embeds in the message - e.g. YouTube Player.\n       * <info>This property requires the {@link GatewayIntentBits.MessageContent} privileged intent\n       * in a guild for messages that do not mention the client.</info>\n       * @type {Embed[]}\n       */\n      this.embeds = data.embeds.map(e => new Embed(e));\n    } else {\n      this.embeds = this.embeds?.slice() ?? [];\n    }\n    if ('components' in data) {\n      /**\n       * An array of of action rows in the message.\n       * <info>This property requires the {@link GatewayIntentBits.MessageContent} privileged intent\n       * in a guild for messages that do not mention the client.</info>\n       * @type {ActionRow[]}\n       */\n      this.components = data.components.map(c => createComponent(c));\n    } else {\n      this.components = this.components?.slice() ?? [];\n    }\n    if ('attachments' in data) {\n      /**\n       * A collection of attachments in the message - e.g. Pictures - mapped by their ids.\n       * <info>This property requires the {@link GatewayIntentBits.MessageContent} privileged intent\n       * in a guild for messages that do not mention the client.</info>\n       * @type {Collection<Snowflake, Attachment>}\n       */\n      this.attachments = new Collection();\n      if (data.attachments) {\n        for (const attachment of data.attachments) {\n          this.attachments.set(attachment.id, new Attachment(attachment));\n        }\n      }\n    } else {\n      this.attachments = new Collection(this.attachments);\n    }\n    if ('sticker_items' in data || 'stickers' in data) {\n      /**\n       * A collection of stickers in the message\n       * @type {Collection<Snowflake, Sticker>}\n       */\n      this.stickers = new Collection((data.sticker_items ?? data.stickers)?.map(s => [s.id, new Sticker(this.client, s)]));\n    } else {\n      this.stickers = new Collection(this.stickers);\n    }\n    if ('position' in data) {\n      /**\n       * A generally increasing integer (there may be gaps or duplicates) that represents\n       * the approximate position of the message in a thread.\n       * @type {?number}\n       */\n      this.position = data.position;\n    } else {\n      this.position ??= null;\n    }\n\n    // Discord sends null if the message has not been edited\n    if (data.edited_timestamp) {\n      /**\n       * The timestamp the message was last edited at (if applicable)\n       * @type {?number}\n       */\n      this.editedTimestamp = Date.parse(data.edited_timestamp);\n    } else {\n      this.editedTimestamp ??= null;\n    }\n    if ('reactions' in data) {\n      /**\n       * A manager of the reactions belonging to this message\n       * @type {ReactionManager}\n       */\n      this.reactions = new ReactionManager(this);\n      if (data.reactions?.length > 0) {\n        for (const reaction of data.reactions) {\n          this.reactions._add(reaction);\n        }\n      }\n    } else {\n      this.reactions ??= new ReactionManager(this);\n    }\n    if (!this.mentions) {\n      /**\n       * All valid mentions that the message contains\n       * @type {MessageMentions}\n       */\n      this.mentions = new Mentions(this, data.mentions, data.mention_roles, data.mention_everyone, data.mention_channels, data.referenced_message?.author);\n    } else {\n      this.mentions = new Mentions(this, data.mentions ?? this.mentions.users, data.mention_roles ?? this.mentions.roles, data.mention_everyone ?? this.mentions.everyone, data.mention_channels ?? this.mentions.crosspostedChannels, data.referenced_message?.author ?? this.mentions.repliedUser);\n    }\n    if ('webhook_id' in data) {\n      /**\n       * The id of the webhook that sent the message, if applicable\n       * @type {?Snowflake}\n       */\n      this.webhookId = data.webhook_id;\n    } else {\n      this.webhookId ??= null;\n    }\n    if ('application' in data) {\n      /**\n       * Supplemental application information for group activities\n       * @type {?ClientApplication}\n       */\n      this.groupActivityApplication = new ClientApplication(this.client, data.application);\n    } else {\n      this.groupActivityApplication ??= null;\n    }\n    if ('application_id' in data) {\n      /**\n       * The id of the application of the interaction that sent this message, if any\n       * @type {?Snowflake}\n       */\n      this.applicationId = data.application_id;\n    } else {\n      this.applicationId ??= null;\n    }\n    if ('activity' in data) {\n      /**\n       * Group activity\n       * @type {?MessageActivity}\n       */\n      this.activity = {\n        partyId: data.activity.party_id,\n        type: data.activity.type\n      };\n    } else {\n      this.activity ??= null;\n    }\n    if ('thread' in data) {\n      this.client.channels._add(data.thread, this.guild);\n    }\n    if (this.member && data.member) {\n      this.member._patch(data.member);\n    } else if (data.member && this.guild && this.author) {\n      this.guild.members._add(Object.assign(data.member, {\n        user: this.author\n      }));\n    }\n    if ('flags' in data) {\n      /**\n       * Flags that are applied to the message\n       * @type {Readonly<MessageFlagsBitField>}\n       */\n      this.flags = new MessageFlagsBitField(data.flags).freeze();\n    } else {\n      this.flags = new MessageFlagsBitField(this.flags).freeze();\n    }\n\n    /**\n     * Reference data sent in a message that contains ids identifying the referenced message.\n     * This can be present in the following types of message:\n     * * Crossposted messages (`MessageFlags.Crossposted`)\n     * * {@link MessageType.ChannelFollowAdd}\n     * * {@link MessageType.ChannelPinnedMessage}\n     * * {@link MessageType.Reply}\n     * * {@link MessageType.ThreadStarterMessage}\n     * @see {@link https://discord.com/developers/docs/resources/channel#message-types}\n     * @typedef {Object} MessageReference\n     * @property {Snowflake} channelId The channel's id the message was referenced\n     * @property {?Snowflake} guildId The guild's id the message was referenced\n     * @property {?Snowflake} messageId The message's id that was referenced\n     */\n\n    if ('message_reference' in data) {\n      /**\n       * Message reference data\n       * @type {?MessageReference}\n       */\n      this.reference = {\n        channelId: data.message_reference.channel_id,\n        guildId: data.message_reference.guild_id,\n        messageId: data.message_reference.message_id\n      };\n    } else {\n      this.reference ??= null;\n    }\n    if (data.referenced_message) {\n      this.channel?.messages._add({\n        guild_id: data.message_reference?.guild_id,\n        ...data.referenced_message\n      });\n    }\n\n    /**\n     * Partial data of the interaction that a message is a reply to\n     * @typedef {Object} MessageInteraction\n     * @property {Snowflake} id The interaction's id\n     * @property {InteractionType} type The type of the interaction\n     * @property {string} commandName The name of the interaction's application command,\n     * as well as the subcommand and subcommand group, where applicable\n     * @property {User} user The user that invoked the interaction\n     */\n\n    if (data.interaction) {\n      /**\n       * Partial data of the interaction that this message is a reply to\n       * @type {?MessageInteraction}\n       */\n      this.interaction = {\n        id: data.interaction.id,\n        type: data.interaction.type,\n        commandName: data.interaction.name,\n        user: this.client.users._add(data.interaction.user)\n      };\n    } else {\n      this.interaction ??= null;\n    }\n  }\n\n  /**\n   * The channel that the message was sent in\n   * @type {TextBasedChannels}\n   * @readonly\n   */\n  get channel() {\n    return this.client.channels.resolve(this.channelId);\n  }\n\n  /**\n   * Whether or not this message is a partial\n   * @type {boolean}\n   * @readonly\n   */\n  get partial() {\n    return typeof this.content !== 'string' || !this.author;\n  }\n\n  /**\n   * Represents the author of the message as a guild member.\n   * Only available if the message comes from a guild where the author is still a member\n   * @type {?GuildMember}\n   * @readonly\n   */\n  get member() {\n    return this.guild?.members.resolve(this.author) ?? null;\n  }\n\n  /**\n   * The time the message was sent at\n   * @type {Date}\n   * @readonly\n   */\n  get createdAt() {\n    return new Date(this.createdTimestamp);\n  }\n\n  /**\n   * The time the message was last edited at (if applicable)\n   * @type {?Date}\n   * @readonly\n   */\n  get editedAt() {\n    return this.editedTimestamp && new Date(this.editedTimestamp);\n  }\n\n  /**\n   * The guild the message was sent in (if in a guild channel)\n   * @type {?Guild}\n   * @readonly\n   */\n  get guild() {\n    return this.client.guilds.resolve(this.guildId) ?? this.channel?.guild ?? null;\n  }\n\n  /**\n   * Whether this message has a thread associated with it\n   * @type {boolean}\n   * @readonly\n   */\n  get hasThread() {\n    return this.flags.has(MessageFlags.HasThread);\n  }\n\n  /**\n   * The thread started by this message\n   * <info>This property is not suitable for checking whether a message has a thread,\n   * use {@link Message#hasThread} instead.</info>\n   * @type {?ThreadChannel}\n   * @readonly\n   */\n  get thread() {\n    return this.channel?.threads?.resolve(this.id) ?? null;\n  }\n\n  /**\n   * The URL to jump to this message\n   * @type {string}\n   * @readonly\n   */\n  get url() {\n    return this.inGuild() ? messageLink(this.channelId, this.id, this.guildId) : messageLink(this.channelId, this.id);\n  }\n\n  /**\n   * The message contents with all mentions replaced by the equivalent text.\n   * If mentions cannot be resolved to a name, the relevant mention in the message content will not be converted.\n   * @type {?string}\n   * @readonly\n   */\n  get cleanContent() {\n    // eslint-disable-next-line eqeqeq\n    return this.content != null ? cleanContent(this.content, this.channel) : null;\n  }\n\n  /**\n   * Creates a reaction collector.\n   * @param {ReactionCollectorOptions} [options={}] Options to send to the collector\n   * @returns {ReactionCollector}\n   * @example\n   * // Create a reaction collector\n   * const filter = (reaction, user) => reaction.emoji.name === '👌' && user.id === 'someId';\n   * const collector = message.createReactionCollector({ filter, time: 15_000 });\n   * collector.on('collect', r => console.log(`Collected ${r.emoji.name}`));\n   * collector.on('end', collected => console.log(`Collected ${collected.size} items`));\n   */\n  createReactionCollector() {\n    let options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    return new ReactionCollector(this, options);\n  }\n\n  /**\n   * An object containing the same properties as CollectorOptions, but a few more:\n   * @typedef {ReactionCollectorOptions} AwaitReactionsOptions\n   * @property {string[]} [errors] Stop/end reasons that cause the promise to reject\n   */\n\n  /**\n   * Similar to createReactionCollector but in promise form.\n   * Resolves with a collection of reactions that pass the specified filter.\n   * @param {AwaitReactionsOptions} [options={}] Optional options to pass to the internal collector\n   * @returns {Promise<Collection<string | Snowflake, MessageReaction>>}\n   * @example\n   * // Create a reaction collector\n   * const filter = (reaction, user) => reaction.emoji.name === '👌' && user.id === 'someId'\n   * message.awaitReactions({ filter, time: 15_000 })\n   *   .then(collected => console.log(`Collected ${collected.size} reactions`))\n   *   .catch(console.error);\n   */\n  awaitReactions() {\n    let options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    return new Promise((resolve, reject) => {\n      const collector = this.createReactionCollector(options);\n      collector.once('end', (reactions, reason) => {\n        if (options.errors?.includes(reason)) reject(reactions);else resolve(reactions);\n      });\n    });\n  }\n\n  /**\n   * @typedef {CollectorOptions} MessageComponentCollectorOptions\n   * @property {ComponentType} [componentType] The type of component to listen for\n   * @property {number} [max] The maximum total amount of interactions to collect\n   * @property {number} [maxComponents] The maximum number of components to collect\n   * @property {number} [maxUsers] The maximum number of users to interact\n   */\n\n  /**\n   * Creates a message component interaction collector.\n   * @param {MessageComponentCollectorOptions} [options={}] Options to send to the collector\n   * @returns {InteractionCollector}\n   * @example\n   * // Create a message component interaction collector\n   * const filter = (interaction) => interaction.customId === 'button' && interaction.user.id === 'someId';\n   * const collector = message.createMessageComponentCollector({ filter, time: 15_000 });\n   * collector.on('collect', i => console.log(`Collected ${i.customId}`));\n   * collector.on('end', collected => console.log(`Collected ${collected.size} items`));\n   */\n  createMessageComponentCollector() {\n    let options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    return new InteractionCollector(this.client, {\n      ...options,\n      interactionType: InteractionType.MessageComponent,\n      message: this\n    });\n  }\n\n  /**\n   * An object containing the same properties as CollectorOptions, but a few more:\n   * @typedef {Object} AwaitMessageComponentOptions\n   * @property {CollectorFilter} [filter] The filter applied to this collector\n   * @property {number} [time] Time to wait for an interaction before rejecting\n   * @property {ComponentType} [componentType] The type of component interaction to collect\n   * @property {number} [idle] Time to wait without another message component interaction before ending the collector\n   * @property {boolean} [dispose] Whether to remove the message component interaction after collecting\n   * @property {InteractionResponse} [InteractionResponse] The interaction response to collect interactions from\n   */\n\n  /**\n   * Collects a single component interaction that passes the filter.\n   * The Promise will reject if the time expires.\n   * @param {AwaitMessageComponentOptions} [options={}] Options to pass to the internal collector\n   * @returns {Promise<MessageComponentInteraction>}\n   * @example\n   * // Collect a message component interaction\n   * const filter = (interaction) => interaction.customId === 'button' && interaction.user.id === 'someId';\n   * message.awaitMessageComponent({ filter, time: 15_000 })\n   *   .then(interaction => console.log(`${interaction.customId} was clicked!`))\n   *   .catch(console.error);\n   */\n  awaitMessageComponent() {\n    let options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    const _options = {\n      ...options,\n      max: 1\n    };\n    return new Promise((resolve, reject) => {\n      const collector = this.createMessageComponentCollector(_options);\n      collector.once('end', (interactions, reason) => {\n        const interaction = interactions.first();\n        if (interaction) resolve(interaction);else reject(new DiscordjsError(ErrorCodes.InteractionCollectorError, reason));\n      });\n    });\n  }\n\n  /**\n   * Whether the message is editable by the client user\n   * @type {boolean}\n   * @readonly\n   */\n  get editable() {\n    const precheck = Boolean(this.author.id === this.client.user.id && (!this.guild || this.channel?.viewable));\n    // Regardless of permissions thread messages cannot be edited if\n    // the thread is locked.\n    if (this.channel?.isThread()) {\n      return precheck && !this.channel.locked;\n    }\n    return precheck;\n  }\n\n  /**\n   * Whether the message is deletable by the client user\n   * @type {boolean}\n   * @readonly\n   */\n  get deletable() {\n    if (!this.guild) {\n      return this.author.id === this.client.user.id;\n    }\n    // DMChannel does not have viewable property, so check viewable after proved that message is on a guild.\n    if (!this.channel?.viewable) {\n      return false;\n    }\n    const permissions = this.channel?.permissionsFor(this.client.user);\n    if (!permissions) return false;\n    // This flag allows deleting even if timed out\n    if (permissions.has(PermissionFlagsBits.Administrator, false)) return true;\n    return Boolean(this.author.id === this.client.user.id || permissions.has(PermissionFlagsBits.ManageMessages, false) && this.guild.members.me.communicationDisabledUntilTimestamp < Date.now());\n  }\n\n  /**\n   * Whether the message is bulk deletable by the client user\n   * @type {boolean}\n   * @readonly\n   * @example\n   * // Filter for bulk deletable messages\n   * channel.bulkDelete(messages.filter(message => message.bulkDeletable));\n   */\n  get bulkDeletable() {\n    const permissions = this.channel?.permissionsFor(this.client.user);\n    return (this.inGuild() && Date.now() - this.createdTimestamp < MaxBulkDeletableMessageAge && this.deletable && permissions?.has(PermissionFlagsBits.ManageMessages, false)) ?? false;\n  }\n\n  /**\n   * Whether the message is pinnable by the client user\n   * @type {boolean}\n   * @readonly\n   */\n  get pinnable() {\n    const {\n      channel\n    } = this;\n    return Boolean(!this.system && (!this.guild || channel?.viewable && channel?.permissionsFor(this.client.user)?.has(PermissionFlagsBits.ManageMessages, false)));\n  }\n\n  /**\n   * Fetches the Message this crosspost/reply/pin-add references, if available to the client\n   * @returns {Promise<Message>}\n   */\n  async fetchReference() {\n    if (!this.reference) throw new DiscordjsError(ErrorCodes.MessageReferenceMissing);\n    const {\n      channelId,\n      messageId\n    } = this.reference;\n    const channel = this.client.channels.resolve(channelId);\n    if (!channel) throw new DiscordjsError(ErrorCodes.GuildChannelResolve);\n    const message = await channel.messages.fetch(messageId);\n    return message;\n  }\n\n  /**\n   * Whether the message is crosspostable by the client user\n   * @type {boolean}\n   * @readonly\n   */\n  get crosspostable() {\n    const bitfield = PermissionFlagsBits.SendMessages | (this.author.id === this.client.user.id ? PermissionsBitField.DefaultBit : PermissionFlagsBits.ManageMessages);\n    const {\n      channel\n    } = this;\n    return Boolean(channel?.type === ChannelType.GuildAnnouncement && !this.flags.has(MessageFlags.Crossposted) && this.type === MessageType.Default && channel.viewable && channel.permissionsFor(this.client.user)?.has(bitfield, false));\n  }\n\n  /**\n   * Edits the content of the message.\n   * @param {string|MessagePayload|MessageEditOptions} options The options to provide\n   * @returns {Promise<Message>}\n   * @example\n   * // Update the content of a message\n   * message.edit('This is my new content!')\n   *   .then(msg => console.log(`Updated the content of a message to ${msg.content}`))\n   *   .catch(console.error);\n   */\n  edit(options) {\n    if (!this.channel) return Promise.reject(new DiscordjsError(ErrorCodes.ChannelNotCached));\n    return this.channel.messages.edit(this, options);\n  }\n\n  /**\n   * Publishes a message in an announcement channel to all channels following it.\n   * @returns {Promise<Message>}\n   * @example\n   * // Crosspost a message\n   * if (message.channel.type === ChannelType.GuildAnnouncement) {\n   *   message.crosspost()\n   *     .then(() => console.log('Crossposted message'))\n   *     .catch(console.error);\n   * }\n   */\n  crosspost() {\n    if (!this.channel) return Promise.reject(new DiscordjsError(ErrorCodes.ChannelNotCached));\n    return this.channel.messages.crosspost(this.id);\n  }\n\n  /**\n   * Pins this message to the channel's pinned messages.\n   * @param {string} [reason] Reason for pinning\n   * @returns {Promise<Message>}\n   * @example\n   * // Pin a message\n   * message.pin()\n   *   .then(console.log)\n   *   .catch(console.error)\n   */\n  async pin(reason) {\n    if (!this.channel) throw new DiscordjsError(ErrorCodes.ChannelNotCached);\n    await this.channel.messages.pin(this.id, reason);\n    return this;\n  }\n\n  /**\n   * Unpins this message from the channel's pinned messages.\n   * @param {string} [reason] Reason for unpinning\n   * @returns {Promise<Message>}\n   * @example\n   * // Unpin a message\n   * message.unpin()\n   *   .then(console.log)\n   *   .catch(console.error)\n   */\n  async unpin(reason) {\n    if (!this.channel) throw new DiscordjsError(ErrorCodes.ChannelNotCached);\n    await this.channel.messages.unpin(this.id, reason);\n    return this;\n  }\n\n  /**\n   * Adds a reaction to the message.\n   * @param {EmojiIdentifierResolvable} emoji The emoji to react with\n   * @returns {Promise<MessageReaction>}\n   * @example\n   * // React to a message with a unicode emoji\n   * message.react('🤔')\n   *   .then(console.log)\n   *   .catch(console.error);\n   * @example\n   * // React to a message with a custom emoji\n   * message.react(message.guild.emojis.cache.get('123456789012345678'))\n   *   .then(console.log)\n   *   .catch(console.error);\n   */\n  async react(emoji) {\n    if (!this.channel) throw new DiscordjsError(ErrorCodes.ChannelNotCached);\n    await this.channel.messages.react(this.id, emoji);\n    return this.client.actions.MessageReactionAdd.handle({\n      user: this.client.user,\n      channel: this.channel,\n      message: this,\n      emoji: resolvePartialEmoji(emoji)\n    }, true).reaction;\n  }\n\n  /**\n   * Deletes the message.\n   * @returns {Promise<Message>}\n   * @example\n   * // Delete a message\n   * message.delete()\n   *   .then(msg => console.log(`Deleted message from ${msg.author.username}`))\n   *   .catch(console.error);\n   */\n  async delete() {\n    if (!this.channel) throw new DiscordjsError(ErrorCodes.ChannelNotCached);\n    await this.channel.messages.delete(this.id);\n    return this;\n  }\n\n  /**\n   * Options provided when sending a message as an inline reply.\n   * @typedef {BaseMessageCreateOptions} MessageReplyOptions\n   * @property {boolean} [failIfNotExists=this.client.options.failIfNotExists] Whether to error if the referenced\n   * message does not exist (creates a standard message in this case when false)\n   * @property {StickerResolvable[]} [stickers=[]] Stickers to send in the message\n   */\n\n  /**\n   * Send an inline reply to this message.\n   * @param {string|MessagePayload|MessageReplyOptions} options The options to provide\n   * @returns {Promise<Message>}\n   * @example\n   * // Reply to a message\n   * message.reply('This is a reply!')\n   *   .then(() => console.log(`Replied to message \"${message.content}\"`))\n   *   .catch(console.error);\n   */\n  reply(options) {\n    if (!this.channel) return Promise.reject(new DiscordjsError(ErrorCodes.ChannelNotCached));\n    let data;\n    if (options instanceof MessagePayload) {\n      data = options;\n    } else {\n      data = MessagePayload.create(this, options, {\n        reply: {\n          messageReference: this,\n          failIfNotExists: options?.failIfNotExists ?? this.client.options.failIfNotExists\n        }\n      });\n    }\n    return this.channel.send(data);\n  }\n\n  /**\n   * Options for starting a thread on a message.\n   * @typedef {Object} StartThreadOptions\n   * @property {string} name The name of the new thread\n   * @property {ThreadAutoArchiveDuration} [autoArchiveDuration=this.channel.defaultAutoArchiveDuration] The amount of\n   * time after which the thread should automatically archive in case of no recent activity\n   * @property {string} [reason] Reason for creating the thread\n   * @property {number} [rateLimitPerUser] The rate limit per user (slowmode) for the thread in seconds\n   */\n\n  /**\n   * Create a new public thread from this message\n   * @see GuildTextThreadManager#create\n   * @param {StartThreadOptions} [options] Options for starting a thread on this message\n   * @returns {Promise<ThreadChannel>}\n   */\n  startThread() {\n    let options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    if (!this.channel) return Promise.reject(new DiscordjsError(ErrorCodes.ChannelNotCached));\n    if (![ChannelType.GuildText, ChannelType.GuildAnnouncement].includes(this.channel.type)) {\n      return Promise.reject(new DiscordjsError(ErrorCodes.MessageThreadParent));\n    }\n    if (this.hasThread) return Promise.reject(new DiscordjsError(ErrorCodes.MessageExistingThread));\n    return this.channel.threads.create({\n      ...options,\n      startMessage: this\n    });\n  }\n\n  /**\n   * Fetch this message.\n   * @param {boolean} [force=true] Whether to skip the cache check and request the API\n   * @returns {Promise<Message>}\n   */\n  fetch() {\n    let force = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;\n    if (!this.channel) return Promise.reject(new DiscordjsError(ErrorCodes.ChannelNotCached));\n    return this.channel.messages.fetch({\n      message: this.id,\n      force\n    });\n  }\n\n  /**\n   * Fetches the webhook used to create this message.\n   * @returns {Promise<?Webhook>}\n   */\n  fetchWebhook() {\n    if (!this.webhookId) return Promise.reject(new DiscordjsError(ErrorCodes.WebhookMessage));\n    if (this.webhookId === this.applicationId) return Promise.reject(new DiscordjsError(ErrorCodes.WebhookApplication));\n    return this.client.fetchWebhook(this.webhookId);\n  }\n\n  /**\n   * Suppresses or unsuppresses embeds on a message.\n   * @param {boolean} [suppress=true] If the embeds should be suppressed or not\n   * @returns {Promise<Message>}\n   */\n  suppressEmbeds() {\n    let suppress = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;\n    const flags = new MessageFlagsBitField(this.flags.bitfield);\n    if (suppress) {\n      flags.add(MessageFlags.SuppressEmbeds);\n    } else {\n      flags.remove(MessageFlags.SuppressEmbeds);\n    }\n    return this.edit({\n      flags\n    });\n  }\n\n  /**\n   * Removes the attachments from this message.\n   * @returns {Promise<Message>}\n   */\n  removeAttachments() {\n    return this.edit({\n      attachments: []\n    });\n  }\n\n  /**\n   * Resolves a component by a custom id.\n   * @param {string} customId The custom id to resolve against\n   * @returns {?MessageActionRowComponent}\n   */\n  resolveComponent(customId) {\n    return this.components.flatMap(row => row.components).find(component => component.customId === customId) ?? null;\n  }\n\n  /**\n   * Used mainly internally. Whether two messages are identical in properties. If you want to compare messages\n   * without checking all the properties, use `message.id === message2.id`, which is much more efficient. This\n   * method allows you to see if there are differences in content, embeds, attachments, nonce and tts properties.\n   * @param {Message} message The message to compare it to\n   * @param {APIMessage} rawData Raw data passed through the WebSocket about this message\n   * @returns {boolean}\n   */\n  equals(message, rawData) {\n    if (!message) return false;\n    const embedUpdate = !message.author && !message.attachments;\n    if (embedUpdate) return this.id === message.id && this.embeds.length === message.embeds.length;\n    let equal = this.id === message.id && this.author.id === message.author.id && this.content === message.content && this.tts === message.tts && this.nonce === message.nonce && this.embeds.length === message.embeds.length && this.attachments.length === message.attachments.length;\n    if (equal && rawData) {\n      equal = this.mentions.everyone === message.mentions.everyone && this.createdTimestamp === Date.parse(rawData.timestamp) && this.editedTimestamp === Date.parse(rawData.edited_timestamp);\n    }\n    return equal;\n  }\n\n  /**\n   * Whether this message is from a guild.\n   * @returns {boolean}\n   */\n  inGuild() {\n    return Boolean(this.guildId);\n  }\n\n  /**\n   * When concatenated with a string, this automatically concatenates the message's content instead of the object.\n   * @returns {string}\n   * @example\n   * // Logs: Message: This is a message!\n   * console.log(`Message: ${message}`);\n   */\n  toString() {\n    return this.content;\n  }\n  toJSON() {\n    return super.toJSON({\n      channel: 'channelId',\n      author: 'authorId',\n      groupActivityApplication: 'groupActivityApplicationId',\n      guild: 'guildId',\n      cleanContent: true,\n      member: false,\n      reactions: false\n    });\n  }\n}\nexports.Message = Message;","map":{"version":3,"names":["messageLink","require","Collection","DiscordSnowflake","InteractionType","ChannelType","MessageType","MessageFlags","PermissionFlagsBits","Attachment","Base","ClientApplication","Embed","InteractionCollector","Mentions","MessagePayload","ReactionCollector","Sticker","DiscordjsError","ErrorCodes","ReactionManager","createComponent","NonSystemMessageTypes","MaxBulkDeletableMessageAge","MessageFlagsBitField","PermissionsBitField","cleanContent","resolvePartialEmoji","Message","constructor","client","data","channelId","channel_id","guildId","guild_id","channel","guild","id","_patch","createdTimestamp","timestampFrom","type","system","includes","content","author","users","_add","webhook_id","pinned","Boolean","tts","nonce","embeds","map","e","slice","components","c","attachments","attachment","set","stickers","sticker_items","s","position","edited_timestamp","editedTimestamp","Date","parse","reactions","length","reaction","mentions","mention_roles","mention_everyone","mention_channels","referenced_message","roles","everyone","crosspostedChannels","repliedUser","webhookId","groupActivityApplication","application","applicationId","application_id","activity","partyId","party_id","channels","thread","member","members","Object","assign","user","flags","freeze","reference","message_reference","messageId","message_id","messages","interaction","commandName","name","resolve","partial","createdAt","editedAt","guilds","hasThread","has","HasThread","threads","url","inGuild","createReactionCollector","options","awaitReactions","Promise","reject","collector","once","reason","errors","createMessageComponentCollector","interactionType","MessageComponent","message","awaitMessageComponent","_options","max","interactions","first","InteractionCollectorError","editable","precheck","viewable","isThread","locked","deletable","permissions","permissionsFor","Administrator","ManageMessages","me","communicationDisabledUntilTimestamp","now","bulkDeletable","pinnable","fetchReference","MessageReferenceMissing","GuildChannelResolve","fetch","crosspostable","bitfield","SendMessages","DefaultBit","GuildAnnouncement","Crossposted","Default","edit","ChannelNotCached","crosspost","pin","unpin","react","emoji","actions","MessageReactionAdd","handle","delete","reply","create","messageReference","failIfNotExists","send","startThread","GuildText","MessageThreadParent","MessageExistingThread","startMessage","force","fetchWebhook","WebhookMessage","WebhookApplication","suppressEmbeds","suppress","add","SuppressEmbeds","remove","removeAttachments","resolveComponent","customId","flatMap","row","find","component","equals","rawData","embedUpdate","equal","timestamp","toString","toJSON","exports"],"sources":["J:/Coding/Projekts/Web/JavaScript/sillcode.tech/node_modules/discord.js/src/structures/Message.js"],"sourcesContent":["'use strict';\n\nconst { messageLink } = require('@discordjs/builders');\nconst { Collection } = require('@discordjs/collection');\nconst { DiscordSnowflake } = require('@sapphire/snowflake');\nconst {\n  InteractionType,\n  ChannelType,\n  MessageType,\n  MessageFlags,\n  PermissionFlagsBits,\n} = require('discord-api-types/v10');\nconst Attachment = require('./Attachment');\nconst Base = require('./Base');\nconst ClientApplication = require('./ClientApplication');\nconst Embed = require('./Embed');\nconst InteractionCollector = require('./InteractionCollector');\nconst Mentions = require('./MessageMentions');\nconst MessagePayload = require('./MessagePayload');\nconst ReactionCollector = require('./ReactionCollector');\nconst { Sticker } = require('./Sticker');\nconst { DiscordjsError, ErrorCodes } = require('../errors');\nconst ReactionManager = require('../managers/ReactionManager');\nconst { createComponent } = require('../util/Components');\nconst { NonSystemMessageTypes, MaxBulkDeletableMessageAge } = require('../util/Constants');\nconst MessageFlagsBitField = require('../util/MessageFlagsBitField');\nconst PermissionsBitField = require('../util/PermissionsBitField');\nconst { cleanContent, resolvePartialEmoji } = require('../util/Util');\n\n/**\n * Represents a message on Discord.\n * @extends {Base}\n */\nclass Message extends Base {\n  constructor(client, data) {\n    super(client);\n\n    /**\n     * The id of the channel the message was sent in\n     * @type {Snowflake}\n     */\n    this.channelId = data.channel_id;\n\n    /**\n     * The id of the guild the message was sent in, if any\n     * @type {?Snowflake}\n     */\n    this.guildId = data.guild_id ?? this.channel?.guild?.id ?? null;\n\n    this._patch(data);\n  }\n\n  _patch(data) {\n    /**\n     * The message's id\n     * @type {Snowflake}\n     */\n    this.id = data.id;\n\n    /**\n     * The timestamp the message was sent at\n     * @type {number}\n     */\n    this.createdTimestamp = DiscordSnowflake.timestampFrom(this.id);\n\n    if ('type' in data) {\n      /**\n       * The type of the message\n       * @type {?MessageType}\n       */\n      this.type = data.type;\n\n      /**\n       * Whether or not this message was sent by Discord, not actually a user (e.g. pin notifications)\n       * @type {?boolean}\n       */\n      this.system = !NonSystemMessageTypes.includes(this.type);\n    } else {\n      this.system ??= null;\n      this.type ??= null;\n    }\n\n    if ('content' in data) {\n      /**\n       * The content of the message.\n       * <info>This property requires the {@link GatewayIntentBits.MessageContent} privileged intent\n       * in a guild for messages that do not mention the client.</info>\n       * @type {?string}\n       */\n      this.content = data.content;\n    } else {\n      this.content ??= null;\n    }\n\n    if ('author' in data) {\n      /**\n       * The author of the message\n       * @type {?User}\n       */\n      this.author = this.client.users._add(data.author, !data.webhook_id);\n    } else {\n      this.author ??= null;\n    }\n\n    if ('pinned' in data) {\n      /**\n       * Whether or not this message is pinned\n       * @type {?boolean}\n       */\n      this.pinned = Boolean(data.pinned);\n    } else {\n      this.pinned ??= null;\n    }\n\n    if ('tts' in data) {\n      /**\n       * Whether or not the message was Text-To-Speech\n       * @type {?boolean}\n       */\n      this.tts = data.tts;\n    } else {\n      this.tts ??= null;\n    }\n\n    if ('nonce' in data) {\n      /**\n       * A random number or string used for checking message delivery\n       * <warn>This is only received after the message was sent successfully, and\n       * lost if re-fetched</warn>\n       * @type {?string}\n       */\n      this.nonce = data.nonce;\n    } else {\n      this.nonce ??= null;\n    }\n\n    if ('embeds' in data) {\n      /**\n       * An array of embeds in the message - e.g. YouTube Player.\n       * <info>This property requires the {@link GatewayIntentBits.MessageContent} privileged intent\n       * in a guild for messages that do not mention the client.</info>\n       * @type {Embed[]}\n       */\n      this.embeds = data.embeds.map(e => new Embed(e));\n    } else {\n      this.embeds = this.embeds?.slice() ?? [];\n    }\n\n    if ('components' in data) {\n      /**\n       * An array of of action rows in the message.\n       * <info>This property requires the {@link GatewayIntentBits.MessageContent} privileged intent\n       * in a guild for messages that do not mention the client.</info>\n       * @type {ActionRow[]}\n       */\n      this.components = data.components.map(c => createComponent(c));\n    } else {\n      this.components = this.components?.slice() ?? [];\n    }\n\n    if ('attachments' in data) {\n      /**\n       * A collection of attachments in the message - e.g. Pictures - mapped by their ids.\n       * <info>This property requires the {@link GatewayIntentBits.MessageContent} privileged intent\n       * in a guild for messages that do not mention the client.</info>\n       * @type {Collection<Snowflake, Attachment>}\n       */\n      this.attachments = new Collection();\n      if (data.attachments) {\n        for (const attachment of data.attachments) {\n          this.attachments.set(attachment.id, new Attachment(attachment));\n        }\n      }\n    } else {\n      this.attachments = new Collection(this.attachments);\n    }\n\n    if ('sticker_items' in data || 'stickers' in data) {\n      /**\n       * A collection of stickers in the message\n       * @type {Collection<Snowflake, Sticker>}\n       */\n      this.stickers = new Collection(\n        (data.sticker_items ?? data.stickers)?.map(s => [s.id, new Sticker(this.client, s)]),\n      );\n    } else {\n      this.stickers = new Collection(this.stickers);\n    }\n\n    if ('position' in data) {\n      /**\n       * A generally increasing integer (there may be gaps or duplicates) that represents\n       * the approximate position of the message in a thread.\n       * @type {?number}\n       */\n      this.position = data.position;\n    } else {\n      this.position ??= null;\n    }\n\n    // Discord sends null if the message has not been edited\n    if (data.edited_timestamp) {\n      /**\n       * The timestamp the message was last edited at (if applicable)\n       * @type {?number}\n       */\n      this.editedTimestamp = Date.parse(data.edited_timestamp);\n    } else {\n      this.editedTimestamp ??= null;\n    }\n\n    if ('reactions' in data) {\n      /**\n       * A manager of the reactions belonging to this message\n       * @type {ReactionManager}\n       */\n      this.reactions = new ReactionManager(this);\n      if (data.reactions?.length > 0) {\n        for (const reaction of data.reactions) {\n          this.reactions._add(reaction);\n        }\n      }\n    } else {\n      this.reactions ??= new ReactionManager(this);\n    }\n\n    if (!this.mentions) {\n      /**\n       * All valid mentions that the message contains\n       * @type {MessageMentions}\n       */\n      this.mentions = new Mentions(\n        this,\n        data.mentions,\n        data.mention_roles,\n        data.mention_everyone,\n        data.mention_channels,\n        data.referenced_message?.author,\n      );\n    } else {\n      this.mentions = new Mentions(\n        this,\n        data.mentions ?? this.mentions.users,\n        data.mention_roles ?? this.mentions.roles,\n        data.mention_everyone ?? this.mentions.everyone,\n        data.mention_channels ?? this.mentions.crosspostedChannels,\n        data.referenced_message?.author ?? this.mentions.repliedUser,\n      );\n    }\n\n    if ('webhook_id' in data) {\n      /**\n       * The id of the webhook that sent the message, if applicable\n       * @type {?Snowflake}\n       */\n      this.webhookId = data.webhook_id;\n    } else {\n      this.webhookId ??= null;\n    }\n\n    if ('application' in data) {\n      /**\n       * Supplemental application information for group activities\n       * @type {?ClientApplication}\n       */\n      this.groupActivityApplication = new ClientApplication(this.client, data.application);\n    } else {\n      this.groupActivityApplication ??= null;\n    }\n\n    if ('application_id' in data) {\n      /**\n       * The id of the application of the interaction that sent this message, if any\n       * @type {?Snowflake}\n       */\n      this.applicationId = data.application_id;\n    } else {\n      this.applicationId ??= null;\n    }\n\n    if ('activity' in data) {\n      /**\n       * Group activity\n       * @type {?MessageActivity}\n       */\n      this.activity = {\n        partyId: data.activity.party_id,\n        type: data.activity.type,\n      };\n    } else {\n      this.activity ??= null;\n    }\n\n    if ('thread' in data) {\n      this.client.channels._add(data.thread, this.guild);\n    }\n\n    if (this.member && data.member) {\n      this.member._patch(data.member);\n    } else if (data.member && this.guild && this.author) {\n      this.guild.members._add(Object.assign(data.member, { user: this.author }));\n    }\n\n    if ('flags' in data) {\n      /**\n       * Flags that are applied to the message\n       * @type {Readonly<MessageFlagsBitField>}\n       */\n      this.flags = new MessageFlagsBitField(data.flags).freeze();\n    } else {\n      this.flags = new MessageFlagsBitField(this.flags).freeze();\n    }\n\n    /**\n     * Reference data sent in a message that contains ids identifying the referenced message.\n     * This can be present in the following types of message:\n     * * Crossposted messages (`MessageFlags.Crossposted`)\n     * * {@link MessageType.ChannelFollowAdd}\n     * * {@link MessageType.ChannelPinnedMessage}\n     * * {@link MessageType.Reply}\n     * * {@link MessageType.ThreadStarterMessage}\n     * @see {@link https://discord.com/developers/docs/resources/channel#message-types}\n     * @typedef {Object} MessageReference\n     * @property {Snowflake} channelId The channel's id the message was referenced\n     * @property {?Snowflake} guildId The guild's id the message was referenced\n     * @property {?Snowflake} messageId The message's id that was referenced\n     */\n\n    if ('message_reference' in data) {\n      /**\n       * Message reference data\n       * @type {?MessageReference}\n       */\n      this.reference = {\n        channelId: data.message_reference.channel_id,\n        guildId: data.message_reference.guild_id,\n        messageId: data.message_reference.message_id,\n      };\n    } else {\n      this.reference ??= null;\n    }\n\n    if (data.referenced_message) {\n      this.channel?.messages._add({ guild_id: data.message_reference?.guild_id, ...data.referenced_message });\n    }\n\n    /**\n     * Partial data of the interaction that a message is a reply to\n     * @typedef {Object} MessageInteraction\n     * @property {Snowflake} id The interaction's id\n     * @property {InteractionType} type The type of the interaction\n     * @property {string} commandName The name of the interaction's application command,\n     * as well as the subcommand and subcommand group, where applicable\n     * @property {User} user The user that invoked the interaction\n     */\n\n    if (data.interaction) {\n      /**\n       * Partial data of the interaction that this message is a reply to\n       * @type {?MessageInteraction}\n       */\n      this.interaction = {\n        id: data.interaction.id,\n        type: data.interaction.type,\n        commandName: data.interaction.name,\n        user: this.client.users._add(data.interaction.user),\n      };\n    } else {\n      this.interaction ??= null;\n    }\n  }\n\n  /**\n   * The channel that the message was sent in\n   * @type {TextBasedChannels}\n   * @readonly\n   */\n  get channel() {\n    return this.client.channels.resolve(this.channelId);\n  }\n\n  /**\n   * Whether or not this message is a partial\n   * @type {boolean}\n   * @readonly\n   */\n  get partial() {\n    return typeof this.content !== 'string' || !this.author;\n  }\n\n  /**\n   * Represents the author of the message as a guild member.\n   * Only available if the message comes from a guild where the author is still a member\n   * @type {?GuildMember}\n   * @readonly\n   */\n  get member() {\n    return this.guild?.members.resolve(this.author) ?? null;\n  }\n\n  /**\n   * The time the message was sent at\n   * @type {Date}\n   * @readonly\n   */\n  get createdAt() {\n    return new Date(this.createdTimestamp);\n  }\n\n  /**\n   * The time the message was last edited at (if applicable)\n   * @type {?Date}\n   * @readonly\n   */\n  get editedAt() {\n    return this.editedTimestamp && new Date(this.editedTimestamp);\n  }\n\n  /**\n   * The guild the message was sent in (if in a guild channel)\n   * @type {?Guild}\n   * @readonly\n   */\n  get guild() {\n    return this.client.guilds.resolve(this.guildId) ?? this.channel?.guild ?? null;\n  }\n\n  /**\n   * Whether this message has a thread associated with it\n   * @type {boolean}\n   * @readonly\n   */\n  get hasThread() {\n    return this.flags.has(MessageFlags.HasThread);\n  }\n\n  /**\n   * The thread started by this message\n   * <info>This property is not suitable for checking whether a message has a thread,\n   * use {@link Message#hasThread} instead.</info>\n   * @type {?ThreadChannel}\n   * @readonly\n   */\n  get thread() {\n    return this.channel?.threads?.resolve(this.id) ?? null;\n  }\n\n  /**\n   * The URL to jump to this message\n   * @type {string}\n   * @readonly\n   */\n  get url() {\n    return this.inGuild() ? messageLink(this.channelId, this.id, this.guildId) : messageLink(this.channelId, this.id);\n  }\n\n  /**\n   * The message contents with all mentions replaced by the equivalent text.\n   * If mentions cannot be resolved to a name, the relevant mention in the message content will not be converted.\n   * @type {?string}\n   * @readonly\n   */\n  get cleanContent() {\n    // eslint-disable-next-line eqeqeq\n    return this.content != null ? cleanContent(this.content, this.channel) : null;\n  }\n\n  /**\n   * Creates a reaction collector.\n   * @param {ReactionCollectorOptions} [options={}] Options to send to the collector\n   * @returns {ReactionCollector}\n   * @example\n   * // Create a reaction collector\n   * const filter = (reaction, user) => reaction.emoji.name === '👌' && user.id === 'someId';\n   * const collector = message.createReactionCollector({ filter, time: 15_000 });\n   * collector.on('collect', r => console.log(`Collected ${r.emoji.name}`));\n   * collector.on('end', collected => console.log(`Collected ${collected.size} items`));\n   */\n  createReactionCollector(options = {}) {\n    return new ReactionCollector(this, options);\n  }\n\n  /**\n   * An object containing the same properties as CollectorOptions, but a few more:\n   * @typedef {ReactionCollectorOptions} AwaitReactionsOptions\n   * @property {string[]} [errors] Stop/end reasons that cause the promise to reject\n   */\n\n  /**\n   * Similar to createReactionCollector but in promise form.\n   * Resolves with a collection of reactions that pass the specified filter.\n   * @param {AwaitReactionsOptions} [options={}] Optional options to pass to the internal collector\n   * @returns {Promise<Collection<string | Snowflake, MessageReaction>>}\n   * @example\n   * // Create a reaction collector\n   * const filter = (reaction, user) => reaction.emoji.name === '👌' && user.id === 'someId'\n   * message.awaitReactions({ filter, time: 15_000 })\n   *   .then(collected => console.log(`Collected ${collected.size} reactions`))\n   *   .catch(console.error);\n   */\n  awaitReactions(options = {}) {\n    return new Promise((resolve, reject) => {\n      const collector = this.createReactionCollector(options);\n      collector.once('end', (reactions, reason) => {\n        if (options.errors?.includes(reason)) reject(reactions);\n        else resolve(reactions);\n      });\n    });\n  }\n\n  /**\n   * @typedef {CollectorOptions} MessageComponentCollectorOptions\n   * @property {ComponentType} [componentType] The type of component to listen for\n   * @property {number} [max] The maximum total amount of interactions to collect\n   * @property {number} [maxComponents] The maximum number of components to collect\n   * @property {number} [maxUsers] The maximum number of users to interact\n   */\n\n  /**\n   * Creates a message component interaction collector.\n   * @param {MessageComponentCollectorOptions} [options={}] Options to send to the collector\n   * @returns {InteractionCollector}\n   * @example\n   * // Create a message component interaction collector\n   * const filter = (interaction) => interaction.customId === 'button' && interaction.user.id === 'someId';\n   * const collector = message.createMessageComponentCollector({ filter, time: 15_000 });\n   * collector.on('collect', i => console.log(`Collected ${i.customId}`));\n   * collector.on('end', collected => console.log(`Collected ${collected.size} items`));\n   */\n  createMessageComponentCollector(options = {}) {\n    return new InteractionCollector(this.client, {\n      ...options,\n      interactionType: InteractionType.MessageComponent,\n      message: this,\n    });\n  }\n\n  /**\n   * An object containing the same properties as CollectorOptions, but a few more:\n   * @typedef {Object} AwaitMessageComponentOptions\n   * @property {CollectorFilter} [filter] The filter applied to this collector\n   * @property {number} [time] Time to wait for an interaction before rejecting\n   * @property {ComponentType} [componentType] The type of component interaction to collect\n   * @property {number} [idle] Time to wait without another message component interaction before ending the collector\n   * @property {boolean} [dispose] Whether to remove the message component interaction after collecting\n   * @property {InteractionResponse} [InteractionResponse] The interaction response to collect interactions from\n   */\n\n  /**\n   * Collects a single component interaction that passes the filter.\n   * The Promise will reject if the time expires.\n   * @param {AwaitMessageComponentOptions} [options={}] Options to pass to the internal collector\n   * @returns {Promise<MessageComponentInteraction>}\n   * @example\n   * // Collect a message component interaction\n   * const filter = (interaction) => interaction.customId === 'button' && interaction.user.id === 'someId';\n   * message.awaitMessageComponent({ filter, time: 15_000 })\n   *   .then(interaction => console.log(`${interaction.customId} was clicked!`))\n   *   .catch(console.error);\n   */\n  awaitMessageComponent(options = {}) {\n    const _options = { ...options, max: 1 };\n    return new Promise((resolve, reject) => {\n      const collector = this.createMessageComponentCollector(_options);\n      collector.once('end', (interactions, reason) => {\n        const interaction = interactions.first();\n        if (interaction) resolve(interaction);\n        else reject(new DiscordjsError(ErrorCodes.InteractionCollectorError, reason));\n      });\n    });\n  }\n\n  /**\n   * Whether the message is editable by the client user\n   * @type {boolean}\n   * @readonly\n   */\n  get editable() {\n    const precheck = Boolean(this.author.id === this.client.user.id && (!this.guild || this.channel?.viewable));\n    // Regardless of permissions thread messages cannot be edited if\n    // the thread is locked.\n    if (this.channel?.isThread()) {\n      return precheck && !this.channel.locked;\n    }\n    return precheck;\n  }\n\n  /**\n   * Whether the message is deletable by the client user\n   * @type {boolean}\n   * @readonly\n   */\n  get deletable() {\n    if (!this.guild) {\n      return this.author.id === this.client.user.id;\n    }\n    // DMChannel does not have viewable property, so check viewable after proved that message is on a guild.\n    if (!this.channel?.viewable) {\n      return false;\n    }\n\n    const permissions = this.channel?.permissionsFor(this.client.user);\n    if (!permissions) return false;\n    // This flag allows deleting even if timed out\n    if (permissions.has(PermissionFlagsBits.Administrator, false)) return true;\n\n    return Boolean(\n      this.author.id === this.client.user.id ||\n        (permissions.has(PermissionFlagsBits.ManageMessages, false) &&\n          this.guild.members.me.communicationDisabledUntilTimestamp < Date.now()),\n    );\n  }\n\n  /**\n   * Whether the message is bulk deletable by the client user\n   * @type {boolean}\n   * @readonly\n   * @example\n   * // Filter for bulk deletable messages\n   * channel.bulkDelete(messages.filter(message => message.bulkDeletable));\n   */\n  get bulkDeletable() {\n    const permissions = this.channel?.permissionsFor(this.client.user);\n    return (\n      (this.inGuild() &&\n        Date.now() - this.createdTimestamp < MaxBulkDeletableMessageAge &&\n        this.deletable &&\n        permissions?.has(PermissionFlagsBits.ManageMessages, false)) ??\n      false\n    );\n  }\n\n  /**\n   * Whether the message is pinnable by the client user\n   * @type {boolean}\n   * @readonly\n   */\n  get pinnable() {\n    const { channel } = this;\n    return Boolean(\n      !this.system &&\n        (!this.guild ||\n          (channel?.viewable &&\n            channel?.permissionsFor(this.client.user)?.has(PermissionFlagsBits.ManageMessages, false))),\n    );\n  }\n\n  /**\n   * Fetches the Message this crosspost/reply/pin-add references, if available to the client\n   * @returns {Promise<Message>}\n   */\n  async fetchReference() {\n    if (!this.reference) throw new DiscordjsError(ErrorCodes.MessageReferenceMissing);\n    const { channelId, messageId } = this.reference;\n    const channel = this.client.channels.resolve(channelId);\n    if (!channel) throw new DiscordjsError(ErrorCodes.GuildChannelResolve);\n    const message = await channel.messages.fetch(messageId);\n    return message;\n  }\n\n  /**\n   * Whether the message is crosspostable by the client user\n   * @type {boolean}\n   * @readonly\n   */\n  get crosspostable() {\n    const bitfield =\n      PermissionFlagsBits.SendMessages |\n      (this.author.id === this.client.user.id ? PermissionsBitField.DefaultBit : PermissionFlagsBits.ManageMessages);\n    const { channel } = this;\n    return Boolean(\n      channel?.type === ChannelType.GuildAnnouncement &&\n        !this.flags.has(MessageFlags.Crossposted) &&\n        this.type === MessageType.Default &&\n        channel.viewable &&\n        channel.permissionsFor(this.client.user)?.has(bitfield, false),\n    );\n  }\n\n  /**\n   * Edits the content of the message.\n   * @param {string|MessagePayload|MessageEditOptions} options The options to provide\n   * @returns {Promise<Message>}\n   * @example\n   * // Update the content of a message\n   * message.edit('This is my new content!')\n   *   .then(msg => console.log(`Updated the content of a message to ${msg.content}`))\n   *   .catch(console.error);\n   */\n  edit(options) {\n    if (!this.channel) return Promise.reject(new DiscordjsError(ErrorCodes.ChannelNotCached));\n    return this.channel.messages.edit(this, options);\n  }\n\n  /**\n   * Publishes a message in an announcement channel to all channels following it.\n   * @returns {Promise<Message>}\n   * @example\n   * // Crosspost a message\n   * if (message.channel.type === ChannelType.GuildAnnouncement) {\n   *   message.crosspost()\n   *     .then(() => console.log('Crossposted message'))\n   *     .catch(console.error);\n   * }\n   */\n  crosspost() {\n    if (!this.channel) return Promise.reject(new DiscordjsError(ErrorCodes.ChannelNotCached));\n    return this.channel.messages.crosspost(this.id);\n  }\n\n  /**\n   * Pins this message to the channel's pinned messages.\n   * @param {string} [reason] Reason for pinning\n   * @returns {Promise<Message>}\n   * @example\n   * // Pin a message\n   * message.pin()\n   *   .then(console.log)\n   *   .catch(console.error)\n   */\n  async pin(reason) {\n    if (!this.channel) throw new DiscordjsError(ErrorCodes.ChannelNotCached);\n    await this.channel.messages.pin(this.id, reason);\n    return this;\n  }\n\n  /**\n   * Unpins this message from the channel's pinned messages.\n   * @param {string} [reason] Reason for unpinning\n   * @returns {Promise<Message>}\n   * @example\n   * // Unpin a message\n   * message.unpin()\n   *   .then(console.log)\n   *   .catch(console.error)\n   */\n  async unpin(reason) {\n    if (!this.channel) throw new DiscordjsError(ErrorCodes.ChannelNotCached);\n    await this.channel.messages.unpin(this.id, reason);\n    return this;\n  }\n\n  /**\n   * Adds a reaction to the message.\n   * @param {EmojiIdentifierResolvable} emoji The emoji to react with\n   * @returns {Promise<MessageReaction>}\n   * @example\n   * // React to a message with a unicode emoji\n   * message.react('🤔')\n   *   .then(console.log)\n   *   .catch(console.error);\n   * @example\n   * // React to a message with a custom emoji\n   * message.react(message.guild.emojis.cache.get('123456789012345678'))\n   *   .then(console.log)\n   *   .catch(console.error);\n   */\n  async react(emoji) {\n    if (!this.channel) throw new DiscordjsError(ErrorCodes.ChannelNotCached);\n    await this.channel.messages.react(this.id, emoji);\n\n    return this.client.actions.MessageReactionAdd.handle(\n      {\n        user: this.client.user,\n        channel: this.channel,\n        message: this,\n        emoji: resolvePartialEmoji(emoji),\n      },\n      true,\n    ).reaction;\n  }\n\n  /**\n   * Deletes the message.\n   * @returns {Promise<Message>}\n   * @example\n   * // Delete a message\n   * message.delete()\n   *   .then(msg => console.log(`Deleted message from ${msg.author.username}`))\n   *   .catch(console.error);\n   */\n  async delete() {\n    if (!this.channel) throw new DiscordjsError(ErrorCodes.ChannelNotCached);\n    await this.channel.messages.delete(this.id);\n    return this;\n  }\n\n  /**\n   * Options provided when sending a message as an inline reply.\n   * @typedef {BaseMessageCreateOptions} MessageReplyOptions\n   * @property {boolean} [failIfNotExists=this.client.options.failIfNotExists] Whether to error if the referenced\n   * message does not exist (creates a standard message in this case when false)\n   * @property {StickerResolvable[]} [stickers=[]] Stickers to send in the message\n   */\n\n  /**\n   * Send an inline reply to this message.\n   * @param {string|MessagePayload|MessageReplyOptions} options The options to provide\n   * @returns {Promise<Message>}\n   * @example\n   * // Reply to a message\n   * message.reply('This is a reply!')\n   *   .then(() => console.log(`Replied to message \"${message.content}\"`))\n   *   .catch(console.error);\n   */\n  reply(options) {\n    if (!this.channel) return Promise.reject(new DiscordjsError(ErrorCodes.ChannelNotCached));\n    let data;\n\n    if (options instanceof MessagePayload) {\n      data = options;\n    } else {\n      data = MessagePayload.create(this, options, {\n        reply: {\n          messageReference: this,\n          failIfNotExists: options?.failIfNotExists ?? this.client.options.failIfNotExists,\n        },\n      });\n    }\n    return this.channel.send(data);\n  }\n\n  /**\n   * Options for starting a thread on a message.\n   * @typedef {Object} StartThreadOptions\n   * @property {string} name The name of the new thread\n   * @property {ThreadAutoArchiveDuration} [autoArchiveDuration=this.channel.defaultAutoArchiveDuration] The amount of\n   * time after which the thread should automatically archive in case of no recent activity\n   * @property {string} [reason] Reason for creating the thread\n   * @property {number} [rateLimitPerUser] The rate limit per user (slowmode) for the thread in seconds\n   */\n\n  /**\n   * Create a new public thread from this message\n   * @see GuildTextThreadManager#create\n   * @param {StartThreadOptions} [options] Options for starting a thread on this message\n   * @returns {Promise<ThreadChannel>}\n   */\n  startThread(options = {}) {\n    if (!this.channel) return Promise.reject(new DiscordjsError(ErrorCodes.ChannelNotCached));\n    if (![ChannelType.GuildText, ChannelType.GuildAnnouncement].includes(this.channel.type)) {\n      return Promise.reject(new DiscordjsError(ErrorCodes.MessageThreadParent));\n    }\n    if (this.hasThread) return Promise.reject(new DiscordjsError(ErrorCodes.MessageExistingThread));\n    return this.channel.threads.create({ ...options, startMessage: this });\n  }\n\n  /**\n   * Fetch this message.\n   * @param {boolean} [force=true] Whether to skip the cache check and request the API\n   * @returns {Promise<Message>}\n   */\n  fetch(force = true) {\n    if (!this.channel) return Promise.reject(new DiscordjsError(ErrorCodes.ChannelNotCached));\n    return this.channel.messages.fetch({ message: this.id, force });\n  }\n\n  /**\n   * Fetches the webhook used to create this message.\n   * @returns {Promise<?Webhook>}\n   */\n  fetchWebhook() {\n    if (!this.webhookId) return Promise.reject(new DiscordjsError(ErrorCodes.WebhookMessage));\n    if (this.webhookId === this.applicationId) return Promise.reject(new DiscordjsError(ErrorCodes.WebhookApplication));\n    return this.client.fetchWebhook(this.webhookId);\n  }\n\n  /**\n   * Suppresses or unsuppresses embeds on a message.\n   * @param {boolean} [suppress=true] If the embeds should be suppressed or not\n   * @returns {Promise<Message>}\n   */\n  suppressEmbeds(suppress = true) {\n    const flags = new MessageFlagsBitField(this.flags.bitfield);\n\n    if (suppress) {\n      flags.add(MessageFlags.SuppressEmbeds);\n    } else {\n      flags.remove(MessageFlags.SuppressEmbeds);\n    }\n\n    return this.edit({ flags });\n  }\n\n  /**\n   * Removes the attachments from this message.\n   * @returns {Promise<Message>}\n   */\n  removeAttachments() {\n    return this.edit({ attachments: [] });\n  }\n\n  /**\n   * Resolves a component by a custom id.\n   * @param {string} customId The custom id to resolve against\n   * @returns {?MessageActionRowComponent}\n   */\n  resolveComponent(customId) {\n    return this.components.flatMap(row => row.components).find(component => component.customId === customId) ?? null;\n  }\n\n  /**\n   * Used mainly internally. Whether two messages are identical in properties. If you want to compare messages\n   * without checking all the properties, use `message.id === message2.id`, which is much more efficient. This\n   * method allows you to see if there are differences in content, embeds, attachments, nonce and tts properties.\n   * @param {Message} message The message to compare it to\n   * @param {APIMessage} rawData Raw data passed through the WebSocket about this message\n   * @returns {boolean}\n   */\n  equals(message, rawData) {\n    if (!message) return false;\n    const embedUpdate = !message.author && !message.attachments;\n    if (embedUpdate) return this.id === message.id && this.embeds.length === message.embeds.length;\n\n    let equal =\n      this.id === message.id &&\n      this.author.id === message.author.id &&\n      this.content === message.content &&\n      this.tts === message.tts &&\n      this.nonce === message.nonce &&\n      this.embeds.length === message.embeds.length &&\n      this.attachments.length === message.attachments.length;\n\n    if (equal && rawData) {\n      equal =\n        this.mentions.everyone === message.mentions.everyone &&\n        this.createdTimestamp === Date.parse(rawData.timestamp) &&\n        this.editedTimestamp === Date.parse(rawData.edited_timestamp);\n    }\n\n    return equal;\n  }\n\n  /**\n   * Whether this message is from a guild.\n   * @returns {boolean}\n   */\n  inGuild() {\n    return Boolean(this.guildId);\n  }\n\n  /**\n   * When concatenated with a string, this automatically concatenates the message's content instead of the object.\n   * @returns {string}\n   * @example\n   * // Logs: Message: This is a message!\n   * console.log(`Message: ${message}`);\n   */\n  toString() {\n    return this.content;\n  }\n\n  toJSON() {\n    return super.toJSON({\n      channel: 'channelId',\n      author: 'authorId',\n      groupActivityApplication: 'groupActivityApplicationId',\n      guild: 'guildId',\n      cleanContent: true,\n      member: false,\n      reactions: false,\n    });\n  }\n}\n\nexports.Message = Message;\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}