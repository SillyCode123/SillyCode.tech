{"ast":null,"code":"'use strict';\n\nconst EventEmitter = require('node:events');\nconst path = require('node:path');\nconst process = require('node:process');\nconst {\n  setTimeout,\n  clearTimeout\n} = require('node:timers');\nconst {\n  setTimeout: sleep\n} = require('node:timers/promises');\nconst {\n  DiscordjsError,\n  ErrorCodes\n} = require('../errors');\nconst ShardEvents = require('../util/ShardEvents');\nconst {\n  makeError,\n  makePlainError\n} = require('../util/Util');\nlet childProcess = null;\nlet Worker = null;\n\n/**\n * A self-contained shard created by the {@link ShardingManager}. Each one has a {@link ChildProcess} that contains\n * an instance of the bot and its {@link Client}. When its child process/worker exits for any reason, the shard will\n * spawn a new one to replace it as necessary.\n * @extends {EventEmitter}\n */\nclass Shard extends EventEmitter {\n  constructor(manager, id) {\n    super();\n    if (manager.mode === 'process') childProcess = require('node:child_process');else if (manager.mode === 'worker') Worker = require('node:worker_threads').Worker;\n\n    /**\n     * Manager that created the shard\n     * @type {ShardingManager}\n     */\n    this.manager = manager;\n\n    /**\n     * The shard's id in the manager\n     * @type {number}\n     */\n    this.id = id;\n\n    /**\n     * Arguments for the shard's process (only when {@link ShardingManager#mode} is `process`)\n     * @type {string[]}\n     */\n    this.args = manager.shardArgs ?? [];\n\n    /**\n     * Arguments for the shard's process executable (only when {@link ShardingManager#mode} is `process`)\n     * @type {string[]}\n     */\n    this.execArgv = manager.execArgv;\n\n    /**\n     * Environment variables for the shard's process, or workerData for the shard's worker\n     * @type {Object}\n     */\n    this.env = Object.assign({}, process.env, {\n      SHARDING_MANAGER: true,\n      SHARDS: this.id,\n      SHARD_COUNT: this.manager.totalShards,\n      DISCORD_TOKEN: this.manager.token\n    });\n\n    /**\n     * Whether the shard's {@link Client} is ready\n     * @type {boolean}\n     */\n    this.ready = false;\n\n    /**\n     * Process of the shard (if {@link ShardingManager#mode} is `process`)\n     * @type {?ChildProcess}\n     */\n    this.process = null;\n\n    /**\n     * Worker of the shard (if {@link ShardingManager#mode} is `worker`)\n     * @type {?Worker}\n     */\n    this.worker = null;\n\n    /**\n     * Ongoing promises for calls to {@link Shard#eval}, mapped by the `script` they were called with\n     * @type {Map<string, Promise>}\n     * @private\n     */\n    this._evals = new Map();\n\n    /**\n     * Ongoing promises for calls to {@link Shard#fetchClientValue}, mapped by the `prop` they were called with\n     * @type {Map<string, Promise>}\n     * @private\n     */\n    this._fetches = new Map();\n\n    /**\n     * Listener function for the {@link ChildProcess}' `exit` event\n     * @type {Function}\n     * @private\n     */\n    this._exitListener = null;\n  }\n\n  /**\n   * Forks a child process or creates a worker thread for the shard.\n   * <warn>You should not need to call this manually.</warn>\n   * @param {number} [timeout=30000] The amount in milliseconds to wait until the {@link Client} has become ready\n   * before resolving (`-1` or `Infinity` for no wait)\n   * @returns {Promise<ChildProcess>}\n   */\n  spawn() {\n    let timeout = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 30_000;\n    if (this.process) throw new DiscordjsError(ErrorCodes.ShardingProcessExists, this.id);\n    if (this.worker) throw new DiscordjsError(ErrorCodes.ShardingWorkerExists, this.id);\n    this._exitListener = this._handleExit.bind(this, undefined, timeout);\n    if (this.manager.mode === 'process') {\n      this.process = childProcess.fork(path.resolve(this.manager.file), this.args, {\n        env: this.env,\n        execArgv: this.execArgv\n      }).on('message', this._handleMessage.bind(this)).on('exit', this._exitListener);\n    } else if (this.manager.mode === 'worker') {\n      this.worker = new Worker(path.resolve(this.manager.file), {\n        workerData: this.env\n      }).on('message', this._handleMessage.bind(this)).on('exit', this._exitListener);\n    }\n    this._evals.clear();\n    this._fetches.clear();\n    const child = this.process ?? this.worker;\n\n    /**\n     * Emitted upon the creation of the shard's child process/worker.\n     * @event Shard#spawn\n     * @param {ChildProcess|Worker} process Child process/worker that was created\n     */\n    this.emit(ShardEvents.Spawn, child);\n    if (timeout === -1 || timeout === Infinity) return Promise.resolve(child);\n    return new Promise((resolve, reject) => {\n      const cleanup = () => {\n        clearTimeout(spawnTimeoutTimer);\n        this.off('ready', onReady);\n        this.off('disconnect', onDisconnect);\n        this.off('death', onDeath);\n      };\n      const onReady = () => {\n        cleanup();\n        resolve(child);\n      };\n      const onDisconnect = () => {\n        cleanup();\n        reject(new DiscordjsError(ErrorCodes.ShardingReadyDisconnected, this.id));\n      };\n      const onDeath = () => {\n        cleanup();\n        reject(new DiscordjsError(ErrorCodes.ShardingReadyDied, this.id));\n      };\n      const onTimeout = () => {\n        cleanup();\n        reject(new DiscordjsError(ErrorCodes.ShardingReadyTimeout, this.id));\n      };\n      const spawnTimeoutTimer = setTimeout(onTimeout, timeout);\n      this.once('ready', onReady);\n      this.once('disconnect', onDisconnect);\n      this.once('death', onDeath);\n    });\n  }\n\n  /**\n   * Immediately kills the shard's process/worker and does not restart it.\n   */\n  kill() {\n    if (this.process) {\n      this.process.removeListener('exit', this._exitListener);\n      this.process.kill();\n    } else {\n      this.worker.removeListener('exit', this._exitListener);\n      this.worker.terminate();\n    }\n    this._handleExit(false);\n  }\n\n  /**\n   * Options used to respawn a shard.\n   * @typedef {Object} ShardRespawnOptions\n   * @property {number} [delay=500] How long to wait between killing the process/worker and\n   * restarting it (in milliseconds)\n   * @property {number} [timeout=30000] The amount in milliseconds to wait until the {@link Client}\n   * has become ready before resolving (`-1` or `Infinity` for no wait)\n   */\n\n  /**\n   * Kills and restarts the shard's process/worker.\n   * @param {ShardRespawnOptions} [options] Options for respawning the shard\n   * @returns {Promise<ChildProcess>}\n   */\n  async respawn() {\n    let {\n      delay = 500,\n      timeout = 30_000\n    } = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    this.kill();\n    if (delay > 0) await sleep(delay);\n    return this.spawn(timeout);\n  }\n\n  /**\n   * Sends a message to the shard's process/worker.\n   * @param {*} message Message to send to the shard\n   * @returns {Promise<Shard>}\n   */\n  send(message) {\n    return new Promise((resolve, reject) => {\n      if (this.process) {\n        this.process.send(message, err => {\n          if (err) reject(err);else resolve(this);\n        });\n      } else {\n        this.worker.postMessage(message);\n        resolve(this);\n      }\n    });\n  }\n\n  /**\n   * Fetches a client property value of the shard.\n   * @param {string} prop Name of the client property to get, using periods for nesting\n   * @returns {Promise<*>}\n   * @example\n   * shard.fetchClientValue('guilds.cache.size')\n   *   .then(count => console.log(`${count} guilds in shard ${shard.id}`))\n   *   .catch(console.error);\n   */\n  fetchClientValue(prop) {\n    // Shard is dead (maybe respawning), don't cache anything and error immediately\n    if (!this.process && !this.worker) {\n      return Promise.reject(new DiscordjsError(ErrorCodes.ShardingNoChildExists, this.id));\n    }\n\n    // Cached promise from previous call\n    if (this._fetches.has(prop)) return this._fetches.get(prop);\n    const promise = new Promise((resolve, reject) => {\n      const child = this.process ?? this.worker;\n      const listener = message => {\n        if (message?._fetchProp !== prop) return;\n        child.removeListener('message', listener);\n        this.decrementMaxListeners(child);\n        this._fetches.delete(prop);\n        if (!message._error) resolve(message._result);else reject(makeError(message._error));\n      };\n      this.incrementMaxListeners(child);\n      child.on('message', listener);\n      this.send({\n        _fetchProp: prop\n      }).catch(err => {\n        child.removeListener('message', listener);\n        this.decrementMaxListeners(child);\n        this._fetches.delete(prop);\n        reject(err);\n      });\n    });\n    this._fetches.set(prop, promise);\n    return promise;\n  }\n\n  /**\n   * Evaluates a script or function on the shard, in the context of the {@link Client}.\n   * @param {string|Function} script JavaScript to run on the shard\n   * @param {*} [context] The context for the eval\n   * @returns {Promise<*>} Result of the script execution\n   */\n  eval(script, context) {\n    // Stringify the script if it's a Function\n    const _eval = typeof script === 'function' ? `(${script})(this, ${JSON.stringify(context)})` : script;\n\n    // Shard is dead (maybe respawning), don't cache anything and error immediately\n    if (!this.process && !this.worker) {\n      return Promise.reject(new DiscordjsError(ErrorCodes.ShardingNoChildExists, this.id));\n    }\n\n    // Cached promise from previous call\n    if (this._evals.has(_eval)) return this._evals.get(_eval);\n    const promise = new Promise((resolve, reject) => {\n      const child = this.process ?? this.worker;\n      const listener = message => {\n        if (message?._eval !== _eval) return;\n        child.removeListener('message', listener);\n        this.decrementMaxListeners(child);\n        this._evals.delete(_eval);\n        if (!message._error) resolve(message._result);else reject(makeError(message._error));\n      };\n      this.incrementMaxListeners(child);\n      child.on('message', listener);\n      this.send({\n        _eval\n      }).catch(err => {\n        child.removeListener('message', listener);\n        this.decrementMaxListeners(child);\n        this._evals.delete(_eval);\n        reject(err);\n      });\n    });\n    this._evals.set(_eval, promise);\n    return promise;\n  }\n\n  /**\n   * Handles a message received from the child process/worker.\n   * @param {*} message Message received\n   * @private\n   */\n  _handleMessage(message) {\n    if (message) {\n      // Shard is ready\n      if (message._ready) {\n        this.ready = true;\n        /**\n         * Emitted upon the shard's {@link Client#event:shardReady} event.\n         * @event Shard#ready\n         */\n        this.emit(ShardEvents.Ready);\n        return;\n      }\n\n      // Shard has disconnected\n      if (message._disconnect) {\n        this.ready = false;\n        /**\n         * Emitted upon the shard's {@link Client#event:shardDisconnect} event.\n         * @event Shard#disconnect\n         */\n        this.emit(ShardEvents.Disconnect);\n        return;\n      }\n\n      // Shard is attempting to reconnect\n      if (message._reconnecting) {\n        this.ready = false;\n        /**\n         * Emitted upon the shard's {@link Client#event:shardReconnecting} event.\n         * @event Shard#reconnecting\n         */\n        this.emit(ShardEvents.Reconnecting);\n        return;\n      }\n\n      // Shard is requesting a property fetch\n      if (message._sFetchProp) {\n        const resp = {\n          _sFetchProp: message._sFetchProp,\n          _sFetchPropShard: message._sFetchPropShard\n        };\n        this.manager.fetchClientValues(message._sFetchProp, message._sFetchPropShard).then(results => this.send({\n          ...resp,\n          _result: results\n        }), err => this.send({\n          ...resp,\n          _error: makePlainError(err)\n        }));\n        return;\n      }\n\n      // Shard is requesting an eval broadcast\n      if (message._sEval) {\n        const resp = {\n          _sEval: message._sEval,\n          _sEvalShard: message._sEvalShard\n        };\n        this.manager._performOnShards('eval', [message._sEval], message._sEvalShard).then(results => this.send({\n          ...resp,\n          _result: results\n        }), err => this.send({\n          ...resp,\n          _error: makePlainError(err)\n        }));\n        return;\n      }\n\n      // Shard is requesting a respawn of all shards\n      if (message._sRespawnAll) {\n        const {\n          shardDelay,\n          respawnDelay,\n          timeout\n        } = message._sRespawnAll;\n        this.manager.respawnAll({\n          shardDelay,\n          respawnDelay,\n          timeout\n        }).catch(() => {\n          // Do nothing\n        });\n        return;\n      }\n    }\n\n    /**\n     * Emitted upon receiving a message from the child process/worker.\n     * @event Shard#message\n     * @param {*} message Message that was received\n     */\n    this.emit(ShardEvents.Message, message);\n  }\n\n  /**\n   * Handles the shard's process/worker exiting.\n   * @param {boolean} [respawn=this.manager.respawn] Whether to spawn the shard again\n   * @param {number} [timeout] The amount in milliseconds to wait until the {@link Client}\n   * has become ready (`-1` or `Infinity` for no wait)\n   * @private\n   */\n  _handleExit() {\n    let respawn = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.manager.respawn;\n    let timeout = arguments.length > 1 ? arguments[1] : undefined;\n    /**\n     * Emitted upon the shard's child process/worker exiting.\n     * @event Shard#death\n     * @param {ChildProcess|Worker} process Child process/worker that exited\n     */\n    this.emit(ShardEvents.Death, this.process ?? this.worker);\n    this.ready = false;\n    this.process = null;\n    this.worker = null;\n    this._evals.clear();\n    this._fetches.clear();\n    if (respawn) this.spawn(timeout).catch(err => this.emit(ShardEvents.Error, err));\n  }\n\n  /**\n   * Increments max listeners by one for a given emitter, if they are not zero.\n   * @param {EventEmitter|process} emitter The emitter that emits the events.\n   * @private\n   */\n  incrementMaxListeners(emitter) {\n    const maxListeners = emitter.getMaxListeners();\n    if (maxListeners !== 0) {\n      emitter.setMaxListeners(maxListeners + 1);\n    }\n  }\n\n  /**\n   * Decrements max listeners by one for a given emitter, if they are not zero.\n   * @param {EventEmitter|process} emitter The emitter that emits the events.\n   * @private\n   */\n  decrementMaxListeners(emitter) {\n    const maxListeners = emitter.getMaxListeners();\n    if (maxListeners !== 0) {\n      emitter.setMaxListeners(maxListeners - 1);\n    }\n  }\n}\nmodule.exports = Shard;","map":{"version":3,"names":["EventEmitter","require","path","process","setTimeout","clearTimeout","sleep","DiscordjsError","ErrorCodes","ShardEvents","makeError","makePlainError","childProcess","Worker","Shard","constructor","manager","id","mode","args","shardArgs","execArgv","env","Object","assign","SHARDING_MANAGER","SHARDS","SHARD_COUNT","totalShards","DISCORD_TOKEN","token","ready","worker","_evals","Map","_fetches","_exitListener","spawn","timeout","ShardingProcessExists","ShardingWorkerExists","_handleExit","bind","undefined","fork","resolve","file","on","_handleMessage","workerData","clear","child","emit","Spawn","Infinity","Promise","reject","cleanup","spawnTimeoutTimer","off","onReady","onDisconnect","onDeath","ShardingReadyDisconnected","ShardingReadyDied","onTimeout","ShardingReadyTimeout","once","kill","removeListener","terminate","respawn","delay","send","message","err","postMessage","fetchClientValue","prop","ShardingNoChildExists","has","get","promise","listener","_fetchProp","decrementMaxListeners","delete","_error","_result","incrementMaxListeners","catch","set","eval","script","context","_eval","JSON","stringify","_ready","Ready","_disconnect","Disconnect","_reconnecting","Reconnecting","_sFetchProp","resp","_sFetchPropShard","fetchClientValues","then","results","_sEval","_sEvalShard","_performOnShards","_sRespawnAll","shardDelay","respawnDelay","respawnAll","Message","Death","Error","emitter","maxListeners","getMaxListeners","setMaxListeners","module","exports"],"sources":["J:/Coding/Projekts/Web/JavaScript/sillcode.tech/node_modules/discord.js/src/sharding/Shard.js"],"sourcesContent":["'use strict';\n\nconst EventEmitter = require('node:events');\nconst path = require('node:path');\nconst process = require('node:process');\nconst { setTimeout, clearTimeout } = require('node:timers');\nconst { setTimeout: sleep } = require('node:timers/promises');\nconst { DiscordjsError, ErrorCodes } = require('../errors');\nconst ShardEvents = require('../util/ShardEvents');\nconst { makeError, makePlainError } = require('../util/Util');\nlet childProcess = null;\nlet Worker = null;\n\n/**\n * A self-contained shard created by the {@link ShardingManager}. Each one has a {@link ChildProcess} that contains\n * an instance of the bot and its {@link Client}. When its child process/worker exits for any reason, the shard will\n * spawn a new one to replace it as necessary.\n * @extends {EventEmitter}\n */\nclass Shard extends EventEmitter {\n  constructor(manager, id) {\n    super();\n\n    if (manager.mode === 'process') childProcess = require('node:child_process');\n    else if (manager.mode === 'worker') Worker = require('node:worker_threads').Worker;\n\n    /**\n     * Manager that created the shard\n     * @type {ShardingManager}\n     */\n    this.manager = manager;\n\n    /**\n     * The shard's id in the manager\n     * @type {number}\n     */\n    this.id = id;\n\n    /**\n     * Arguments for the shard's process (only when {@link ShardingManager#mode} is `process`)\n     * @type {string[]}\n     */\n    this.args = manager.shardArgs ?? [];\n\n    /**\n     * Arguments for the shard's process executable (only when {@link ShardingManager#mode} is `process`)\n     * @type {string[]}\n     */\n    this.execArgv = manager.execArgv;\n\n    /**\n     * Environment variables for the shard's process, or workerData for the shard's worker\n     * @type {Object}\n     */\n    this.env = Object.assign({}, process.env, {\n      SHARDING_MANAGER: true,\n      SHARDS: this.id,\n      SHARD_COUNT: this.manager.totalShards,\n      DISCORD_TOKEN: this.manager.token,\n    });\n\n    /**\n     * Whether the shard's {@link Client} is ready\n     * @type {boolean}\n     */\n    this.ready = false;\n\n    /**\n     * Process of the shard (if {@link ShardingManager#mode} is `process`)\n     * @type {?ChildProcess}\n     */\n    this.process = null;\n\n    /**\n     * Worker of the shard (if {@link ShardingManager#mode} is `worker`)\n     * @type {?Worker}\n     */\n    this.worker = null;\n\n    /**\n     * Ongoing promises for calls to {@link Shard#eval}, mapped by the `script` they were called with\n     * @type {Map<string, Promise>}\n     * @private\n     */\n    this._evals = new Map();\n\n    /**\n     * Ongoing promises for calls to {@link Shard#fetchClientValue}, mapped by the `prop` they were called with\n     * @type {Map<string, Promise>}\n     * @private\n     */\n    this._fetches = new Map();\n\n    /**\n     * Listener function for the {@link ChildProcess}' `exit` event\n     * @type {Function}\n     * @private\n     */\n    this._exitListener = null;\n  }\n\n  /**\n   * Forks a child process or creates a worker thread for the shard.\n   * <warn>You should not need to call this manually.</warn>\n   * @param {number} [timeout=30000] The amount in milliseconds to wait until the {@link Client} has become ready\n   * before resolving (`-1` or `Infinity` for no wait)\n   * @returns {Promise<ChildProcess>}\n   */\n  spawn(timeout = 30_000) {\n    if (this.process) throw new DiscordjsError(ErrorCodes.ShardingProcessExists, this.id);\n    if (this.worker) throw new DiscordjsError(ErrorCodes.ShardingWorkerExists, this.id);\n\n    this._exitListener = this._handleExit.bind(this, undefined, timeout);\n\n    if (this.manager.mode === 'process') {\n      this.process = childProcess\n        .fork(path.resolve(this.manager.file), this.args, {\n          env: this.env,\n          execArgv: this.execArgv,\n        })\n        .on('message', this._handleMessage.bind(this))\n        .on('exit', this._exitListener);\n    } else if (this.manager.mode === 'worker') {\n      this.worker = new Worker(path.resolve(this.manager.file), { workerData: this.env })\n        .on('message', this._handleMessage.bind(this))\n        .on('exit', this._exitListener);\n    }\n\n    this._evals.clear();\n    this._fetches.clear();\n\n    const child = this.process ?? this.worker;\n\n    /**\n     * Emitted upon the creation of the shard's child process/worker.\n     * @event Shard#spawn\n     * @param {ChildProcess|Worker} process Child process/worker that was created\n     */\n    this.emit(ShardEvents.Spawn, child);\n\n    if (timeout === -1 || timeout === Infinity) return Promise.resolve(child);\n    return new Promise((resolve, reject) => {\n      const cleanup = () => {\n        clearTimeout(spawnTimeoutTimer);\n        this.off('ready', onReady);\n        this.off('disconnect', onDisconnect);\n        this.off('death', onDeath);\n      };\n\n      const onReady = () => {\n        cleanup();\n        resolve(child);\n      };\n\n      const onDisconnect = () => {\n        cleanup();\n        reject(new DiscordjsError(ErrorCodes.ShardingReadyDisconnected, this.id));\n      };\n\n      const onDeath = () => {\n        cleanup();\n        reject(new DiscordjsError(ErrorCodes.ShardingReadyDied, this.id));\n      };\n\n      const onTimeout = () => {\n        cleanup();\n        reject(new DiscordjsError(ErrorCodes.ShardingReadyTimeout, this.id));\n      };\n\n      const spawnTimeoutTimer = setTimeout(onTimeout, timeout);\n      this.once('ready', onReady);\n      this.once('disconnect', onDisconnect);\n      this.once('death', onDeath);\n    });\n  }\n\n  /**\n   * Immediately kills the shard's process/worker and does not restart it.\n   */\n  kill() {\n    if (this.process) {\n      this.process.removeListener('exit', this._exitListener);\n      this.process.kill();\n    } else {\n      this.worker.removeListener('exit', this._exitListener);\n      this.worker.terminate();\n    }\n\n    this._handleExit(false);\n  }\n\n  /**\n   * Options used to respawn a shard.\n   * @typedef {Object} ShardRespawnOptions\n   * @property {number} [delay=500] How long to wait between killing the process/worker and\n   * restarting it (in milliseconds)\n   * @property {number} [timeout=30000] The amount in milliseconds to wait until the {@link Client}\n   * has become ready before resolving (`-1` or `Infinity` for no wait)\n   */\n\n  /**\n   * Kills and restarts the shard's process/worker.\n   * @param {ShardRespawnOptions} [options] Options for respawning the shard\n   * @returns {Promise<ChildProcess>}\n   */\n  async respawn({ delay = 500, timeout = 30_000 } = {}) {\n    this.kill();\n    if (delay > 0) await sleep(delay);\n    return this.spawn(timeout);\n  }\n\n  /**\n   * Sends a message to the shard's process/worker.\n   * @param {*} message Message to send to the shard\n   * @returns {Promise<Shard>}\n   */\n  send(message) {\n    return new Promise((resolve, reject) => {\n      if (this.process) {\n        this.process.send(message, err => {\n          if (err) reject(err);\n          else resolve(this);\n        });\n      } else {\n        this.worker.postMessage(message);\n        resolve(this);\n      }\n    });\n  }\n\n  /**\n   * Fetches a client property value of the shard.\n   * @param {string} prop Name of the client property to get, using periods for nesting\n   * @returns {Promise<*>}\n   * @example\n   * shard.fetchClientValue('guilds.cache.size')\n   *   .then(count => console.log(`${count} guilds in shard ${shard.id}`))\n   *   .catch(console.error);\n   */\n  fetchClientValue(prop) {\n    // Shard is dead (maybe respawning), don't cache anything and error immediately\n    if (!this.process && !this.worker) {\n      return Promise.reject(new DiscordjsError(ErrorCodes.ShardingNoChildExists, this.id));\n    }\n\n    // Cached promise from previous call\n    if (this._fetches.has(prop)) return this._fetches.get(prop);\n\n    const promise = new Promise((resolve, reject) => {\n      const child = this.process ?? this.worker;\n\n      const listener = message => {\n        if (message?._fetchProp !== prop) return;\n        child.removeListener('message', listener);\n        this.decrementMaxListeners(child);\n        this._fetches.delete(prop);\n        if (!message._error) resolve(message._result);\n        else reject(makeError(message._error));\n      };\n\n      this.incrementMaxListeners(child);\n      child.on('message', listener);\n\n      this.send({ _fetchProp: prop }).catch(err => {\n        child.removeListener('message', listener);\n        this.decrementMaxListeners(child);\n        this._fetches.delete(prop);\n        reject(err);\n      });\n    });\n\n    this._fetches.set(prop, promise);\n    return promise;\n  }\n\n  /**\n   * Evaluates a script or function on the shard, in the context of the {@link Client}.\n   * @param {string|Function} script JavaScript to run on the shard\n   * @param {*} [context] The context for the eval\n   * @returns {Promise<*>} Result of the script execution\n   */\n  eval(script, context) {\n    // Stringify the script if it's a Function\n    const _eval = typeof script === 'function' ? `(${script})(this, ${JSON.stringify(context)})` : script;\n\n    // Shard is dead (maybe respawning), don't cache anything and error immediately\n    if (!this.process && !this.worker) {\n      return Promise.reject(new DiscordjsError(ErrorCodes.ShardingNoChildExists, this.id));\n    }\n\n    // Cached promise from previous call\n    if (this._evals.has(_eval)) return this._evals.get(_eval);\n\n    const promise = new Promise((resolve, reject) => {\n      const child = this.process ?? this.worker;\n\n      const listener = message => {\n        if (message?._eval !== _eval) return;\n        child.removeListener('message', listener);\n        this.decrementMaxListeners(child);\n        this._evals.delete(_eval);\n        if (!message._error) resolve(message._result);\n        else reject(makeError(message._error));\n      };\n\n      this.incrementMaxListeners(child);\n      child.on('message', listener);\n\n      this.send({ _eval }).catch(err => {\n        child.removeListener('message', listener);\n        this.decrementMaxListeners(child);\n        this._evals.delete(_eval);\n        reject(err);\n      });\n    });\n\n    this._evals.set(_eval, promise);\n    return promise;\n  }\n\n  /**\n   * Handles a message received from the child process/worker.\n   * @param {*} message Message received\n   * @private\n   */\n  _handleMessage(message) {\n    if (message) {\n      // Shard is ready\n      if (message._ready) {\n        this.ready = true;\n        /**\n         * Emitted upon the shard's {@link Client#event:shardReady} event.\n         * @event Shard#ready\n         */\n        this.emit(ShardEvents.Ready);\n        return;\n      }\n\n      // Shard has disconnected\n      if (message._disconnect) {\n        this.ready = false;\n        /**\n         * Emitted upon the shard's {@link Client#event:shardDisconnect} event.\n         * @event Shard#disconnect\n         */\n        this.emit(ShardEvents.Disconnect);\n        return;\n      }\n\n      // Shard is attempting to reconnect\n      if (message._reconnecting) {\n        this.ready = false;\n        /**\n         * Emitted upon the shard's {@link Client#event:shardReconnecting} event.\n         * @event Shard#reconnecting\n         */\n        this.emit(ShardEvents.Reconnecting);\n        return;\n      }\n\n      // Shard is requesting a property fetch\n      if (message._sFetchProp) {\n        const resp = { _sFetchProp: message._sFetchProp, _sFetchPropShard: message._sFetchPropShard };\n        this.manager.fetchClientValues(message._sFetchProp, message._sFetchPropShard).then(\n          results => this.send({ ...resp, _result: results }),\n          err => this.send({ ...resp, _error: makePlainError(err) }),\n        );\n        return;\n      }\n\n      // Shard is requesting an eval broadcast\n      if (message._sEval) {\n        const resp = { _sEval: message._sEval, _sEvalShard: message._sEvalShard };\n        this.manager._performOnShards('eval', [message._sEval], message._sEvalShard).then(\n          results => this.send({ ...resp, _result: results }),\n          err => this.send({ ...resp, _error: makePlainError(err) }),\n        );\n        return;\n      }\n\n      // Shard is requesting a respawn of all shards\n      if (message._sRespawnAll) {\n        const { shardDelay, respawnDelay, timeout } = message._sRespawnAll;\n        this.manager.respawnAll({ shardDelay, respawnDelay, timeout }).catch(() => {\n          // Do nothing\n        });\n        return;\n      }\n    }\n\n    /**\n     * Emitted upon receiving a message from the child process/worker.\n     * @event Shard#message\n     * @param {*} message Message that was received\n     */\n    this.emit(ShardEvents.Message, message);\n  }\n\n  /**\n   * Handles the shard's process/worker exiting.\n   * @param {boolean} [respawn=this.manager.respawn] Whether to spawn the shard again\n   * @param {number} [timeout] The amount in milliseconds to wait until the {@link Client}\n   * has become ready (`-1` or `Infinity` for no wait)\n   * @private\n   */\n  _handleExit(respawn = this.manager.respawn, timeout) {\n    /**\n     * Emitted upon the shard's child process/worker exiting.\n     * @event Shard#death\n     * @param {ChildProcess|Worker} process Child process/worker that exited\n     */\n    this.emit(ShardEvents.Death, this.process ?? this.worker);\n\n    this.ready = false;\n    this.process = null;\n    this.worker = null;\n    this._evals.clear();\n    this._fetches.clear();\n\n    if (respawn) this.spawn(timeout).catch(err => this.emit(ShardEvents.Error, err));\n  }\n\n  /**\n   * Increments max listeners by one for a given emitter, if they are not zero.\n   * @param {EventEmitter|process} emitter The emitter that emits the events.\n   * @private\n   */\n  incrementMaxListeners(emitter) {\n    const maxListeners = emitter.getMaxListeners();\n    if (maxListeners !== 0) {\n      emitter.setMaxListeners(maxListeners + 1);\n    }\n  }\n\n  /**\n   * Decrements max listeners by one for a given emitter, if they are not zero.\n   * @param {EventEmitter|process} emitter The emitter that emits the events.\n   * @private\n   */\n  decrementMaxListeners(emitter) {\n    const maxListeners = emitter.getMaxListeners();\n    if (maxListeners !== 0) {\n      emitter.setMaxListeners(maxListeners - 1);\n    }\n  }\n}\n\nmodule.exports = Shard;\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}