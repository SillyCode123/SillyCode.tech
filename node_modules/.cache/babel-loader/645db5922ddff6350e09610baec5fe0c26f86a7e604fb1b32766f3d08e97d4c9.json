{"ast":null,"code":"'use strict';\n\nconst EventEmitter = require('node:events');\nconst {\n  setImmediate\n} = require('node:timers');\nconst {\n  setTimeout: sleep\n} = require('node:timers/promises');\nconst {\n  Collection\n} = require('@discordjs/collection');\nconst {\n  GatewayCloseCodes,\n  GatewayDispatchEvents,\n  Routes\n} = require('discord-api-types/v10');\nconst WebSocketShard = require('./WebSocketShard');\nconst PacketHandlers = require('./handlers');\nconst {\n  DiscordjsError,\n  ErrorCodes\n} = require('../../errors');\nconst Events = require('../../util/Events');\nconst Status = require('../../util/Status');\nconst WebSocketShardEvents = require('../../util/WebSocketShardEvents');\nconst BeforeReadyWhitelist = [GatewayDispatchEvents.Ready, GatewayDispatchEvents.Resumed, GatewayDispatchEvents.GuildCreate, GatewayDispatchEvents.GuildDelete, GatewayDispatchEvents.GuildMembersChunk, GatewayDispatchEvents.GuildMemberAdd, GatewayDispatchEvents.GuildMemberRemove];\nconst unrecoverableErrorCodeMap = {\n  [GatewayCloseCodes.AuthenticationFailed]: ErrorCodes.TokenInvalid,\n  [GatewayCloseCodes.InvalidShard]: ErrorCodes.ShardingInvalid,\n  [GatewayCloseCodes.ShardingRequired]: ErrorCodes.ShardingRequired,\n  [GatewayCloseCodes.InvalidIntents]: ErrorCodes.InvalidIntents,\n  [GatewayCloseCodes.DisallowedIntents]: ErrorCodes.DisallowedIntents\n};\nconst UNRESUMABLE_CLOSE_CODES = [1000, GatewayCloseCodes.AlreadyAuthenticated, GatewayCloseCodes.InvalidSeq];\n\n/**\n * The WebSocket manager for this client.\n * <info>This class forwards raw dispatch events,\n * read more about it here {@link https://discord.com/developers/docs/topics/gateway}</info>\n * @extends {EventEmitter}\n */\nclass WebSocketManager extends EventEmitter {\n  constructor(client) {\n    super();\n\n    /**\n     * The client that instantiated this WebSocketManager\n     * @type {Client}\n     * @readonly\n     * @name WebSocketManager#client\n     */\n    Object.defineProperty(this, 'client', {\n      value: client\n    });\n\n    /**\n     * The gateway this manager uses\n     * @type {?string}\n     */\n    this.gateway = null;\n\n    /**\n     * The amount of shards this manager handles\n     * @private\n     * @type {number}\n     */\n    this.totalShards = this.client.options.shards.length;\n\n    /**\n     * A collection of all shards this manager handles\n     * @type {Collection<number, WebSocketShard>}\n     */\n    this.shards = new Collection();\n\n    /**\n     * An array of shards to be connected or that need to reconnect\n     * @type {Set<WebSocketShard>}\n     * @private\n     * @name WebSocketManager#shardQueue\n     */\n    Object.defineProperty(this, 'shardQueue', {\n      value: new Set(),\n      writable: true\n    });\n\n    /**\n     * An array of queued events before this WebSocketManager became ready\n     * @type {Object[]}\n     * @private\n     * @name WebSocketManager#packetQueue\n     */\n    Object.defineProperty(this, 'packetQueue', {\n      value: []\n    });\n\n    /**\n     * The current status of this WebSocketManager\n     * @type {Status}\n     */\n    this.status = Status.Idle;\n\n    /**\n     * If this manager was destroyed. It will prevent shards from reconnecting\n     * @type {boolean}\n     * @private\n     */\n    this.destroyed = false;\n\n    /**\n     * If this manager is currently reconnecting one or multiple shards\n     * @type {boolean}\n     * @private\n     */\n    this.reconnecting = false;\n  }\n\n  /**\n   * The average ping of all WebSocketShards\n   * @type {number}\n   * @readonly\n   */\n  get ping() {\n    const sum = this.shards.reduce((a, b) => a + b.ping, 0);\n    return sum / this.shards.size;\n  }\n\n  /**\n   * Emits a debug message.\n   * @param {string} message The debug message\n   * @param {?WebSocketShard} [shard] The shard that emitted this message, if any\n   * @private\n   */\n  debug(message, shard) {\n    this.client.emit(Events.Debug, `[WS => ${shard ? `Shard ${shard.id}` : 'Manager'}] ${message}`);\n  }\n\n  /**\n   * Connects this manager to the gateway.\n   * @private\n   */\n  async connect() {\n    const invalidToken = new DiscordjsError(ErrorCodes.TokenInvalid);\n    const {\n      url: gatewayURL,\n      shards: recommendedShards,\n      session_start_limit: sessionStartLimit\n    } = await this.client.rest.get(Routes.gatewayBot()).catch(error => {\n      throw error.status === 401 ? invalidToken : error;\n    });\n    const {\n      total,\n      remaining\n    } = sessionStartLimit;\n    this.debug(`Fetched Gateway Information\n    URL: ${gatewayURL}\n    Recommended Shards: ${recommendedShards}`);\n    this.debug(`Session Limit Information\n    Total: ${total}\n    Remaining: ${remaining}`);\n    this.gateway = `${gatewayURL}/`;\n    let {\n      shards\n    } = this.client.options;\n    if (shards === 'auto') {\n      this.debug(`Using the recommended shard count provided by Discord: ${recommendedShards}`);\n      this.totalShards = this.client.options.shardCount = recommendedShards;\n      shards = this.client.options.shards = Array.from({\n        length: recommendedShards\n      }, (_, i) => i);\n    }\n    this.totalShards = shards.length;\n    this.debug(`Spawning shards: ${shards.join(', ')}`);\n    this.shardQueue = new Set(shards.map(id => new WebSocketShard(this, id)));\n    return this.createShards();\n  }\n\n  /**\n   * Handles the creation of a shard.\n   * @returns {Promise<boolean>}\n   * @private\n   */\n  async createShards() {\n    // If we don't have any shards to handle, return\n    if (!this.shardQueue.size) return false;\n    const [shard] = this.shardQueue;\n    this.shardQueue.delete(shard);\n    if (!shard.eventsAttached) {\n      shard.on(WebSocketShardEvents.AllReady, unavailableGuilds => {\n        /**\n         * Emitted when a shard turns ready.\n         * @event Client#shardReady\n         * @param {number} id The shard id that turned ready\n         * @param {?Set<Snowflake>} unavailableGuilds Set of unavailable guild ids, if any\n         */\n        this.client.emit(Events.ShardReady, shard.id, unavailableGuilds);\n        if (!this.shardQueue.size) this.reconnecting = false;\n        this.checkShardsReady();\n      });\n      shard.on(WebSocketShardEvents.Close, event => {\n        if (event.code === 1_000 ? this.destroyed : event.code in unrecoverableErrorCodeMap) {\n          /**\n           * Emitted when a shard's WebSocket disconnects and will no longer reconnect.\n           * @event Client#shardDisconnect\n           * @param {CloseEvent} event The WebSocket close event\n           * @param {number} id The shard id that disconnected\n           */\n          this.client.emit(Events.ShardDisconnect, event, shard.id);\n          this.debug(GatewayCloseCodes[event.code], shard);\n          return;\n        }\n        if (UNRESUMABLE_CLOSE_CODES.includes(event.code)) {\n          // These event codes cannot be resumed\n          shard.sessionId = null;\n        }\n\n        /**\n         * Emitted when a shard is attempting to reconnect or re-identify.\n         * @event Client#shardReconnecting\n         * @param {number} id The shard id that is attempting to reconnect\n         */\n        this.client.emit(Events.ShardReconnecting, shard.id);\n        this.shardQueue.add(shard);\n        if (shard.sessionId) this.debug(`Session id is present, attempting an immediate reconnect...`, shard);\n        this.reconnect();\n      });\n      shard.on(WebSocketShardEvents.InvalidSession, () => {\n        this.client.emit(Events.ShardReconnecting, shard.id);\n      });\n      shard.on(WebSocketShardEvents.Destroyed, () => {\n        this.debug('Shard was destroyed but no WebSocket connection was present! Reconnecting...', shard);\n        this.client.emit(Events.ShardReconnecting, shard.id);\n        this.shardQueue.add(shard);\n        this.reconnect();\n      });\n      shard.eventsAttached = true;\n    }\n    this.shards.set(shard.id, shard);\n    try {\n      await shard.connect();\n    } catch (error) {\n      if (error?.code && error.code in unrecoverableErrorCodeMap) {\n        throw new DiscordjsError(unrecoverableErrorCodeMap[error.code]);\n        // Undefined if session is invalid, error event for regular closes\n      } else if (!error || error.code) {\n        this.debug('Failed to connect to the gateway, requeueing...', shard);\n        this.shardQueue.add(shard);\n      } else {\n        throw error;\n      }\n    }\n    // If we have more shards, add a 5s delay\n    if (this.shardQueue.size) {\n      this.debug(`Shard Queue Size: ${this.shardQueue.size}; continuing in 5 seconds...`);\n      await sleep(5_000);\n      return this.createShards();\n    }\n    return true;\n  }\n\n  /**\n   * Handles reconnects for this manager.\n   * @private\n   * @returns {Promise<boolean>}\n   */\n  async reconnect() {\n    if (this.reconnecting || this.status !== Status.Ready) return false;\n    this.reconnecting = true;\n    try {\n      await this.createShards();\n    } catch (error) {\n      this.debug(`Couldn't reconnect or fetch information about the gateway. ${error}`);\n      if (error.httpStatus !== 401) {\n        this.debug(`Possible network error occurred. Retrying in 5s...`);\n        await sleep(5_000);\n        this.reconnecting = false;\n        return this.reconnect();\n      }\n      // If we get an error at this point, it means we cannot reconnect anymore\n      if (this.client.listenerCount(Events.Invalidated)) {\n        /**\n         * Emitted when the client's session becomes invalidated.\n         * You are expected to handle closing the process gracefully and preventing a boot loop\n         * if you are listening to this event.\n         * @event Client#invalidated\n         */\n        this.client.emit(Events.Invalidated);\n        // Destroy just the shards. This means you have to handle the cleanup yourself\n        this.destroy();\n      } else {\n        this.client.destroy();\n      }\n    } finally {\n      this.reconnecting = false;\n    }\n    return true;\n  }\n\n  /**\n   * Broadcasts a packet to every shard this manager handles.\n   * @param {Object} packet The packet to send\n   * @private\n   */\n  broadcast(packet) {\n    for (const shard of this.shards.values()) shard.send(packet);\n  }\n\n  /**\n   * Destroys this manager and all its shards.\n   * @private\n   */\n  destroy() {\n    if (this.destroyed) return;\n    // TODO: Make a util for getting a stack\n    this.debug(`Manager was destroyed. Called by:\\n${new Error().stack}`);\n    this.destroyed = true;\n    this.shardQueue.clear();\n    for (const shard of this.shards.values()) shard.destroy({\n      closeCode: 1_000,\n      reset: true,\n      emit: false,\n      log: false\n    });\n  }\n\n  /**\n   * Processes a packet and queues it if this WebSocketManager is not ready.\n   * @param {Object} [packet] The packet to be handled\n   * @param {WebSocketShard} [shard] The shard that will handle this packet\n   * @returns {boolean}\n   * @private\n   */\n  handlePacket(packet, shard) {\n    if (packet && this.status !== Status.Ready) {\n      if (!BeforeReadyWhitelist.includes(packet.t)) {\n        this.packetQueue.push({\n          packet,\n          shard\n        });\n        return false;\n      }\n    }\n    if (this.packetQueue.length) {\n      const item = this.packetQueue.shift();\n      setImmediate(() => {\n        this.handlePacket(item.packet, item.shard);\n      }).unref();\n    }\n    if (packet && PacketHandlers[packet.t]) {\n      PacketHandlers[packet.t](this.client, packet, shard);\n    }\n    return true;\n  }\n\n  /**\n   * Checks whether the client is ready to be marked as ready.\n   * @private\n   */\n  checkShardsReady() {\n    if (this.status === Status.Ready) return;\n    if (this.shards.size !== this.totalShards || this.shards.some(s => s.status !== Status.Ready)) {\n      return;\n    }\n    this.triggerClientReady();\n  }\n\n  /**\n   * Causes the client to be marked as ready and emits the ready event.\n   * @private\n   */\n  triggerClientReady() {\n    this.status = Status.Ready;\n    this.client.readyTimestamp = Date.now();\n\n    /**\n     * Emitted when the client becomes ready to start working.\n     * @event Client#ready\n     * @param {Client} client The client\n     */\n    this.client.emit(Events.ClientReady, this.client);\n    this.handlePacket();\n  }\n}\nmodule.exports = WebSocketManager;","map":{"version":3,"names":["EventEmitter","require","setImmediate","setTimeout","sleep","Collection","GatewayCloseCodes","GatewayDispatchEvents","Routes","WebSocketShard","PacketHandlers","DiscordjsError","ErrorCodes","Events","Status","WebSocketShardEvents","BeforeReadyWhitelist","Ready","Resumed","GuildCreate","GuildDelete","GuildMembersChunk","GuildMemberAdd","GuildMemberRemove","unrecoverableErrorCodeMap","AuthenticationFailed","TokenInvalid","InvalidShard","ShardingInvalid","ShardingRequired","InvalidIntents","DisallowedIntents","UNRESUMABLE_CLOSE_CODES","AlreadyAuthenticated","InvalidSeq","WebSocketManager","constructor","client","Object","defineProperty","value","gateway","totalShards","options","shards","length","Set","writable","status","Idle","destroyed","reconnecting","ping","sum","reduce","a","b","size","debug","message","shard","emit","Debug","id","connect","invalidToken","url","gatewayURL","recommendedShards","session_start_limit","sessionStartLimit","rest","get","gatewayBot","catch","error","total","remaining","shardCount","Array","from","_","i","join","shardQueue","map","createShards","delete","eventsAttached","on","AllReady","unavailableGuilds","ShardReady","checkShardsReady","Close","event","code","ShardDisconnect","includes","sessionId","ShardReconnecting","add","reconnect","InvalidSession","Destroyed","set","httpStatus","listenerCount","Invalidated","destroy","broadcast","packet","values","send","Error","stack","clear","closeCode","reset","log","handlePacket","t","packetQueue","push","item","shift","unref","some","s","triggerClientReady","readyTimestamp","Date","now","ClientReady","module","exports"],"sources":["J:/Coding/Projekts/Web/JavaScript/sillcode.tech/node_modules/discord.js/src/client/websocket/WebSocketManager.js"],"sourcesContent":["'use strict';\n\nconst EventEmitter = require('node:events');\nconst { setImmediate } = require('node:timers');\nconst { setTimeout: sleep } = require('node:timers/promises');\nconst { Collection } = require('@discordjs/collection');\nconst { GatewayCloseCodes, GatewayDispatchEvents, Routes } = require('discord-api-types/v10');\nconst WebSocketShard = require('./WebSocketShard');\nconst PacketHandlers = require('./handlers');\nconst { DiscordjsError, ErrorCodes } = require('../../errors');\nconst Events = require('../../util/Events');\nconst Status = require('../../util/Status');\nconst WebSocketShardEvents = require('../../util/WebSocketShardEvents');\n\nconst BeforeReadyWhitelist = [\n  GatewayDispatchEvents.Ready,\n  GatewayDispatchEvents.Resumed,\n  GatewayDispatchEvents.GuildCreate,\n  GatewayDispatchEvents.GuildDelete,\n  GatewayDispatchEvents.GuildMembersChunk,\n  GatewayDispatchEvents.GuildMemberAdd,\n  GatewayDispatchEvents.GuildMemberRemove,\n];\n\nconst unrecoverableErrorCodeMap = {\n  [GatewayCloseCodes.AuthenticationFailed]: ErrorCodes.TokenInvalid,\n  [GatewayCloseCodes.InvalidShard]: ErrorCodes.ShardingInvalid,\n  [GatewayCloseCodes.ShardingRequired]: ErrorCodes.ShardingRequired,\n  [GatewayCloseCodes.InvalidIntents]: ErrorCodes.InvalidIntents,\n  [GatewayCloseCodes.DisallowedIntents]: ErrorCodes.DisallowedIntents,\n};\n\nconst UNRESUMABLE_CLOSE_CODES = [1000, GatewayCloseCodes.AlreadyAuthenticated, GatewayCloseCodes.InvalidSeq];\n\n/**\n * The WebSocket manager for this client.\n * <info>This class forwards raw dispatch events,\n * read more about it here {@link https://discord.com/developers/docs/topics/gateway}</info>\n * @extends {EventEmitter}\n */\nclass WebSocketManager extends EventEmitter {\n  constructor(client) {\n    super();\n\n    /**\n     * The client that instantiated this WebSocketManager\n     * @type {Client}\n     * @readonly\n     * @name WebSocketManager#client\n     */\n    Object.defineProperty(this, 'client', { value: client });\n\n    /**\n     * The gateway this manager uses\n     * @type {?string}\n     */\n    this.gateway = null;\n\n    /**\n     * The amount of shards this manager handles\n     * @private\n     * @type {number}\n     */\n    this.totalShards = this.client.options.shards.length;\n\n    /**\n     * A collection of all shards this manager handles\n     * @type {Collection<number, WebSocketShard>}\n     */\n    this.shards = new Collection();\n\n    /**\n     * An array of shards to be connected or that need to reconnect\n     * @type {Set<WebSocketShard>}\n     * @private\n     * @name WebSocketManager#shardQueue\n     */\n    Object.defineProperty(this, 'shardQueue', { value: new Set(), writable: true });\n\n    /**\n     * An array of queued events before this WebSocketManager became ready\n     * @type {Object[]}\n     * @private\n     * @name WebSocketManager#packetQueue\n     */\n    Object.defineProperty(this, 'packetQueue', { value: [] });\n\n    /**\n     * The current status of this WebSocketManager\n     * @type {Status}\n     */\n    this.status = Status.Idle;\n\n    /**\n     * If this manager was destroyed. It will prevent shards from reconnecting\n     * @type {boolean}\n     * @private\n     */\n    this.destroyed = false;\n\n    /**\n     * If this manager is currently reconnecting one or multiple shards\n     * @type {boolean}\n     * @private\n     */\n    this.reconnecting = false;\n  }\n\n  /**\n   * The average ping of all WebSocketShards\n   * @type {number}\n   * @readonly\n   */\n  get ping() {\n    const sum = this.shards.reduce((a, b) => a + b.ping, 0);\n    return sum / this.shards.size;\n  }\n\n  /**\n   * Emits a debug message.\n   * @param {string} message The debug message\n   * @param {?WebSocketShard} [shard] The shard that emitted this message, if any\n   * @private\n   */\n  debug(message, shard) {\n    this.client.emit(Events.Debug, `[WS => ${shard ? `Shard ${shard.id}` : 'Manager'}] ${message}`);\n  }\n\n  /**\n   * Connects this manager to the gateway.\n   * @private\n   */\n  async connect() {\n    const invalidToken = new DiscordjsError(ErrorCodes.TokenInvalid);\n    const {\n      url: gatewayURL,\n      shards: recommendedShards,\n      session_start_limit: sessionStartLimit,\n    } = await this.client.rest.get(Routes.gatewayBot()).catch(error => {\n      throw error.status === 401 ? invalidToken : error;\n    });\n\n    const { total, remaining } = sessionStartLimit;\n\n    this.debug(`Fetched Gateway Information\n    URL: ${gatewayURL}\n    Recommended Shards: ${recommendedShards}`);\n\n    this.debug(`Session Limit Information\n    Total: ${total}\n    Remaining: ${remaining}`);\n\n    this.gateway = `${gatewayURL}/`;\n\n    let { shards } = this.client.options;\n\n    if (shards === 'auto') {\n      this.debug(`Using the recommended shard count provided by Discord: ${recommendedShards}`);\n      this.totalShards = this.client.options.shardCount = recommendedShards;\n      shards = this.client.options.shards = Array.from({ length: recommendedShards }, (_, i) => i);\n    }\n\n    this.totalShards = shards.length;\n    this.debug(`Spawning shards: ${shards.join(', ')}`);\n    this.shardQueue = new Set(shards.map(id => new WebSocketShard(this, id)));\n\n    return this.createShards();\n  }\n\n  /**\n   * Handles the creation of a shard.\n   * @returns {Promise<boolean>}\n   * @private\n   */\n  async createShards() {\n    // If we don't have any shards to handle, return\n    if (!this.shardQueue.size) return false;\n\n    const [shard] = this.shardQueue;\n\n    this.shardQueue.delete(shard);\n\n    if (!shard.eventsAttached) {\n      shard.on(WebSocketShardEvents.AllReady, unavailableGuilds => {\n        /**\n         * Emitted when a shard turns ready.\n         * @event Client#shardReady\n         * @param {number} id The shard id that turned ready\n         * @param {?Set<Snowflake>} unavailableGuilds Set of unavailable guild ids, if any\n         */\n        this.client.emit(Events.ShardReady, shard.id, unavailableGuilds);\n\n        if (!this.shardQueue.size) this.reconnecting = false;\n        this.checkShardsReady();\n      });\n\n      shard.on(WebSocketShardEvents.Close, event => {\n        if (event.code === 1_000 ? this.destroyed : event.code in unrecoverableErrorCodeMap) {\n          /**\n           * Emitted when a shard's WebSocket disconnects and will no longer reconnect.\n           * @event Client#shardDisconnect\n           * @param {CloseEvent} event The WebSocket close event\n           * @param {number} id The shard id that disconnected\n           */\n          this.client.emit(Events.ShardDisconnect, event, shard.id);\n          this.debug(GatewayCloseCodes[event.code], shard);\n          return;\n        }\n\n        if (UNRESUMABLE_CLOSE_CODES.includes(event.code)) {\n          // These event codes cannot be resumed\n          shard.sessionId = null;\n        }\n\n        /**\n         * Emitted when a shard is attempting to reconnect or re-identify.\n         * @event Client#shardReconnecting\n         * @param {number} id The shard id that is attempting to reconnect\n         */\n        this.client.emit(Events.ShardReconnecting, shard.id);\n\n        this.shardQueue.add(shard);\n\n        if (shard.sessionId) this.debug(`Session id is present, attempting an immediate reconnect...`, shard);\n        this.reconnect();\n      });\n\n      shard.on(WebSocketShardEvents.InvalidSession, () => {\n        this.client.emit(Events.ShardReconnecting, shard.id);\n      });\n\n      shard.on(WebSocketShardEvents.Destroyed, () => {\n        this.debug('Shard was destroyed but no WebSocket connection was present! Reconnecting...', shard);\n\n        this.client.emit(Events.ShardReconnecting, shard.id);\n\n        this.shardQueue.add(shard);\n        this.reconnect();\n      });\n\n      shard.eventsAttached = true;\n    }\n\n    this.shards.set(shard.id, shard);\n\n    try {\n      await shard.connect();\n    } catch (error) {\n      if (error?.code && error.code in unrecoverableErrorCodeMap) {\n        throw new DiscordjsError(unrecoverableErrorCodeMap[error.code]);\n        // Undefined if session is invalid, error event for regular closes\n      } else if (!error || error.code) {\n        this.debug('Failed to connect to the gateway, requeueing...', shard);\n        this.shardQueue.add(shard);\n      } else {\n        throw error;\n      }\n    }\n    // If we have more shards, add a 5s delay\n    if (this.shardQueue.size) {\n      this.debug(`Shard Queue Size: ${this.shardQueue.size}; continuing in 5 seconds...`);\n      await sleep(5_000);\n      return this.createShards();\n    }\n\n    return true;\n  }\n\n  /**\n   * Handles reconnects for this manager.\n   * @private\n   * @returns {Promise<boolean>}\n   */\n  async reconnect() {\n    if (this.reconnecting || this.status !== Status.Ready) return false;\n    this.reconnecting = true;\n    try {\n      await this.createShards();\n    } catch (error) {\n      this.debug(`Couldn't reconnect or fetch information about the gateway. ${error}`);\n      if (error.httpStatus !== 401) {\n        this.debug(`Possible network error occurred. Retrying in 5s...`);\n        await sleep(5_000);\n        this.reconnecting = false;\n        return this.reconnect();\n      }\n      // If we get an error at this point, it means we cannot reconnect anymore\n      if (this.client.listenerCount(Events.Invalidated)) {\n        /**\n         * Emitted when the client's session becomes invalidated.\n         * You are expected to handle closing the process gracefully and preventing a boot loop\n         * if you are listening to this event.\n         * @event Client#invalidated\n         */\n        this.client.emit(Events.Invalidated);\n        // Destroy just the shards. This means you have to handle the cleanup yourself\n        this.destroy();\n      } else {\n        this.client.destroy();\n      }\n    } finally {\n      this.reconnecting = false;\n    }\n    return true;\n  }\n\n  /**\n   * Broadcasts a packet to every shard this manager handles.\n   * @param {Object} packet The packet to send\n   * @private\n   */\n  broadcast(packet) {\n    for (const shard of this.shards.values()) shard.send(packet);\n  }\n\n  /**\n   * Destroys this manager and all its shards.\n   * @private\n   */\n  destroy() {\n    if (this.destroyed) return;\n    // TODO: Make a util for getting a stack\n    this.debug(`Manager was destroyed. Called by:\\n${new Error().stack}`);\n    this.destroyed = true;\n    this.shardQueue.clear();\n    for (const shard of this.shards.values()) shard.destroy({ closeCode: 1_000, reset: true, emit: false, log: false });\n  }\n\n  /**\n   * Processes a packet and queues it if this WebSocketManager is not ready.\n   * @param {Object} [packet] The packet to be handled\n   * @param {WebSocketShard} [shard] The shard that will handle this packet\n   * @returns {boolean}\n   * @private\n   */\n  handlePacket(packet, shard) {\n    if (packet && this.status !== Status.Ready) {\n      if (!BeforeReadyWhitelist.includes(packet.t)) {\n        this.packetQueue.push({ packet, shard });\n        return false;\n      }\n    }\n\n    if (this.packetQueue.length) {\n      const item = this.packetQueue.shift();\n      setImmediate(() => {\n        this.handlePacket(item.packet, item.shard);\n      }).unref();\n    }\n\n    if (packet && PacketHandlers[packet.t]) {\n      PacketHandlers[packet.t](this.client, packet, shard);\n    }\n\n    return true;\n  }\n\n  /**\n   * Checks whether the client is ready to be marked as ready.\n   * @private\n   */\n  checkShardsReady() {\n    if (this.status === Status.Ready) return;\n    if (this.shards.size !== this.totalShards || this.shards.some(s => s.status !== Status.Ready)) {\n      return;\n    }\n\n    this.triggerClientReady();\n  }\n\n  /**\n   * Causes the client to be marked as ready and emits the ready event.\n   * @private\n   */\n  triggerClientReady() {\n    this.status = Status.Ready;\n\n    this.client.readyTimestamp = Date.now();\n\n    /**\n     * Emitted when the client becomes ready to start working.\n     * @event Client#ready\n     * @param {Client} client The client\n     */\n    this.client.emit(Events.ClientReady, this.client);\n\n    this.handlePacket();\n  }\n}\n\nmodule.exports = WebSocketManager;\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}