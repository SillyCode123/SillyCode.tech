{"ast":null,"code":"'use strict';\n\nconst {\n  Collection\n} = require('@discordjs/collection');\nconst {\n  FormattingPatterns\n} = require('discord-api-types/v10');\nconst {\n  flatten\n} = require('../util/Util');\n\n/**\n * Keeps track of mentions in a {@link Message}.\n */\nclass MessageMentions {\n  /**\n   * A regular expression that matches `@everyone` and `@here`.\n   * The `mention` group property is present on the `exec` result of this expression.\n   * @type {RegExp}\n   * @memberof MessageMentions\n   */\n  static EveryonePattern = /@(?<mention>everyone|here)/;\n\n  /**\n   * A regular expression that matches user mentions like `<@81440962496172032>`.\n   * The `id` group property is present on the `exec` result of this expression.\n   * @type {RegExp}\n   * @memberof MessageMentions\n   */\n  static UsersPattern = FormattingPatterns.UserWithOptionalNickname;\n\n  /**\n   * A regular expression that matches role mentions like `<@&297577916114403338>`.\n   * The `id` group property is present on the `exec` result of this expression.\n   * @type {RegExp}\n   * @memberof MessageMentions\n   */\n  static RolesPattern = FormattingPatterns.Role;\n\n  /**\n   * A regular expression that matches channel mentions like `<#222079895583457280>`.\n   * The `id` group property is present on the `exec` result of this expression.\n   * @type {RegExp}\n   * @memberof MessageMentions\n   */\n  static ChannelsPattern = FormattingPatterns.Channel;\n\n  /**\n   * A global regular expression variant of {@link MessageMentions.ChannelsPattern}.\n   * @type {RegExp}\n   * @memberof MessageMentions\n   * @private\n   */\n  static GlobalChannelsPattern = new RegExp(this.ChannelsPattern.source, 'g');\n\n  /**\n   * A global regular expression variant of {@link MessageMentions.UsersPattern}.\n   * @type {RegExp}\n   * @memberof MessageMentions\n   * @private\n   */\n  static GlobalUsersPattern = new RegExp(this.UsersPattern.source, 'g');\n  constructor(message, users, roles, everyone, crosspostedChannels, repliedUser) {\n    /**\n     * The client the message is from\n     * @type {Client}\n     * @readonly\n     */\n    Object.defineProperty(this, 'client', {\n      value: message.client\n    });\n\n    /**\n     * The guild the message is in\n     * @type {?Guild}\n     * @readonly\n     */\n    Object.defineProperty(this, 'guild', {\n      value: message.guild\n    });\n\n    /**\n     * The initial message content\n     * @type {string}\n     * @readonly\n     * @private\n     */\n    Object.defineProperty(this, '_content', {\n      value: message.content\n    });\n\n    /**\n     * Whether `@everyone` or `@here` were mentioned\n     * @type {boolean}\n     */\n    this.everyone = Boolean(everyone);\n    if (users) {\n      if (users instanceof Collection) {\n        /**\n         * Any users that were mentioned\n         * <info>Order as received from the API, not as they appear in the message content</info>\n         * @type {Collection<Snowflake, User>}\n         */\n        this.users = new Collection(users);\n      } else {\n        this.users = new Collection();\n        for (const mention of users) {\n          if (mention.member && message.guild) {\n            message.guild.members._add(Object.assign(mention.member, {\n              user: mention\n            }));\n          }\n          const user = message.client.users._add(mention);\n          this.users.set(user.id, user);\n        }\n      }\n    } else {\n      this.users = new Collection();\n    }\n    if (roles instanceof Collection) {\n      /**\n       * Any roles that were mentioned\n       * <info>Order as received from the API, not as they appear in the message content</info>\n       * @type {Collection<Snowflake, Role>}\n       */\n      this.roles = new Collection(roles);\n    } else if (roles) {\n      this.roles = new Collection();\n      const guild = message.guild;\n      if (guild) {\n        for (const mention of roles) {\n          const role = guild.roles.cache.get(mention);\n          if (role) this.roles.set(role.id, role);\n        }\n      }\n    } else {\n      this.roles = new Collection();\n    }\n\n    /**\n     * Cached members for {@link MessageMentions#members}\n     * @type {?Collection<Snowflake, GuildMember>}\n     * @private\n     */\n    this._members = null;\n\n    /**\n     * Cached channels for {@link MessageMentions#channels}\n     * @type {?Collection<Snowflake, BaseChannel>}\n     * @private\n     */\n    this._channels = null;\n\n    /**\n     * Cached users for {@link MessageMentions#parsedUsers}\n     * @type {?Collection<Snowflake, User>}\n     * @private\n     */\n    this._parsedUsers = null;\n\n    /**\n     * Crossposted channel data.\n     * @typedef {Object} CrosspostedChannel\n     * @property {Snowflake} channelId The mentioned channel's id\n     * @property {Snowflake} guildId The id of the guild that has the channel\n     * @property {ChannelType} type The channel's type\n     * @property {string} name The channel's name\n     */\n\n    if (crosspostedChannels) {\n      if (crosspostedChannels instanceof Collection) {\n        /**\n         * A collection of crossposted channels\n         * <info>Order as received from the API, not as they appear in the message content</info>\n         * @type {Collection<Snowflake, CrosspostedChannel>}\n         */\n        this.crosspostedChannels = new Collection(crosspostedChannels);\n      } else {\n        this.crosspostedChannels = new Collection();\n        for (const d of crosspostedChannels) {\n          this.crosspostedChannels.set(d.id, {\n            channelId: d.id,\n            guildId: d.guild_id,\n            type: d.type,\n            name: d.name\n          });\n        }\n      }\n    } else {\n      this.crosspostedChannels = new Collection();\n    }\n\n    /**\n     * The author of the message that this message is a reply to\n     * @type {?User}\n     */\n    this.repliedUser = repliedUser ? this.client.users._add(repliedUser) : null;\n  }\n\n  /**\n   * Any members that were mentioned (only in {@link Guild}s)\n   * <info>Order as received from the API, not as they appear in the message content</info>\n   * @type {?Collection<Snowflake, GuildMember>}\n   * @readonly\n   */\n  get members() {\n    if (this._members) return this._members;\n    if (!this.guild) return null;\n    this._members = new Collection();\n    this.users.forEach(user => {\n      const member = this.guild.members.resolve(user);\n      if (member) this._members.set(member.user.id, member);\n    });\n    return this._members;\n  }\n\n  /**\n   * Any channels that were mentioned\n   * <info>Order as they appear first in the message content</info>\n   * @type {Collection<Snowflake, BaseChannel>}\n   * @readonly\n   */\n  get channels() {\n    if (this._channels) return this._channels;\n    this._channels = new Collection();\n    let matches;\n    while ((matches = this.constructor.GlobalChannelsPattern.exec(this._content)) !== null) {\n      const channel = this.client.channels.cache.get(matches.groups.id);\n      if (channel) this._channels.set(channel.id, channel);\n    }\n    return this._channels;\n  }\n\n  /**\n   * Any user mentions that were included in the message content\n   * <info>Order as they appear first in the message content</info>\n   * @type {Collection<Snowflake, User>}\n   * @readonly\n   */\n  get parsedUsers() {\n    if (this._parsedUsers) return this._parsedUsers;\n    this._parsedUsers = new Collection();\n    let matches;\n    while ((matches = this.constructor.GlobalUsersPattern.exec(this._content)) !== null) {\n      const user = this.client.users.cache.get(matches[1]);\n      if (user) this._parsedUsers.set(user.id, user);\n    }\n    return this._parsedUsers;\n  }\n\n  /**\n   * Options used to check for a mention.\n   * @typedef {Object} MessageMentionsHasOptions\n   * @property {boolean} [ignoreDirect=false] Whether to ignore direct mentions to the item\n   * @property {boolean} [ignoreRoles=false] Whether to ignore role mentions to a guild member\n   * @property {boolean} [ignoreRepliedUser=false] Whether to ignore replied user mention to an user\n   * @property {boolean} [ignoreEveryone=false] Whether to ignore `@everyone`/`@here` mentions\n   */\n\n  /**\n   * Checks if a user, guild member, thread member, role, or channel is mentioned.\n   * Takes into account user mentions, role mentions, channel mentions,\n   * replied user mention, and `@everyone`/`@here` mentions.\n   * @param {UserResolvable|RoleResolvable|ChannelResolvable} data The User/Role/Channel to check for\n   * @param {MessageMentionsHasOptions} [options] The options for the check\n   * @returns {boolean}\n   */\n  has(data) {\n    let {\n      ignoreDirect = false,\n      ignoreRoles = false,\n      ignoreRepliedUser = false,\n      ignoreEveryone = false\n    } = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    const user = this.client.users.resolve(data);\n    if (!ignoreEveryone && user && this.everyone) return true;\n    const userWasRepliedTo = user && this.repliedUser?.id === user.id;\n    if (!ignoreRepliedUser && userWasRepliedTo && this.users.has(user.id)) return true;\n    if (!ignoreDirect) {\n      if (user && (!ignoreRepliedUser || this.parsedUsers.has(user.id)) && this.users.has(user.id)) return true;\n      const role = this.guild?.roles.resolve(data);\n      if (role && this.roles.has(role.id)) return true;\n      const channel = this.client.channels.resolve(data);\n      if (channel && this.channels.has(channel.id)) return true;\n    }\n    if (!ignoreRoles) {\n      const member = this.guild?.members.resolve(data);\n      if (member) {\n        for (const mentionedRole of this.roles.values()) if (member.roles.cache.has(mentionedRole.id)) return true;\n      }\n    }\n    return false;\n  }\n  toJSON() {\n    return flatten(this, {\n      members: true,\n      channels: true\n    });\n  }\n}\nmodule.exports = MessageMentions;","map":{"version":3,"names":["Collection","require","FormattingPatterns","flatten","MessageMentions","EveryonePattern","UsersPattern","UserWithOptionalNickname","RolesPattern","Role","ChannelsPattern","Channel","GlobalChannelsPattern","RegExp","source","GlobalUsersPattern","constructor","message","users","roles","everyone","crosspostedChannels","repliedUser","Object","defineProperty","value","client","guild","content","Boolean","mention","member","members","_add","assign","user","set","id","role","cache","get","_members","_channels","_parsedUsers","d","channelId","guildId","guild_id","type","name","forEach","resolve","channels","matches","exec","_content","channel","groups","parsedUsers","has","data","ignoreDirect","ignoreRoles","ignoreRepliedUser","ignoreEveryone","userWasRepliedTo","mentionedRole","values","toJSON","module","exports"],"sources":["J:/Coding/Projekts/Web/JavaScript/sillcode.tech/node_modules/discord.js/src/structures/MessageMentions.js"],"sourcesContent":["'use strict';\n\nconst { Collection } = require('@discordjs/collection');\nconst { FormattingPatterns } = require('discord-api-types/v10');\nconst { flatten } = require('../util/Util');\n\n/**\n * Keeps track of mentions in a {@link Message}.\n */\nclass MessageMentions {\n  /**\n   * A regular expression that matches `@everyone` and `@here`.\n   * The `mention` group property is present on the `exec` result of this expression.\n   * @type {RegExp}\n   * @memberof MessageMentions\n   */\n  static EveryonePattern = /@(?<mention>everyone|here)/;\n\n  /**\n   * A regular expression that matches user mentions like `<@81440962496172032>`.\n   * The `id` group property is present on the `exec` result of this expression.\n   * @type {RegExp}\n   * @memberof MessageMentions\n   */\n  static UsersPattern = FormattingPatterns.UserWithOptionalNickname;\n\n  /**\n   * A regular expression that matches role mentions like `<@&297577916114403338>`.\n   * The `id` group property is present on the `exec` result of this expression.\n   * @type {RegExp}\n   * @memberof MessageMentions\n   */\n  static RolesPattern = FormattingPatterns.Role;\n\n  /**\n   * A regular expression that matches channel mentions like `<#222079895583457280>`.\n   * The `id` group property is present on the `exec` result of this expression.\n   * @type {RegExp}\n   * @memberof MessageMentions\n   */\n  static ChannelsPattern = FormattingPatterns.Channel;\n\n  /**\n   * A global regular expression variant of {@link MessageMentions.ChannelsPattern}.\n   * @type {RegExp}\n   * @memberof MessageMentions\n   * @private\n   */\n  static GlobalChannelsPattern = new RegExp(this.ChannelsPattern.source, 'g');\n\n  /**\n   * A global regular expression variant of {@link MessageMentions.UsersPattern}.\n   * @type {RegExp}\n   * @memberof MessageMentions\n   * @private\n   */\n  static GlobalUsersPattern = new RegExp(this.UsersPattern.source, 'g');\n\n  constructor(message, users, roles, everyone, crosspostedChannels, repliedUser) {\n    /**\n     * The client the message is from\n     * @type {Client}\n     * @readonly\n     */\n    Object.defineProperty(this, 'client', { value: message.client });\n\n    /**\n     * The guild the message is in\n     * @type {?Guild}\n     * @readonly\n     */\n    Object.defineProperty(this, 'guild', { value: message.guild });\n\n    /**\n     * The initial message content\n     * @type {string}\n     * @readonly\n     * @private\n     */\n    Object.defineProperty(this, '_content', { value: message.content });\n\n    /**\n     * Whether `@everyone` or `@here` were mentioned\n     * @type {boolean}\n     */\n    this.everyone = Boolean(everyone);\n\n    if (users) {\n      if (users instanceof Collection) {\n        /**\n         * Any users that were mentioned\n         * <info>Order as received from the API, not as they appear in the message content</info>\n         * @type {Collection<Snowflake, User>}\n         */\n        this.users = new Collection(users);\n      } else {\n        this.users = new Collection();\n        for (const mention of users) {\n          if (mention.member && message.guild) {\n            message.guild.members._add(Object.assign(mention.member, { user: mention }));\n          }\n          const user = message.client.users._add(mention);\n          this.users.set(user.id, user);\n        }\n      }\n    } else {\n      this.users = new Collection();\n    }\n\n    if (roles instanceof Collection) {\n      /**\n       * Any roles that were mentioned\n       * <info>Order as received from the API, not as they appear in the message content</info>\n       * @type {Collection<Snowflake, Role>}\n       */\n      this.roles = new Collection(roles);\n    } else if (roles) {\n      this.roles = new Collection();\n      const guild = message.guild;\n      if (guild) {\n        for (const mention of roles) {\n          const role = guild.roles.cache.get(mention);\n          if (role) this.roles.set(role.id, role);\n        }\n      }\n    } else {\n      this.roles = new Collection();\n    }\n\n    /**\n     * Cached members for {@link MessageMentions#members}\n     * @type {?Collection<Snowflake, GuildMember>}\n     * @private\n     */\n    this._members = null;\n\n    /**\n     * Cached channels for {@link MessageMentions#channels}\n     * @type {?Collection<Snowflake, BaseChannel>}\n     * @private\n     */\n    this._channels = null;\n\n    /**\n     * Cached users for {@link MessageMentions#parsedUsers}\n     * @type {?Collection<Snowflake, User>}\n     * @private\n     */\n    this._parsedUsers = null;\n\n    /**\n     * Crossposted channel data.\n     * @typedef {Object} CrosspostedChannel\n     * @property {Snowflake} channelId The mentioned channel's id\n     * @property {Snowflake} guildId The id of the guild that has the channel\n     * @property {ChannelType} type The channel's type\n     * @property {string} name The channel's name\n     */\n\n    if (crosspostedChannels) {\n      if (crosspostedChannels instanceof Collection) {\n        /**\n         * A collection of crossposted channels\n         * <info>Order as received from the API, not as they appear in the message content</info>\n         * @type {Collection<Snowflake, CrosspostedChannel>}\n         */\n        this.crosspostedChannels = new Collection(crosspostedChannels);\n      } else {\n        this.crosspostedChannels = new Collection();\n        for (const d of crosspostedChannels) {\n          this.crosspostedChannels.set(d.id, {\n            channelId: d.id,\n            guildId: d.guild_id,\n            type: d.type,\n            name: d.name,\n          });\n        }\n      }\n    } else {\n      this.crosspostedChannels = new Collection();\n    }\n\n    /**\n     * The author of the message that this message is a reply to\n     * @type {?User}\n     */\n    this.repliedUser = repliedUser ? this.client.users._add(repliedUser) : null;\n  }\n\n  /**\n   * Any members that were mentioned (only in {@link Guild}s)\n   * <info>Order as received from the API, not as they appear in the message content</info>\n   * @type {?Collection<Snowflake, GuildMember>}\n   * @readonly\n   */\n  get members() {\n    if (this._members) return this._members;\n    if (!this.guild) return null;\n    this._members = new Collection();\n    this.users.forEach(user => {\n      const member = this.guild.members.resolve(user);\n      if (member) this._members.set(member.user.id, member);\n    });\n    return this._members;\n  }\n\n  /**\n   * Any channels that were mentioned\n   * <info>Order as they appear first in the message content</info>\n   * @type {Collection<Snowflake, BaseChannel>}\n   * @readonly\n   */\n  get channels() {\n    if (this._channels) return this._channels;\n    this._channels = new Collection();\n    let matches;\n\n    while ((matches = this.constructor.GlobalChannelsPattern.exec(this._content)) !== null) {\n      const channel = this.client.channels.cache.get(matches.groups.id);\n      if (channel) this._channels.set(channel.id, channel);\n    }\n\n    return this._channels;\n  }\n\n  /**\n   * Any user mentions that were included in the message content\n   * <info>Order as they appear first in the message content</info>\n   * @type {Collection<Snowflake, User>}\n   * @readonly\n   */\n  get parsedUsers() {\n    if (this._parsedUsers) return this._parsedUsers;\n    this._parsedUsers = new Collection();\n    let matches;\n    while ((matches = this.constructor.GlobalUsersPattern.exec(this._content)) !== null) {\n      const user = this.client.users.cache.get(matches[1]);\n      if (user) this._parsedUsers.set(user.id, user);\n    }\n    return this._parsedUsers;\n  }\n\n  /**\n   * Options used to check for a mention.\n   * @typedef {Object} MessageMentionsHasOptions\n   * @property {boolean} [ignoreDirect=false] Whether to ignore direct mentions to the item\n   * @property {boolean} [ignoreRoles=false] Whether to ignore role mentions to a guild member\n   * @property {boolean} [ignoreRepliedUser=false] Whether to ignore replied user mention to an user\n   * @property {boolean} [ignoreEveryone=false] Whether to ignore `@everyone`/`@here` mentions\n   */\n\n  /**\n   * Checks if a user, guild member, thread member, role, or channel is mentioned.\n   * Takes into account user mentions, role mentions, channel mentions,\n   * replied user mention, and `@everyone`/`@here` mentions.\n   * @param {UserResolvable|RoleResolvable|ChannelResolvable} data The User/Role/Channel to check for\n   * @param {MessageMentionsHasOptions} [options] The options for the check\n   * @returns {boolean}\n   */\n  has(data, { ignoreDirect = false, ignoreRoles = false, ignoreRepliedUser = false, ignoreEveryone = false } = {}) {\n    const user = this.client.users.resolve(data);\n\n    if (!ignoreEveryone && user && this.everyone) return true;\n\n    const userWasRepliedTo = user && this.repliedUser?.id === user.id;\n\n    if (!ignoreRepliedUser && userWasRepliedTo && this.users.has(user.id)) return true;\n\n    if (!ignoreDirect) {\n      if (user && (!ignoreRepliedUser || this.parsedUsers.has(user.id)) && this.users.has(user.id)) return true;\n\n      const role = this.guild?.roles.resolve(data);\n      if (role && this.roles.has(role.id)) return true;\n\n      const channel = this.client.channels.resolve(data);\n      if (channel && this.channels.has(channel.id)) return true;\n    }\n\n    if (!ignoreRoles) {\n      const member = this.guild?.members.resolve(data);\n      if (member) {\n        for (const mentionedRole of this.roles.values()) if (member.roles.cache.has(mentionedRole.id)) return true;\n      }\n    }\n\n    return false;\n  }\n\n  toJSON() {\n    return flatten(this, {\n      members: true,\n      channels: true,\n    });\n  }\n}\n\nmodule.exports = MessageMentions;\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}