{"ast":null,"code":"'use strict';\n\nconst process = require('node:process');\nconst {\n  setTimeout,\n  clearTimeout\n} = require('node:timers');\nconst {\n  Collection\n} = require('@discordjs/collection');\nconst {\n  makeURLSearchParams\n} = require('@discordjs/rest');\nconst {\n  Routes\n} = require('discord-api-types/v10');\nconst CachedManager = require('./CachedManager');\nconst {\n  Guild\n} = require('../structures/Guild');\nconst GuildChannel = require('../structures/GuildChannel');\nconst GuildEmoji = require('../structures/GuildEmoji');\nconst {\n  GuildMember\n} = require('../structures/GuildMember');\nconst Invite = require('../structures/Invite');\nconst OAuth2Guild = require('../structures/OAuth2Guild');\nconst {\n  Role\n} = require('../structures/Role');\nconst DataResolver = require('../util/DataResolver');\nconst Events = require('../util/Events');\nconst PermissionsBitField = require('../util/PermissionsBitField');\nconst SystemChannelFlagsBitField = require('../util/SystemChannelFlagsBitField');\nconst {\n  resolveColor\n} = require('../util/Util');\nlet cacheWarningEmitted = false;\n\n/**\n * Manages API methods for Guilds and stores their cache.\n * @extends {CachedManager}\n */\nclass GuildManager extends CachedManager {\n  constructor(client, iterable) {\n    super(client, Guild, iterable);\n    if (!cacheWarningEmitted && this._cache.constructor.name !== 'Collection') {\n      cacheWarningEmitted = true;\n      process.emitWarning(`Overriding the cache handling for ${this.constructor.name} is unsupported and breaks functionality.`, 'UnsupportedCacheOverwriteWarning');\n    }\n  }\n\n  /**\n   * The cache of this Manager\n   * @type {Collection<Snowflake, Guild>}\n   * @name GuildManager#cache\n   */\n\n  /**\n   * Data that resolves to give a Guild object. This can be:\n   * * A Guild object\n   * * A GuildChannel object\n   * * A GuildEmoji object\n   * * A Role object\n   * * A Snowflake\n   * * An Invite object\n   * @typedef {Guild|GuildChannel|GuildMember|GuildEmoji|Role|Snowflake|Invite} GuildResolvable\n   */\n\n  /**\n   * Partial data for a Role.\n   * @typedef {Object} PartialRoleData\n   * @property {Snowflake|number} [id] The role's id, used to set channel overrides,\n   * this is a placeholder and will be replaced by the API after consumption\n   * @property {string} [name] The name of the role\n   * @property {ColorResolvable} [color] The color of the role, either a hex string or a base 10 number\n   * @property {boolean} [hoist] Whether or not the role should be hoisted\n   * @property {number} [position] The position of the role\n   * @property {PermissionResolvable} [permissions] The permissions of the role\n   * @property {boolean} [mentionable] Whether or not the role should be mentionable\n   */\n\n  /**\n   * Partial overwrite data.\n   * @typedef {Object} PartialOverwriteData\n   * @property {Snowflake|number} id The id of the {@link Role} or {@link User} this overwrite belongs to\n   * @property {OverwriteType} [type] The type of this overwrite\n   * @property {PermissionResolvable} [allow] The permissions to allow\n   * @property {PermissionResolvable} [deny] The permissions to deny\n   */\n\n  /**\n   * Partial data for a Channel.\n   * @typedef {Object} PartialChannelData\n   * @property {Snowflake|number} [id] The channel's id, used to set its parent,\n   * this is a placeholder and will be replaced by the API after consumption\n   * @property {Snowflake|number} [parentId] The parent id for this channel\n   * @property {ChannelType.GuildText|ChannelType.GuildVoice|ChannelType.GuildCategory} [type] The type of the channel\n   * @property {string} name The name of the channel\n   * @property {?string} [topic] The topic of the text channel\n   * @property {boolean} [nsfw] Whether the channel is NSFW\n   * @property {number} [bitrate] The bitrate of the voice channel\n   * @property {number} [userLimit] The user limit of the channel\n   * @property {?string} [rtcRegion] The RTC region of the channel\n   * @property {VideoQualityMode} [videoQualityMode] The camera video quality mode of the channel\n   * @property {PartialOverwriteData[]} [permissionOverwrites]\n   * Overwrites of the channel\n   * @property {number} [rateLimitPerUser] The rate limit per user (slowmode) of the channel in seconds\n   */\n\n  /**\n   * Resolves a GuildResolvable to a Guild object.\n   * @method resolve\n   * @memberof GuildManager\n   * @instance\n   * @param {GuildResolvable} guild The guild resolvable to identify\n   * @returns {?Guild}\n   */\n  resolve(guild) {\n    if (guild instanceof GuildChannel || guild instanceof GuildMember || guild instanceof GuildEmoji || guild instanceof Role || guild instanceof Invite && guild.guild) {\n      return super.resolve(guild.guild);\n    }\n    return super.resolve(guild);\n  }\n\n  /**\n   * Resolves a {@link GuildResolvable} to a {@link Guild} id string.\n   * @method resolveId\n   * @memberof GuildManager\n   * @instance\n   * @param {GuildResolvable} guild The guild resolvable to identify\n   * @returns {?Snowflake}\n   */\n  resolveId(guild) {\n    if (guild instanceof GuildChannel || guild instanceof GuildMember || guild instanceof GuildEmoji || guild instanceof Role || guild instanceof Invite && guild.guild) {\n      return super.resolveId(guild.guild.id);\n    }\n    return super.resolveId(guild);\n  }\n\n  /**\n   * Options used to create a guild.\n   * @typedef {Object} GuildCreateOptions\n   * @property {string} name The name of the guild\n   * @property {Snowflake|number} [afkChannelId] The AFK channel's id\n   * @property {number} [afkTimeout] The AFK timeout in seconds\n   * @property {PartialChannelData[]} [channels=[]] The channels for this guild\n   * @property {GuildDefaultMessageNotifications} [defaultMessageNotifications] The default message notifications\n   * for the guild\n   * @property {GuildExplicitContentFilter} [explicitContentFilter] The explicit content filter level for the guild\n   * @property {?(BufferResolvable|Base64Resolvable)} [icon=null] The icon for the guild\n   * @property {PartialRoleData[]} [roles=[]] The roles for this guild,\n   * the first element of this array is used to change properties of the guild's everyone role.\n   * @property {Snowflake|number} [systemChannelId] The system channel's id\n   * @property {SystemChannelFlagsResolvable} [systemChannelFlags] The flags of the system channel\n   * @property {GuildVerificationLevel} [verificationLevel] The verification level for the guild\n   */\n  /* eslint-enable max-len */\n\n  /**\n   * Creates a guild.\n   * <warn>This is only available to bots in fewer than 10 guilds.</warn>\n   * @param {GuildCreateOptions} options Options for creating the guild\n   * @returns {Promise<Guild>} The guild that was created\n   */\n  async create(_ref) {\n    let {\n      name,\n      afkChannelId,\n      afkTimeout,\n      channels = [],\n      defaultMessageNotifications,\n      explicitContentFilter,\n      icon = null,\n      roles = [],\n      systemChannelId,\n      systemChannelFlags,\n      verificationLevel\n    } = _ref;\n    icon = await DataResolver.resolveImage(icon);\n    for (const channel of channels) {\n      channel.parent_id = channel.parentId;\n      delete channel.parentId;\n      channel.user_limit = channel.userLimit;\n      delete channel.userLimit;\n      channel.rate_limit_per_user = channel.rateLimitPerUser;\n      delete channel.rateLimitPerUser;\n      channel.rtc_region = channel.rtcRegion;\n      delete channel.rtcRegion;\n      channel.video_quality_mode = channel.videoQualityMode;\n      delete channel.videoQualityMode;\n      if (!channel.permissionOverwrites) continue;\n      for (const overwrite of channel.permissionOverwrites) {\n        overwrite.allow &&= PermissionsBitField.resolve(overwrite.allow).toString();\n        overwrite.deny &&= PermissionsBitField.resolve(overwrite.deny).toString();\n      }\n      channel.permission_overwrites = channel.permissionOverwrites;\n      delete channel.permissionOverwrites;\n    }\n    for (const role of roles) {\n      role.color &&= resolveColor(role.color);\n      role.permissions &&= PermissionsBitField.resolve(role.permissions).toString();\n    }\n    systemChannelFlags &&= SystemChannelFlagsBitField.resolve(systemChannelFlags);\n    const data = await this.client.rest.post(Routes.guilds(), {\n      body: {\n        name,\n        icon,\n        verification_level: verificationLevel,\n        default_message_notifications: defaultMessageNotifications,\n        explicit_content_filter: explicitContentFilter,\n        roles,\n        channels,\n        afk_channel_id: afkChannelId,\n        afk_timeout: afkTimeout,\n        system_channel_id: systemChannelId,\n        system_channel_flags: systemChannelFlags\n      }\n    });\n    if (this.client.guilds.cache.has(data.id)) return this.client.guilds.cache.get(data.id);\n    return new Promise(resolve => {\n      const handleGuild = guild => {\n        if (guild.id === data.id) {\n          clearTimeout(timeout);\n          this.client.removeListener(Events.GuildCreate, handleGuild);\n          this.client.decrementMaxListeners();\n          resolve(guild);\n        }\n      };\n      this.client.incrementMaxListeners();\n      this.client.on(Events.GuildCreate, handleGuild);\n      const timeout = setTimeout(() => {\n        this.client.removeListener(Events.GuildCreate, handleGuild);\n        this.client.decrementMaxListeners();\n        resolve(this.client.guilds._add(data));\n      }, 10_000).unref();\n    });\n  }\n\n  /**\n   * Options used to fetch a single guild.\n   * @typedef {BaseFetchOptions} FetchGuildOptions\n   * @property {GuildResolvable} guild The guild to fetch\n   * @property {boolean} [withCounts=true] Whether the approximate member and presence counts should be returned\n   */\n\n  /**\n   * Options used to fetch multiple guilds.\n   * @typedef {Object} FetchGuildsOptions\n   * @property {Snowflake} [before] Get guilds before this guild id\n   * @property {Snowflake} [after] Get guilds after this guild id\n   * @property {number} [limit] Maximum number of guilds to request (1-200)\n   */\n\n  /**\n   * Obtains one or multiple guilds from Discord, or the guild cache if it's already available.\n   * @param {GuildResolvable|FetchGuildOptions|FetchGuildsOptions} [options] The guild's id or options\n   * @returns {Promise<Guild|Collection<Snowflake, OAuth2Guild>>}\n   */\n  async fetch() {\n    let options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    const id = this.resolveId(options) ?? this.resolveId(options.guild);\n    if (id) {\n      if (!options.force) {\n        const existing = this.cache.get(id);\n        if (existing) return existing;\n      }\n      const data = await this.client.rest.get(Routes.guild(id), {\n        query: makeURLSearchParams({\n          with_counts: options.withCounts ?? true\n        })\n      });\n      return this._add(data, options.cache);\n    }\n    const data = await this.client.rest.get(Routes.userGuilds(), {\n      query: makeURLSearchParams(options)\n    });\n    return data.reduce((coll, guild) => coll.set(guild.id, new OAuth2Guild(this.client, guild)), new Collection());\n  }\n}\nmodule.exports = GuildManager;","map":{"version":3,"names":["process","require","setTimeout","clearTimeout","Collection","makeURLSearchParams","Routes","CachedManager","Guild","GuildChannel","GuildEmoji","GuildMember","Invite","OAuth2Guild","Role","DataResolver","Events","PermissionsBitField","SystemChannelFlagsBitField","resolveColor","cacheWarningEmitted","GuildManager","constructor","client","iterable","_cache","name","emitWarning","resolve","guild","resolveId","id","create","afkChannelId","afkTimeout","channels","defaultMessageNotifications","explicitContentFilter","icon","roles","systemChannelId","systemChannelFlags","verificationLevel","resolveImage","channel","parent_id","parentId","user_limit","userLimit","rate_limit_per_user","rateLimitPerUser","rtc_region","rtcRegion","video_quality_mode","videoQualityMode","permissionOverwrites","overwrite","allow","toString","deny","permission_overwrites","role","color","permissions","data","rest","post","guilds","body","verification_level","default_message_notifications","explicit_content_filter","afk_channel_id","afk_timeout","system_channel_id","system_channel_flags","cache","has","get","Promise","handleGuild","timeout","removeListener","GuildCreate","decrementMaxListeners","incrementMaxListeners","on","_add","unref","fetch","options","force","existing","query","with_counts","withCounts","userGuilds","reduce","coll","set","module","exports"],"sources":["J:/Coding/Projekts/Web/JavaScript/sillcode.tech/node_modules/discord.js/src/managers/GuildManager.js"],"sourcesContent":["'use strict';\n\nconst process = require('node:process');\nconst { setTimeout, clearTimeout } = require('node:timers');\nconst { Collection } = require('@discordjs/collection');\nconst { makeURLSearchParams } = require('@discordjs/rest');\nconst { Routes } = require('discord-api-types/v10');\nconst CachedManager = require('./CachedManager');\nconst { Guild } = require('../structures/Guild');\nconst GuildChannel = require('../structures/GuildChannel');\nconst GuildEmoji = require('../structures/GuildEmoji');\nconst { GuildMember } = require('../structures/GuildMember');\nconst Invite = require('../structures/Invite');\nconst OAuth2Guild = require('../structures/OAuth2Guild');\nconst { Role } = require('../structures/Role');\nconst DataResolver = require('../util/DataResolver');\nconst Events = require('../util/Events');\nconst PermissionsBitField = require('../util/PermissionsBitField');\nconst SystemChannelFlagsBitField = require('../util/SystemChannelFlagsBitField');\nconst { resolveColor } = require('../util/Util');\n\nlet cacheWarningEmitted = false;\n\n/**\n * Manages API methods for Guilds and stores their cache.\n * @extends {CachedManager}\n */\nclass GuildManager extends CachedManager {\n  constructor(client, iterable) {\n    super(client, Guild, iterable);\n    if (!cacheWarningEmitted && this._cache.constructor.name !== 'Collection') {\n      cacheWarningEmitted = true;\n      process.emitWarning(\n        `Overriding the cache handling for ${this.constructor.name} is unsupported and breaks functionality.`,\n        'UnsupportedCacheOverwriteWarning',\n      );\n    }\n  }\n\n  /**\n   * The cache of this Manager\n   * @type {Collection<Snowflake, Guild>}\n   * @name GuildManager#cache\n   */\n\n  /**\n   * Data that resolves to give a Guild object. This can be:\n   * * A Guild object\n   * * A GuildChannel object\n   * * A GuildEmoji object\n   * * A Role object\n   * * A Snowflake\n   * * An Invite object\n   * @typedef {Guild|GuildChannel|GuildMember|GuildEmoji|Role|Snowflake|Invite} GuildResolvable\n   */\n\n  /**\n   * Partial data for a Role.\n   * @typedef {Object} PartialRoleData\n   * @property {Snowflake|number} [id] The role's id, used to set channel overrides,\n   * this is a placeholder and will be replaced by the API after consumption\n   * @property {string} [name] The name of the role\n   * @property {ColorResolvable} [color] The color of the role, either a hex string or a base 10 number\n   * @property {boolean} [hoist] Whether or not the role should be hoisted\n   * @property {number} [position] The position of the role\n   * @property {PermissionResolvable} [permissions] The permissions of the role\n   * @property {boolean} [mentionable] Whether or not the role should be mentionable\n   */\n\n  /**\n   * Partial overwrite data.\n   * @typedef {Object} PartialOverwriteData\n   * @property {Snowflake|number} id The id of the {@link Role} or {@link User} this overwrite belongs to\n   * @property {OverwriteType} [type] The type of this overwrite\n   * @property {PermissionResolvable} [allow] The permissions to allow\n   * @property {PermissionResolvable} [deny] The permissions to deny\n   */\n\n  /**\n   * Partial data for a Channel.\n   * @typedef {Object} PartialChannelData\n   * @property {Snowflake|number} [id] The channel's id, used to set its parent,\n   * this is a placeholder and will be replaced by the API after consumption\n   * @property {Snowflake|number} [parentId] The parent id for this channel\n   * @property {ChannelType.GuildText|ChannelType.GuildVoice|ChannelType.GuildCategory} [type] The type of the channel\n   * @property {string} name The name of the channel\n   * @property {?string} [topic] The topic of the text channel\n   * @property {boolean} [nsfw] Whether the channel is NSFW\n   * @property {number} [bitrate] The bitrate of the voice channel\n   * @property {number} [userLimit] The user limit of the channel\n   * @property {?string} [rtcRegion] The RTC region of the channel\n   * @property {VideoQualityMode} [videoQualityMode] The camera video quality mode of the channel\n   * @property {PartialOverwriteData[]} [permissionOverwrites]\n   * Overwrites of the channel\n   * @property {number} [rateLimitPerUser] The rate limit per user (slowmode) of the channel in seconds\n   */\n\n  /**\n   * Resolves a GuildResolvable to a Guild object.\n   * @method resolve\n   * @memberof GuildManager\n   * @instance\n   * @param {GuildResolvable} guild The guild resolvable to identify\n   * @returns {?Guild}\n   */\n  resolve(guild) {\n    if (\n      guild instanceof GuildChannel ||\n      guild instanceof GuildMember ||\n      guild instanceof GuildEmoji ||\n      guild instanceof Role ||\n      (guild instanceof Invite && guild.guild)\n    ) {\n      return super.resolve(guild.guild);\n    }\n    return super.resolve(guild);\n  }\n\n  /**\n   * Resolves a {@link GuildResolvable} to a {@link Guild} id string.\n   * @method resolveId\n   * @memberof GuildManager\n   * @instance\n   * @param {GuildResolvable} guild The guild resolvable to identify\n   * @returns {?Snowflake}\n   */\n  resolveId(guild) {\n    if (\n      guild instanceof GuildChannel ||\n      guild instanceof GuildMember ||\n      guild instanceof GuildEmoji ||\n      guild instanceof Role ||\n      (guild instanceof Invite && guild.guild)\n    ) {\n      return super.resolveId(guild.guild.id);\n    }\n    return super.resolveId(guild);\n  }\n\n  /**\n   * Options used to create a guild.\n   * @typedef {Object} GuildCreateOptions\n   * @property {string} name The name of the guild\n   * @property {Snowflake|number} [afkChannelId] The AFK channel's id\n   * @property {number} [afkTimeout] The AFK timeout in seconds\n   * @property {PartialChannelData[]} [channels=[]] The channels for this guild\n   * @property {GuildDefaultMessageNotifications} [defaultMessageNotifications] The default message notifications\n   * for the guild\n   * @property {GuildExplicitContentFilter} [explicitContentFilter] The explicit content filter level for the guild\n   * @property {?(BufferResolvable|Base64Resolvable)} [icon=null] The icon for the guild\n   * @property {PartialRoleData[]} [roles=[]] The roles for this guild,\n   * the first element of this array is used to change properties of the guild's everyone role.\n   * @property {Snowflake|number} [systemChannelId] The system channel's id\n   * @property {SystemChannelFlagsResolvable} [systemChannelFlags] The flags of the system channel\n   * @property {GuildVerificationLevel} [verificationLevel] The verification level for the guild\n   */\n  /* eslint-enable max-len */\n\n  /**\n   * Creates a guild.\n   * <warn>This is only available to bots in fewer than 10 guilds.</warn>\n   * @param {GuildCreateOptions} options Options for creating the guild\n   * @returns {Promise<Guild>} The guild that was created\n   */\n  async create({\n    name,\n    afkChannelId,\n    afkTimeout,\n    channels = [],\n    defaultMessageNotifications,\n    explicitContentFilter,\n    icon = null,\n    roles = [],\n    systemChannelId,\n    systemChannelFlags,\n    verificationLevel,\n  }) {\n    icon = await DataResolver.resolveImage(icon);\n\n    for (const channel of channels) {\n      channel.parent_id = channel.parentId;\n      delete channel.parentId;\n      channel.user_limit = channel.userLimit;\n      delete channel.userLimit;\n      channel.rate_limit_per_user = channel.rateLimitPerUser;\n      delete channel.rateLimitPerUser;\n      channel.rtc_region = channel.rtcRegion;\n      delete channel.rtcRegion;\n      channel.video_quality_mode = channel.videoQualityMode;\n      delete channel.videoQualityMode;\n\n      if (!channel.permissionOverwrites) continue;\n      for (const overwrite of channel.permissionOverwrites) {\n        overwrite.allow &&= PermissionsBitField.resolve(overwrite.allow).toString();\n        overwrite.deny &&= PermissionsBitField.resolve(overwrite.deny).toString();\n      }\n      channel.permission_overwrites = channel.permissionOverwrites;\n      delete channel.permissionOverwrites;\n    }\n    for (const role of roles) {\n      role.color &&= resolveColor(role.color);\n      role.permissions &&= PermissionsBitField.resolve(role.permissions).toString();\n    }\n    systemChannelFlags &&= SystemChannelFlagsBitField.resolve(systemChannelFlags);\n\n    const data = await this.client.rest.post(Routes.guilds(), {\n      body: {\n        name,\n        icon,\n        verification_level: verificationLevel,\n        default_message_notifications: defaultMessageNotifications,\n        explicit_content_filter: explicitContentFilter,\n        roles,\n        channels,\n        afk_channel_id: afkChannelId,\n        afk_timeout: afkTimeout,\n        system_channel_id: systemChannelId,\n        system_channel_flags: systemChannelFlags,\n      },\n    });\n\n    if (this.client.guilds.cache.has(data.id)) return this.client.guilds.cache.get(data.id);\n\n    return new Promise(resolve => {\n      const handleGuild = guild => {\n        if (guild.id === data.id) {\n          clearTimeout(timeout);\n          this.client.removeListener(Events.GuildCreate, handleGuild);\n          this.client.decrementMaxListeners();\n          resolve(guild);\n        }\n      };\n      this.client.incrementMaxListeners();\n      this.client.on(Events.GuildCreate, handleGuild);\n\n      const timeout = setTimeout(() => {\n        this.client.removeListener(Events.GuildCreate, handleGuild);\n        this.client.decrementMaxListeners();\n        resolve(this.client.guilds._add(data));\n      }, 10_000).unref();\n    });\n  }\n\n  /**\n   * Options used to fetch a single guild.\n   * @typedef {BaseFetchOptions} FetchGuildOptions\n   * @property {GuildResolvable} guild The guild to fetch\n   * @property {boolean} [withCounts=true] Whether the approximate member and presence counts should be returned\n   */\n\n  /**\n   * Options used to fetch multiple guilds.\n   * @typedef {Object} FetchGuildsOptions\n   * @property {Snowflake} [before] Get guilds before this guild id\n   * @property {Snowflake} [after] Get guilds after this guild id\n   * @property {number} [limit] Maximum number of guilds to request (1-200)\n   */\n\n  /**\n   * Obtains one or multiple guilds from Discord, or the guild cache if it's already available.\n   * @param {GuildResolvable|FetchGuildOptions|FetchGuildsOptions} [options] The guild's id or options\n   * @returns {Promise<Guild|Collection<Snowflake, OAuth2Guild>>}\n   */\n  async fetch(options = {}) {\n    const id = this.resolveId(options) ?? this.resolveId(options.guild);\n\n    if (id) {\n      if (!options.force) {\n        const existing = this.cache.get(id);\n        if (existing) return existing;\n      }\n\n      const data = await this.client.rest.get(Routes.guild(id), {\n        query: makeURLSearchParams({ with_counts: options.withCounts ?? true }),\n      });\n      return this._add(data, options.cache);\n    }\n\n    const data = await this.client.rest.get(Routes.userGuilds(), { query: makeURLSearchParams(options) });\n    return data.reduce((coll, guild) => coll.set(guild.id, new OAuth2Guild(this.client, guild)), new Collection());\n  }\n}\n\nmodule.exports = GuildManager;\n"],"mappings":"AAAA,YAAY;;AAEZ,MAAMA,OAAO,GAAGC,OAAO,CAAC,cAAc,CAAC;AACvC,MAAM;EAAEC,UAAU;EAAEC;AAAa,CAAC,GAAGF,OAAO,CAAC,aAAa,CAAC;AAC3D,MAAM;EAAEG;AAAW,CAAC,GAAGH,OAAO,CAAC,uBAAuB,CAAC;AACvD,MAAM;EAAEI;AAAoB,CAAC,GAAGJ,OAAO,CAAC,iBAAiB,CAAC;AAC1D,MAAM;EAAEK;AAAO,CAAC,GAAGL,OAAO,CAAC,uBAAuB,CAAC;AACnD,MAAMM,aAAa,GAAGN,OAAO,CAAC,iBAAiB,CAAC;AAChD,MAAM;EAAEO;AAAM,CAAC,GAAGP,OAAO,CAAC,qBAAqB,CAAC;AAChD,MAAMQ,YAAY,GAAGR,OAAO,CAAC,4BAA4B,CAAC;AAC1D,MAAMS,UAAU,GAAGT,OAAO,CAAC,0BAA0B,CAAC;AACtD,MAAM;EAAEU;AAAY,CAAC,GAAGV,OAAO,CAAC,2BAA2B,CAAC;AAC5D,MAAMW,MAAM,GAAGX,OAAO,CAAC,sBAAsB,CAAC;AAC9C,MAAMY,WAAW,GAAGZ,OAAO,CAAC,2BAA2B,CAAC;AACxD,MAAM;EAAEa;AAAK,CAAC,GAAGb,OAAO,CAAC,oBAAoB,CAAC;AAC9C,MAAMc,YAAY,GAAGd,OAAO,CAAC,sBAAsB,CAAC;AACpD,MAAMe,MAAM,GAAGf,OAAO,CAAC,gBAAgB,CAAC;AACxC,MAAMgB,mBAAmB,GAAGhB,OAAO,CAAC,6BAA6B,CAAC;AAClE,MAAMiB,0BAA0B,GAAGjB,OAAO,CAAC,oCAAoC,CAAC;AAChF,MAAM;EAAEkB;AAAa,CAAC,GAAGlB,OAAO,CAAC,cAAc,CAAC;AAEhD,IAAImB,mBAAmB,GAAG,KAAK;;AAE/B;AACA;AACA;AACA;AACA,MAAMC,YAAY,SAASd,aAAa,CAAC;EACvCe,WAAW,CAACC,MAAM,EAAEC,QAAQ,EAAE;IAC5B,KAAK,CAACD,MAAM,EAAEf,KAAK,EAAEgB,QAAQ,CAAC;IAC9B,IAAI,CAACJ,mBAAmB,IAAI,IAAI,CAACK,MAAM,CAACH,WAAW,CAACI,IAAI,KAAK,YAAY,EAAE;MACzEN,mBAAmB,GAAG,IAAI;MAC1BpB,OAAO,CAAC2B,WAAW,CAChB,qCAAoC,IAAI,CAACL,WAAW,CAACI,IAAK,2CAA0C,EACrG,kCAAkC,CACnC;IACH;EACF;;EAEA;AACF;AACA;AACA;AACA;;EAEE;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;EAEE;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;EAEE;AACF;AACA;AACA;AACA;AACA;AACA;AACA;;EAEE;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;EAEE;AACF;AACA;AACA;AACA;AACA;AACA;AACA;EACEE,OAAO,CAACC,KAAK,EAAE;IACb,IACEA,KAAK,YAAYpB,YAAY,IAC7BoB,KAAK,YAAYlB,WAAW,IAC5BkB,KAAK,YAAYnB,UAAU,IAC3BmB,KAAK,YAAYf,IAAI,IACpBe,KAAK,YAAYjB,MAAM,IAAIiB,KAAK,CAACA,KAAM,EACxC;MACA,OAAO,KAAK,CAACD,OAAO,CAACC,KAAK,CAACA,KAAK,CAAC;IACnC;IACA,OAAO,KAAK,CAACD,OAAO,CAACC,KAAK,CAAC;EAC7B;;EAEA;AACF;AACA;AACA;AACA;AACA;AACA;AACA;EACEC,SAAS,CAACD,KAAK,EAAE;IACf,IACEA,KAAK,YAAYpB,YAAY,IAC7BoB,KAAK,YAAYlB,WAAW,IAC5BkB,KAAK,YAAYnB,UAAU,IAC3BmB,KAAK,YAAYf,IAAI,IACpBe,KAAK,YAAYjB,MAAM,IAAIiB,KAAK,CAACA,KAAM,EACxC;MACA,OAAO,KAAK,CAACC,SAAS,CAACD,KAAK,CAACA,KAAK,CAACE,EAAE,CAAC;IACxC;IACA,OAAO,KAAK,CAACD,SAAS,CAACD,KAAK,CAAC;EAC/B;;EAEA;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACE;;EAEA;AACF;AACA;AACA;AACA;AACA;EACE,MAAMG,MAAM,OAYT;IAAA,IAZU;MACXN,IAAI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"},"metadata":{},"sourceType":"script","externalDependencies":[]}