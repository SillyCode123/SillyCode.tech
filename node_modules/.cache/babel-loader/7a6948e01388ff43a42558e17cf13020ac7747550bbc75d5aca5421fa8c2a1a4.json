{"ast":null,"code":"'use strict';\n\nconst EventEmitter = require('node:events');\nconst {\n  setTimeout,\n  setInterval,\n  clearTimeout,\n  clearInterval\n} = require('node:timers');\nconst {\n  GatewayDispatchEvents,\n  GatewayIntentBits,\n  GatewayOpcodes\n} = require('discord-api-types/v10');\nconst WebSocket = require('../../WebSocket');\nconst Events = require('../../util/Events');\nconst Status = require('../../util/Status');\nconst WebSocketShardEvents = require('../../util/WebSocketShardEvents');\nconst STATUS_KEYS = Object.keys(Status);\nconst CONNECTION_STATE = Object.keys(WebSocket.WebSocket);\nlet zlib;\ntry {\n  zlib = require('zlib-sync');\n} catch {} // eslint-disable-line no-empty\n\n/**\n * Represents a Shard's WebSocket connection\n * @extends {EventEmitter}\n */\nclass WebSocketShard extends EventEmitter {\n  constructor(manager, id) {\n    super();\n\n    /**\n     * The WebSocketManager of the shard\n     * @type {WebSocketManager}\n     */\n    this.manager = manager;\n\n    /**\n     * The shard's id\n     * @type {number}\n     */\n    this.id = id;\n\n    /**\n     * The current status of the shard\n     * @type {Status}\n     */\n    this.status = Status.Idle;\n\n    /**\n     * The current sequence of the shard\n     * @type {number}\n     * @private\n     */\n    this.sequence = -1;\n\n    /**\n     * The sequence of the shard after close\n     * @type {number}\n     * @private\n     */\n    this.closeSequence = 0;\n\n    /**\n     * The current session id of the shard\n     * @type {?string}\n     * @private\n     */\n    this.sessionId = null;\n\n    /**\n     * The resume url for this shard\n     * @type {?string}\n     * @private\n     */\n    this.resumeURL = null;\n\n    /**\n     * The previous heartbeat ping of the shard\n     * @type {number}\n     */\n    this.ping = -1;\n\n    /**\n     * The last time a ping was sent (a timestamp)\n     * @type {number}\n     */\n    this.lastPingTimestamp = -1;\n\n    /**\n     * If we received a heartbeat ack back. Used to identify zombie connections\n     * @type {boolean}\n     * @private\n     */\n    this.lastHeartbeatAcked = true;\n\n    /**\n     * Used to prevent calling {@link WebSocketShard#event:close} twice while closing or terminating the WebSocket.\n     * @type {boolean}\n     * @private\n     */\n    this.closeEmitted = false;\n\n    /**\n     * Contains the rate limit queue and metadata\n     * @name WebSocketShard#ratelimit\n     * @type {Object}\n     * @private\n     */\n    Object.defineProperty(this, 'ratelimit', {\n      value: {\n        queue: [],\n        total: 120,\n        remaining: 120,\n        time: 60e3,\n        timer: null\n      }\n    });\n\n    /**\n     * The WebSocket connection for the current shard\n     * @name WebSocketShard#connection\n     * @type {?WebSocket}\n     * @private\n     */\n    Object.defineProperty(this, 'connection', {\n      value: null,\n      writable: true\n    });\n\n    /**\n     * @external Inflate\n     * @see {@link https://www.npmjs.com/package/zlib-sync}\n     */\n\n    /**\n     * The compression to use\n     * @name WebSocketShard#inflate\n     * @type {?Inflate}\n     * @private\n     */\n    Object.defineProperty(this, 'inflate', {\n      value: null,\n      writable: true\n    });\n\n    /**\n     * The HELLO timeout\n     * @name WebSocketShard#helloTimeout\n     * @type {?NodeJS.Timeout}\n     * @private\n     */\n    Object.defineProperty(this, 'helloTimeout', {\n      value: null,\n      writable: true\n    });\n\n    /**\n     * The WebSocket timeout.\n     * @name WebSocketShard#wsCloseTimeout\n     * @type {?NodeJS.Timeout}\n     * @private\n     */\n    Object.defineProperty(this, 'wsCloseTimeout', {\n      value: null,\n      writable: true\n    });\n\n    /**\n     * If the manager attached its event handlers on the shard\n     * @name WebSocketShard#eventsAttached\n     * @type {boolean}\n     * @private\n     */\n    Object.defineProperty(this, 'eventsAttached', {\n      value: false,\n      writable: true\n    });\n\n    /**\n     * A set of guild ids this shard expects to receive\n     * @name WebSocketShard#expectedGuilds\n     * @type {?Set<string>}\n     * @private\n     */\n    Object.defineProperty(this, 'expectedGuilds', {\n      value: null,\n      writable: true\n    });\n\n    /**\n     * The ready timeout\n     * @name WebSocketShard#readyTimeout\n     * @type {?NodeJS.Timeout}\n     * @private\n     */\n    Object.defineProperty(this, 'readyTimeout', {\n      value: null,\n      writable: true\n    });\n\n    /**\n     * Time when the WebSocket connection was opened\n     * @name WebSocketShard#connectedAt\n     * @type {number}\n     * @private\n     */\n    Object.defineProperty(this, 'connectedAt', {\n      value: 0,\n      writable: true\n    });\n  }\n\n  /**\n   * Emits a debug event.\n   * @param {string} message The debug message\n   * @private\n   */\n  debug(message) {\n    this.manager.debug(message, this);\n  }\n\n  /**\n   * Connects the shard to the gateway.\n   * @private\n   * @returns {Promise<void>} A promise that will resolve if the shard turns ready successfully,\n   * or reject if we couldn't connect\n   */\n  connect() {\n    const {\n      client\n    } = this.manager;\n    if (this.connection?.readyState === WebSocket.OPEN && this.status === Status.Ready) {\n      return Promise.resolve();\n    }\n    const gateway = this.resumeURL ?? this.manager.gateway;\n    return new Promise((resolve, reject) => {\n      const cleanup = () => {\n        this.removeListener(WebSocketShardEvents.Close, onClose);\n        this.removeListener(WebSocketShardEvents.Ready, onReady);\n        this.removeListener(WebSocketShardEvents.Resumed, onResumed);\n        this.removeListener(WebSocketShardEvents.InvalidSession, onInvalidOrDestroyed);\n        this.removeListener(WebSocketShardEvents.Destroyed, onInvalidOrDestroyed);\n      };\n      const onReady = () => {\n        cleanup();\n        resolve();\n      };\n      const onResumed = () => {\n        cleanup();\n        resolve();\n      };\n      const onClose = event => {\n        cleanup();\n        reject(event);\n      };\n      const onInvalidOrDestroyed = () => {\n        cleanup();\n        // eslint-disable-next-line prefer-promise-reject-errors\n        reject();\n      };\n      this.once(WebSocketShardEvents.Ready, onReady);\n      this.once(WebSocketShardEvents.Resumed, onResumed);\n      this.once(WebSocketShardEvents.Close, onClose);\n      this.once(WebSocketShardEvents.InvalidSession, onInvalidOrDestroyed);\n      this.once(WebSocketShardEvents.Destroyed, onInvalidOrDestroyed);\n      if (this.connection?.readyState === WebSocket.OPEN) {\n        this.debug('An open connection was found, attempting an immediate identify.');\n        this.identify();\n        return;\n      }\n      if (this.connection) {\n        this.debug(`A connection object was found. Cleaning up before continuing.\n    State: ${CONNECTION_STATE[this.connection.readyState]}`);\n        this.destroy({\n          emit: false\n        });\n      }\n      const wsQuery = {\n        v: client.options.ws.version\n      };\n      if (zlib) {\n        this.inflate = new zlib.Inflate({\n          chunkSize: 65535,\n          flush: zlib.Z_SYNC_FLUSH,\n          to: WebSocket.encoding === 'json' ? 'string' : ''\n        });\n        wsQuery.compress = 'zlib-stream';\n      }\n      this.debug(`[CONNECT]\n    Gateway    : ${gateway}\n    Version    : ${client.options.ws.version}\n    Encoding   : ${WebSocket.encoding}\n    Compression: ${zlib ? 'zlib-stream' : 'none'}`);\n      this.status = this.status === Status.Disconnected ? Status.Reconnecting : Status.Connecting;\n      this.setHelloTimeout();\n      this.connectedAt = Date.now();\n\n      // Adding a handshake timeout to just make sure no zombie connection appears.\n      const ws = this.connection = WebSocket.create(gateway, wsQuery, {\n        handshakeTimeout: 30_000\n      });\n      ws.onopen = this.onOpen.bind(this);\n      ws.onmessage = this.onMessage.bind(this);\n      ws.onerror = this.onError.bind(this);\n      ws.onclose = this.onClose.bind(this);\n    });\n  }\n\n  /**\n   * Called whenever a connection is opened to the gateway.\n   * @private\n   */\n  onOpen() {\n    this.debug(`[CONNECTED] Took ${Date.now() - this.connectedAt}ms`);\n    this.status = Status.Nearly;\n  }\n\n  /**\n   * Called whenever a message is received.\n   * @param {MessageEvent} event Event received\n   * @private\n   */\n  onMessage(_ref) {\n    let {\n      data\n    } = _ref;\n    let raw;\n    if (data instanceof ArrayBuffer) data = new Uint8Array(data);\n    if (zlib) {\n      const l = data.length;\n      const flush = l >= 4 && data[l - 4] === 0x00 && data[l - 3] === 0x00 && data[l - 2] === 0xff && data[l - 1] === 0xff;\n      this.inflate.push(data, flush && zlib.Z_SYNC_FLUSH);\n      if (!flush) return;\n      raw = this.inflate.result;\n    } else {\n      raw = data;\n    }\n    let packet;\n    try {\n      packet = WebSocket.unpack(raw);\n    } catch (err) {\n      this.manager.client.emit(Events.ShardError, err, this.id);\n      return;\n    }\n    this.manager.client.emit(Events.Raw, packet, this.id);\n    if (packet.op === GatewayOpcodes.Dispatch) this.manager.emit(packet.t, packet.d, this.id);\n    this.onPacket(packet);\n  }\n\n  /**\n   * Called whenever an error occurs with the WebSocket.\n   * @param {ErrorEvent} event The error that occurred\n   * @private\n   */\n  onError(event) {\n    const error = event?.error ?? event;\n    if (!error) return;\n\n    /**\n     * Emitted whenever a shard's WebSocket encounters a connection error.\n     * @event Client#shardError\n     * @param {Error} error The encountered error\n     * @param {number} shardId The shard that encountered this error\n     */\n    this.manager.client.emit(Events.ShardError, error, this.id);\n  }\n\n  /**\n   * @external CloseEvent\n   * @see {@link https://developer.mozilla.org/en-US/docs/Web/API/CloseEvent}\n   */\n\n  /**\n   * @external ErrorEvent\n   * @see {@link https://developer.mozilla.org/en-US/docs/Web/API/ErrorEvent}\n   */\n\n  /**\n   * @external MessageEvent\n   * @see {@link https://developer.mozilla.org/en-US/docs/Web/API/MessageEvent}\n   */\n\n  /**\n   * Called whenever a connection to the gateway is closed.\n   * @param {CloseEvent} event Close event that was received\n   * @private\n   */\n  onClose(event) {\n    this.closeEmitted = true;\n    if (this.sequence !== -1) this.closeSequence = this.sequence;\n    this.sequence = -1;\n    this.setHeartbeatTimer(-1);\n    this.setHelloTimeout(-1);\n    // Clearing the WebSocket close timeout as close was emitted.\n    this.setWsCloseTimeout(-1);\n    // If we still have a connection object, clean up its listeners\n    if (this.connection) this._cleanupConnection();\n    this.status = Status.Disconnected;\n    this.emitClose(event);\n  }\n\n  /**\n   * This method is responsible to emit close event for this shard.\n   * This method helps the shard reconnect.\n   * @param {CloseEvent} [event] Close event that was received\n   */\n  emitClose() {\n    let event = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {\n      code: 1011,\n      reason: 'INTERNAL_ERROR',\n      wasClean: false\n    };\n    this.debug(`[CLOSE]\n    Event Code: ${event.code}\n    Clean     : ${event.wasClean}\n    Reason    : ${event.reason ?? 'No reason received'}`);\n    /**\n     * Emitted when a shard's WebSocket closes.\n     * @private\n     * @event WebSocketShard#close\n     * @param {CloseEvent} event The received event\n     */\n    this.emit(WebSocketShardEvents.Close, event);\n  }\n  /**\n   * Called whenever a packet is received.\n   * @param {Object} packet The received packet\n   * @private\n   */\n  onPacket(packet) {\n    if (!packet) {\n      this.debug(`Received broken packet: '${packet}'.`);\n      return;\n    }\n    switch (packet.t) {\n      case GatewayDispatchEvents.Ready:\n        /**\n         * Emitted when the shard receives the READY payload and is now waiting for guilds\n         * @event WebSocketShard#ready\n         */\n        this.emit(WebSocketShardEvents.Ready);\n        this.sessionId = packet.d.session_id;\n        this.resumeURL = packet.d.resume_gateway_url;\n        this.expectedGuilds = new Set(packet.d.guilds.map(d => d.id));\n        this.status = Status.WaitingForGuilds;\n        this.debug(`[READY] Session ${this.sessionId} | Resume url ${this.resumeURL}.`);\n        this.lastHeartbeatAcked = true;\n        this.sendHeartbeat('ReadyHeartbeat');\n        break;\n      case GatewayDispatchEvents.Resumed:\n        {\n          /**\n           * Emitted when the shard resumes successfully\n           * @event WebSocketShard#resumed\n           */\n          this.emit(WebSocketShardEvents.Resumed);\n          this.status = Status.Ready;\n          const replayed = packet.s - this.closeSequence;\n          this.debug(`[RESUMED] Session ${this.sessionId} | Replayed ${replayed} events.`);\n          this.lastHeartbeatAcked = true;\n          this.sendHeartbeat('ResumeHeartbeat');\n          break;\n        }\n    }\n    if (packet.s > this.sequence) this.sequence = packet.s;\n    switch (packet.op) {\n      case GatewayOpcodes.Hello:\n        this.setHelloTimeout(-1);\n        this.setHeartbeatTimer(packet.d.heartbeat_interval);\n        this.identify();\n        break;\n      case GatewayOpcodes.Reconnect:\n        this.debug('[RECONNECT] Discord asked us to reconnect');\n        this.destroy({\n          closeCode: 4_000\n        });\n        break;\n      case GatewayOpcodes.InvalidSession:\n        this.debug(`[INVALID SESSION] Resumable: ${packet.d}.`);\n        // If we can resume the session, do so immediately\n        if (packet.d) {\n          this.identifyResume();\n          return;\n        }\n        // Reset the sequence\n        this.sequence = -1;\n        // Reset the session id as it's invalid\n        this.sessionId = null;\n        // Set the status to reconnecting\n        this.status = Status.Reconnecting;\n        // Finally, emit the INVALID_SESSION event\n        /**\n         * Emitted when the session has been invalidated.\n         * @event WebSocketShard#invalidSession\n         */\n        this.emit(WebSocketShardEvents.InvalidSession);\n        break;\n      case GatewayOpcodes.HeartbeatAck:\n        this.ackHeartbeat();\n        break;\n      case GatewayOpcodes.Heartbeat:\n        this.sendHeartbeat('HeartbeatRequest', true);\n        break;\n      default:\n        this.manager.handlePacket(packet, this);\n        if (this.status === Status.WaitingForGuilds && packet.t === GatewayDispatchEvents.GuildCreate) {\n          this.expectedGuilds.delete(packet.d.id);\n          this.checkReady();\n        }\n    }\n  }\n\n  /**\n   * Checks if the shard can be marked as ready\n   * @private\n   */\n  checkReady() {\n    // Step 0. Clear the ready timeout, if it exists\n    if (this.readyTimeout) {\n      clearTimeout(this.readyTimeout);\n      this.readyTimeout = null;\n    }\n    // Step 1. If we don't have any other guilds pending, we are ready\n    if (!this.expectedGuilds.size) {\n      this.debug('Shard received all its guilds. Marking as fully ready.');\n      this.status = Status.Ready;\n\n      /**\n       * Emitted when the shard is fully ready.\n       * This event is emitted if:\n       * * all guilds were received by this shard\n       * * the ready timeout expired, and some guilds are unavailable\n       * @event WebSocketShard#allReady\n       * @param {?Set<string>} unavailableGuilds Set of unavailable guilds, if any\n       */\n      this.emit(WebSocketShardEvents.AllReady);\n      return;\n    }\n    const hasGuildsIntent = this.manager.client.options.intents.has(GatewayIntentBits.Guilds);\n    // Step 2. Create a timeout that will mark the shard as ready if there are still unavailable guilds\n    // * The timeout is 15 seconds by default\n    // * This can be optionally changed in the client options via the `waitGuildTimeout` option\n    // * a timeout time of zero will skip this timeout, which potentially could cause the Client to miss guilds.\n\n    const {\n      waitGuildTimeout\n    } = this.manager.client.options;\n    this.readyTimeout = setTimeout(() => {\n      this.debug(`Shard ${hasGuildsIntent ? 'did' : 'will'} not receive any more guild packets` + `${hasGuildsIntent ? ` in ${waitGuildTimeout} ms` : ''}.\\nUnavailable guild count: ${this.expectedGuilds.size}`);\n      this.readyTimeout = null;\n      this.status = Status.Ready;\n      this.emit(WebSocketShardEvents.AllReady, this.expectedGuilds);\n    }, hasGuildsIntent ? waitGuildTimeout : 0).unref();\n  }\n\n  /**\n   * Sets the HELLO packet timeout.\n   * @param {number} [time] If set to -1, it will clear the hello timeout\n   * @private\n   */\n  setHelloTimeout(time) {\n    if (time === -1) {\n      if (this.helloTimeout) {\n        this.debug('Clearing the HELLO timeout.');\n        clearTimeout(this.helloTimeout);\n        this.helloTimeout = null;\n      }\n      return;\n    }\n    this.debug('Setting a HELLO timeout for 20s.');\n    this.helloTimeout = setTimeout(() => {\n      this.debug('Did not receive HELLO in time. Destroying and connecting again.');\n      this.destroy({\n        reset: true,\n        closeCode: 4009\n      });\n    }, 20_000).unref();\n  }\n\n  /**\n   * Sets the WebSocket Close timeout.\n   * This method is responsible for detecting any zombie connections if the WebSocket fails to close properly.\n   * @param {number} [time] If set to -1, it will clear the timeout\n   * @private\n   */\n  setWsCloseTimeout(time) {\n    if (this.wsCloseTimeout) {\n      this.debug('[WebSocket] Clearing the close timeout.');\n      clearTimeout(this.wsCloseTimeout);\n    }\n    if (time === -1) {\n      this.wsCloseTimeout = null;\n      return;\n    }\n    this.wsCloseTimeout = setTimeout(() => {\n      this.setWsCloseTimeout(-1);\n      this.debug(`[WebSocket] Close Emitted: ${this.closeEmitted}`);\n      // Check if close event was emitted.\n      if (this.closeEmitted) {\n        this.debug(`[WebSocket] was closed. | WS State: ${CONNECTION_STATE[this.connection?.readyState ?? WebSocket.CLOSED]} | Close Emitted: ${this.closeEmitted}`);\n        // Setting the variable false to check for zombie connections.\n        this.closeEmitted = false;\n        return;\n      }\n      this.debug(`[WebSocket] did not close properly, assuming a zombie connection.\\nEmitting close and reconnecting again.`);\n      this.emitClose();\n      // Setting the variable false to check for zombie connections.\n      this.closeEmitted = false;\n    }, time).unref();\n  }\n\n  /**\n   * Sets the heartbeat timer for this shard.\n   * @param {number} time If -1, clears the interval, any other number sets an interval\n   * @private\n   */\n  setHeartbeatTimer(time) {\n    if (time === -1) {\n      if (this.heartbeatInterval) {\n        this.debug('Clearing the heartbeat interval.');\n        clearInterval(this.heartbeatInterval);\n        this.heartbeatInterval = null;\n      }\n      return;\n    }\n    this.debug(`Setting a heartbeat interval for ${time}ms.`);\n    // Sanity checks\n    if (this.heartbeatInterval) clearInterval(this.heartbeatInterval);\n    this.heartbeatInterval = setInterval(() => this.sendHeartbeat(), time).unref();\n  }\n\n  /**\n   * Sends a heartbeat to the WebSocket.\n   * If this shard didn't receive a heartbeat last time, it will destroy it and reconnect\n   * @param {string} [tag='HeartbeatTimer'] What caused this heartbeat to be sent\n   * @param {boolean} [ignoreHeartbeatAck] If we should send the heartbeat forcefully.\n   * @private\n   */\n  sendHeartbeat() {\n    let tag = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 'HeartbeatTimer';\n    let ignoreHeartbeatAck = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [Status.WaitingForGuilds, Status.Identifying, Status.Resuming].includes(this.status);\n    if (ignoreHeartbeatAck && !this.lastHeartbeatAcked) {\n      this.debug(`[${tag}] Didn't process heartbeat ack yet but we are still connected. Sending one now.`);\n    } else if (!this.lastHeartbeatAcked) {\n      this.debug(`[${tag}] Didn't receive a heartbeat ack last time, assuming zombie connection. Destroying and reconnecting.\n    Status          : ${STATUS_KEYS[this.status]}\n    Sequence        : ${this.sequence}\n    Connection State: ${this.connection ? CONNECTION_STATE[this.connection.readyState] : 'No Connection??'}`);\n      this.destroy({\n        reset: true,\n        closeCode: 4009\n      });\n      return;\n    }\n    this.debug(`[${tag}] Sending a heartbeat.`);\n    this.lastHeartbeatAcked = false;\n    this.lastPingTimestamp = Date.now();\n    this.send({\n      op: GatewayOpcodes.Heartbeat,\n      d: this.sequence\n    }, true);\n  }\n\n  /**\n   * Acknowledges a heartbeat.\n   * @private\n   */\n  ackHeartbeat() {\n    this.lastHeartbeatAcked = true;\n    const latency = Date.now() - this.lastPingTimestamp;\n    this.debug(`Heartbeat acknowledged, latency of ${latency}ms.`);\n    this.ping = latency;\n  }\n\n  /**\n   * Identifies the client on the connection.\n   * @private\n   * @returns {void}\n   */\n  identify() {\n    return this.sessionId ? this.identifyResume() : this.identifyNew();\n  }\n\n  /**\n   * Identifies as a new connection on the gateway.\n   * @private\n   */\n  identifyNew() {\n    const {\n      client\n    } = this.manager;\n    if (!client.token) {\n      this.debug('[IDENTIFY] No token available to identify a new session.');\n      return;\n    }\n    this.status = Status.Identifying;\n\n    // Clone the identify payload and assign the token and shard info\n    const d = {\n      ...client.options.ws,\n      intents: client.options.intents.bitfield,\n      token: client.token,\n      shard: [this.id, Number(client.options.shardCount)]\n    };\n    this.debug(`[IDENTIFY] Shard ${this.id}/${client.options.shardCount} with intents: ${d.intents}`);\n    this.send({\n      op: GatewayOpcodes.Identify,\n      d\n    }, true);\n  }\n\n  /**\n   * Resumes a session on the gateway.\n   * @private\n   */\n  identifyResume() {\n    if (!this.sessionId) {\n      this.debug('[RESUME] No session id was present; identifying as a new session.');\n      this.identifyNew();\n      return;\n    }\n    this.status = Status.Resuming;\n    this.debug(`[RESUME] Session ${this.sessionId}, sequence ${this.closeSequence}`);\n    const d = {\n      token: this.manager.client.token,\n      session_id: this.sessionId,\n      seq: this.closeSequence\n    };\n    this.send({\n      op: GatewayOpcodes.Resume,\n      d\n    }, true);\n  }\n\n  /**\n   * Adds a packet to the queue to be sent to the gateway.\n   * <warn>If you use this method, make sure you understand that you need to provide\n   * a full [Payload](https://discord.com/developers/docs/topics/gateway#commands-and-events-gateway-commands).\n   * Do not use this method if you don't know what you're doing.</warn>\n   * @param {Object} data The full packet to send\n   * @param {boolean} [important=false] If this packet should be added first in queue\n   */\n  send(data) {\n    let important = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n    this.ratelimit.queue[important ? 'unshift' : 'push'](data);\n    this.processQueue();\n  }\n\n  /**\n   * Sends data, bypassing the queue.\n   * @param {Object} data Packet to send\n   * @returns {void}\n   * @private\n   */\n  _send(data) {\n    if (this.connection?.readyState !== WebSocket.OPEN) {\n      this.debug(`Tried to send packet '${JSON.stringify(data).replaceAll(this.manager.client.token, this.manager.client._censoredToken)}' but no WebSocket is available!`);\n      this.destroy({\n        closeCode: 4_000\n      });\n      return;\n    }\n    this.connection.send(WebSocket.pack(data), err => {\n      if (err) this.manager.client.emit(Events.ShardError, err, this.id);\n    });\n  }\n\n  /**\n   * Processes the current WebSocket queue.\n   * @returns {void}\n   * @private\n   */\n  processQueue() {\n    if (this.ratelimit.remaining === 0) return;\n    if (this.ratelimit.queue.length === 0) return;\n    if (this.ratelimit.remaining === this.ratelimit.total) {\n      this.ratelimit.timer = setTimeout(() => {\n        this.ratelimit.remaining = this.ratelimit.total;\n        this.processQueue();\n      }, this.ratelimit.time).unref();\n    }\n    while (this.ratelimit.remaining > 0) {\n      const item = this.ratelimit.queue.shift();\n      if (!item) return;\n      this._send(item);\n      this.ratelimit.remaining--;\n    }\n  }\n\n  /**\n   * Destroys this shard and closes its WebSocket connection.\n   * @param {Object} [options={ closeCode: 1000, reset: false, emit: true, log: true }] Options for destroying the shard\n   * @private\n   */\n  destroy() {\n    let {\n      closeCode = 1_000,\n      reset = false,\n      emit = true,\n      log = true\n    } = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    if (log) {\n      this.debug(`[DESTROY]\n    Close Code    : ${closeCode}\n    Reset         : ${reset}\n    Emit DESTROYED: ${emit}`);\n    }\n\n    // Step 0: Remove all timers\n    this.setHeartbeatTimer(-1);\n    this.setHelloTimeout(-1);\n    this.debug(`[WebSocket] Destroy: Attempting to close the WebSocket. | WS State: ${CONNECTION_STATE[this.connection?.readyState ?? WebSocket.CLOSED]}`);\n    // Step 1: Close the WebSocket connection, if any, otherwise, emit DESTROYED\n    if (this.connection) {\n      // If the connection is currently opened, we will (hopefully) receive close\n      if (this.connection.readyState === WebSocket.OPEN) {\n        this.connection.close(closeCode);\n        this.debug(`[WebSocket] Close: Tried closing. | WS State: ${CONNECTION_STATE[this.connection.readyState]}`);\n      } else {\n        // Connection is not OPEN\n        this.debug(`WS State: ${CONNECTION_STATE[this.connection.readyState]}`);\n        // Remove listeners from the connection\n        this._cleanupConnection();\n        // Attempt to close the connection just in case\n        try {\n          this.connection.close(closeCode);\n        } catch (err) {\n          this.debug(`[WebSocket] Close: Something went wrong while closing the WebSocket: ${err.message || err}. Forcefully terminating the connection | WS State: ${CONNECTION_STATE[this.connection.readyState]}`);\n          this.connection.terminate();\n        }\n        // Emit the destroyed event if needed\n        if (emit) this._emitDestroyed();\n      }\n    } else if (emit) {\n      // We requested a destroy, but we had no connection. Emit destroyed\n      this._emitDestroyed();\n    }\n    if (this.connection?.readyState === WebSocket.CLOSING || this.connection?.readyState === WebSocket.CLOSED) {\n      this.closeEmitted = false;\n      this.debug(`[WebSocket] Adding a WebSocket close timeout to ensure a correct WS reconnect.\n        Timeout: ${this.manager.client.options.closeTimeout}ms`);\n      this.setWsCloseTimeout(this.manager.client.options.closeTimeout);\n    }\n\n    // Step 2: Null the connection object\n    this.connection = null;\n\n    // Step 3: Set the shard status to disconnected\n    this.status = Status.Disconnected;\n\n    // Step 4: Cache the old sequence (use to attempt a resume)\n    if (this.sequence !== -1) this.closeSequence = this.sequence;\n\n    // Step 5: Reset the sequence, resume url and session id if requested\n    if (reset) {\n      this.sequence = -1;\n      this.sessionId = null;\n      this.resumeURL = null;\n    }\n\n    // Step 6: reset the rate limit data\n    this.ratelimit.remaining = this.ratelimit.total;\n    this.ratelimit.queue.length = 0;\n    if (this.ratelimit.timer) {\n      clearTimeout(this.ratelimit.timer);\n      this.ratelimit.timer = null;\n    }\n  }\n\n  /**\n   * Cleans up the WebSocket connection listeners.\n   * @private\n   */\n  _cleanupConnection() {\n    this.connection.onopen = this.connection.onclose = this.connection.onmessage = null;\n    this.connection.onerror = () => null;\n  }\n\n  /**\n   * Emits the DESTROYED event on the shard\n   * @private\n   */\n  _emitDestroyed() {\n    /**\n     * Emitted when a shard is destroyed, but no WebSocket connection was present.\n     * @private\n     * @event WebSocketShard#destroyed\n     */\n    this.emit(WebSocketShardEvents.Destroyed);\n  }\n}\nmodule.exports = WebSocketShard;","map":{"version":3,"names":["EventEmitter","require","setTimeout","setInterval","clearTimeout","clearInterval","GatewayDispatchEvents","GatewayIntentBits","GatewayOpcodes","WebSocket","Events","Status","WebSocketShardEvents","STATUS_KEYS","Object","keys","CONNECTION_STATE","zlib","WebSocketShard","constructor","manager","id","status","Idle","sequence","closeSequence","sessionId","resumeURL","ping","lastPingTimestamp","lastHeartbeatAcked","closeEmitted","defineProperty","value","queue","total","remaining","time","timer","writable","debug","message","connect","client","connection","readyState","OPEN","Ready","Promise","resolve","gateway","reject","cleanup","removeListener","Close","onClose","onReady","Resumed","onResumed","InvalidSession","onInvalidOrDestroyed","Destroyed","event","once","identify","destroy","emit","wsQuery","v","options","ws","version","inflate","Inflate","chunkSize","flush","Z_SYNC_FLUSH","to","encoding","compress","Disconnected","Reconnecting","Connecting","setHelloTimeout","connectedAt","Date","now","create","handshakeTimeout","onopen","onOpen","bind","onmessage","onMessage","onerror","onError","onclose","Nearly","data","raw","ArrayBuffer","Uint8Array","l","length","push","result","packet","unpack","err","ShardError","Raw","op","Dispatch","t","d","onPacket","error","setHeartbeatTimer","setWsCloseTimeout","_cleanupConnection","emitClose","code","reason","wasClean","session_id","resume_gateway_url","expectedGuilds","Set","guilds","map","WaitingForGuilds","sendHeartbeat","replayed","s","Hello","heartbeat_interval","Reconnect","closeCode","identifyResume","HeartbeatAck","ackHeartbeat","Heartbeat","handlePacket","GuildCreate","delete","checkReady","readyTimeout","size","AllReady","hasGuildsIntent","intents","has","Guilds","waitGuildTimeout","unref","helloTimeout","reset","wsCloseTimeout","CLOSED","heartbeatInterval","tag","ignoreHeartbeatAck","Identifying","Resuming","includes","send","latency","identifyNew","token","bitfield","shard","Number","shardCount","Identify","seq","Resume","important","ratelimit","processQueue","_send","JSON","stringify","replaceAll","_censoredToken","pack","item","shift","log","close","terminate","_emitDestroyed","CLOSING","closeTimeout","module","exports"],"sources":["J:/Coding/Projekts/Web/JavaScript/sillcode.tech/node_modules/discord.js/src/client/websocket/WebSocketShard.js"],"sourcesContent":["'use strict';\n\nconst EventEmitter = require('node:events');\nconst { setTimeout, setInterval, clearTimeout, clearInterval } = require('node:timers');\nconst { GatewayDispatchEvents, GatewayIntentBits, GatewayOpcodes } = require('discord-api-types/v10');\nconst WebSocket = require('../../WebSocket');\nconst Events = require('../../util/Events');\nconst Status = require('../../util/Status');\nconst WebSocketShardEvents = require('../../util/WebSocketShardEvents');\n\nconst STATUS_KEYS = Object.keys(Status);\nconst CONNECTION_STATE = Object.keys(WebSocket.WebSocket);\n\nlet zlib;\n\ntry {\n  zlib = require('zlib-sync');\n} catch {} // eslint-disable-line no-empty\n\n/**\n * Represents a Shard's WebSocket connection\n * @extends {EventEmitter}\n */\nclass WebSocketShard extends EventEmitter {\n  constructor(manager, id) {\n    super();\n\n    /**\n     * The WebSocketManager of the shard\n     * @type {WebSocketManager}\n     */\n    this.manager = manager;\n\n    /**\n     * The shard's id\n     * @type {number}\n     */\n    this.id = id;\n\n    /**\n     * The current status of the shard\n     * @type {Status}\n     */\n    this.status = Status.Idle;\n\n    /**\n     * The current sequence of the shard\n     * @type {number}\n     * @private\n     */\n    this.sequence = -1;\n\n    /**\n     * The sequence of the shard after close\n     * @type {number}\n     * @private\n     */\n    this.closeSequence = 0;\n\n    /**\n     * The current session id of the shard\n     * @type {?string}\n     * @private\n     */\n    this.sessionId = null;\n\n    /**\n     * The resume url for this shard\n     * @type {?string}\n     * @private\n     */\n    this.resumeURL = null;\n\n    /**\n     * The previous heartbeat ping of the shard\n     * @type {number}\n     */\n    this.ping = -1;\n\n    /**\n     * The last time a ping was sent (a timestamp)\n     * @type {number}\n     */\n    this.lastPingTimestamp = -1;\n\n    /**\n     * If we received a heartbeat ack back. Used to identify zombie connections\n     * @type {boolean}\n     * @private\n     */\n    this.lastHeartbeatAcked = true;\n\n    /**\n     * Used to prevent calling {@link WebSocketShard#event:close} twice while closing or terminating the WebSocket.\n     * @type {boolean}\n     * @private\n     */\n    this.closeEmitted = false;\n\n    /**\n     * Contains the rate limit queue and metadata\n     * @name WebSocketShard#ratelimit\n     * @type {Object}\n     * @private\n     */\n    Object.defineProperty(this, 'ratelimit', {\n      value: {\n        queue: [],\n        total: 120,\n        remaining: 120,\n        time: 60e3,\n        timer: null,\n      },\n    });\n\n    /**\n     * The WebSocket connection for the current shard\n     * @name WebSocketShard#connection\n     * @type {?WebSocket}\n     * @private\n     */\n    Object.defineProperty(this, 'connection', { value: null, writable: true });\n\n    /**\n     * @external Inflate\n     * @see {@link https://www.npmjs.com/package/zlib-sync}\n     */\n\n    /**\n     * The compression to use\n     * @name WebSocketShard#inflate\n     * @type {?Inflate}\n     * @private\n     */\n    Object.defineProperty(this, 'inflate', { value: null, writable: true });\n\n    /**\n     * The HELLO timeout\n     * @name WebSocketShard#helloTimeout\n     * @type {?NodeJS.Timeout}\n     * @private\n     */\n    Object.defineProperty(this, 'helloTimeout', { value: null, writable: true });\n\n    /**\n     * The WebSocket timeout.\n     * @name WebSocketShard#wsCloseTimeout\n     * @type {?NodeJS.Timeout}\n     * @private\n     */\n    Object.defineProperty(this, 'wsCloseTimeout', { value: null, writable: true });\n\n    /**\n     * If the manager attached its event handlers on the shard\n     * @name WebSocketShard#eventsAttached\n     * @type {boolean}\n     * @private\n     */\n    Object.defineProperty(this, 'eventsAttached', { value: false, writable: true });\n\n    /**\n     * A set of guild ids this shard expects to receive\n     * @name WebSocketShard#expectedGuilds\n     * @type {?Set<string>}\n     * @private\n     */\n    Object.defineProperty(this, 'expectedGuilds', { value: null, writable: true });\n\n    /**\n     * The ready timeout\n     * @name WebSocketShard#readyTimeout\n     * @type {?NodeJS.Timeout}\n     * @private\n     */\n    Object.defineProperty(this, 'readyTimeout', { value: null, writable: true });\n\n    /**\n     * Time when the WebSocket connection was opened\n     * @name WebSocketShard#connectedAt\n     * @type {number}\n     * @private\n     */\n    Object.defineProperty(this, 'connectedAt', { value: 0, writable: true });\n  }\n\n  /**\n   * Emits a debug event.\n   * @param {string} message The debug message\n   * @private\n   */\n  debug(message) {\n    this.manager.debug(message, this);\n  }\n\n  /**\n   * Connects the shard to the gateway.\n   * @private\n   * @returns {Promise<void>} A promise that will resolve if the shard turns ready successfully,\n   * or reject if we couldn't connect\n   */\n  connect() {\n    const { client } = this.manager;\n\n    if (this.connection?.readyState === WebSocket.OPEN && this.status === Status.Ready) {\n      return Promise.resolve();\n    }\n\n    const gateway = this.resumeURL ?? this.manager.gateway;\n\n    return new Promise((resolve, reject) => {\n      const cleanup = () => {\n        this.removeListener(WebSocketShardEvents.Close, onClose);\n        this.removeListener(WebSocketShardEvents.Ready, onReady);\n        this.removeListener(WebSocketShardEvents.Resumed, onResumed);\n        this.removeListener(WebSocketShardEvents.InvalidSession, onInvalidOrDestroyed);\n        this.removeListener(WebSocketShardEvents.Destroyed, onInvalidOrDestroyed);\n      };\n\n      const onReady = () => {\n        cleanup();\n        resolve();\n      };\n\n      const onResumed = () => {\n        cleanup();\n        resolve();\n      };\n\n      const onClose = event => {\n        cleanup();\n        reject(event);\n      };\n\n      const onInvalidOrDestroyed = () => {\n        cleanup();\n        // eslint-disable-next-line prefer-promise-reject-errors\n        reject();\n      };\n\n      this.once(WebSocketShardEvents.Ready, onReady);\n      this.once(WebSocketShardEvents.Resumed, onResumed);\n      this.once(WebSocketShardEvents.Close, onClose);\n      this.once(WebSocketShardEvents.InvalidSession, onInvalidOrDestroyed);\n      this.once(WebSocketShardEvents.Destroyed, onInvalidOrDestroyed);\n\n      if (this.connection?.readyState === WebSocket.OPEN) {\n        this.debug('An open connection was found, attempting an immediate identify.');\n        this.identify();\n        return;\n      }\n\n      if (this.connection) {\n        this.debug(`A connection object was found. Cleaning up before continuing.\n    State: ${CONNECTION_STATE[this.connection.readyState]}`);\n        this.destroy({ emit: false });\n      }\n\n      const wsQuery = { v: client.options.ws.version };\n\n      if (zlib) {\n        this.inflate = new zlib.Inflate({\n          chunkSize: 65535,\n          flush: zlib.Z_SYNC_FLUSH,\n          to: WebSocket.encoding === 'json' ? 'string' : '',\n        });\n        wsQuery.compress = 'zlib-stream';\n      }\n\n      this.debug(\n        `[CONNECT]\n    Gateway    : ${gateway}\n    Version    : ${client.options.ws.version}\n    Encoding   : ${WebSocket.encoding}\n    Compression: ${zlib ? 'zlib-stream' : 'none'}`,\n      );\n\n      this.status = this.status === Status.Disconnected ? Status.Reconnecting : Status.Connecting;\n      this.setHelloTimeout();\n\n      this.connectedAt = Date.now();\n\n      // Adding a handshake timeout to just make sure no zombie connection appears.\n      const ws = (this.connection = WebSocket.create(gateway, wsQuery, { handshakeTimeout: 30_000 }));\n      ws.onopen = this.onOpen.bind(this);\n      ws.onmessage = this.onMessage.bind(this);\n      ws.onerror = this.onError.bind(this);\n      ws.onclose = this.onClose.bind(this);\n    });\n  }\n\n  /**\n   * Called whenever a connection is opened to the gateway.\n   * @private\n   */\n  onOpen() {\n    this.debug(`[CONNECTED] Took ${Date.now() - this.connectedAt}ms`);\n    this.status = Status.Nearly;\n  }\n\n  /**\n   * Called whenever a message is received.\n   * @param {MessageEvent} event Event received\n   * @private\n   */\n  onMessage({ data }) {\n    let raw;\n    if (data instanceof ArrayBuffer) data = new Uint8Array(data);\n    if (zlib) {\n      const l = data.length;\n      const flush =\n        l >= 4 && data[l - 4] === 0x00 && data[l - 3] === 0x00 && data[l - 2] === 0xff && data[l - 1] === 0xff;\n\n      this.inflate.push(data, flush && zlib.Z_SYNC_FLUSH);\n      if (!flush) return;\n      raw = this.inflate.result;\n    } else {\n      raw = data;\n    }\n    let packet;\n    try {\n      packet = WebSocket.unpack(raw);\n    } catch (err) {\n      this.manager.client.emit(Events.ShardError, err, this.id);\n      return;\n    }\n    this.manager.client.emit(Events.Raw, packet, this.id);\n    if (packet.op === GatewayOpcodes.Dispatch) this.manager.emit(packet.t, packet.d, this.id);\n    this.onPacket(packet);\n  }\n\n  /**\n   * Called whenever an error occurs with the WebSocket.\n   * @param {ErrorEvent} event The error that occurred\n   * @private\n   */\n  onError(event) {\n    const error = event?.error ?? event;\n    if (!error) return;\n\n    /**\n     * Emitted whenever a shard's WebSocket encounters a connection error.\n     * @event Client#shardError\n     * @param {Error} error The encountered error\n     * @param {number} shardId The shard that encountered this error\n     */\n    this.manager.client.emit(Events.ShardError, error, this.id);\n  }\n\n  /**\n   * @external CloseEvent\n   * @see {@link https://developer.mozilla.org/en-US/docs/Web/API/CloseEvent}\n   */\n\n  /**\n   * @external ErrorEvent\n   * @see {@link https://developer.mozilla.org/en-US/docs/Web/API/ErrorEvent}\n   */\n\n  /**\n   * @external MessageEvent\n   * @see {@link https://developer.mozilla.org/en-US/docs/Web/API/MessageEvent}\n   */\n\n  /**\n   * Called whenever a connection to the gateway is closed.\n   * @param {CloseEvent} event Close event that was received\n   * @private\n   */\n  onClose(event) {\n    this.closeEmitted = true;\n    if (this.sequence !== -1) this.closeSequence = this.sequence;\n    this.sequence = -1;\n    this.setHeartbeatTimer(-1);\n    this.setHelloTimeout(-1);\n    // Clearing the WebSocket close timeout as close was emitted.\n    this.setWsCloseTimeout(-1);\n    // If we still have a connection object, clean up its listeners\n    if (this.connection) this._cleanupConnection();\n    this.status = Status.Disconnected;\n    this.emitClose(event);\n  }\n\n  /**\n   * This method is responsible to emit close event for this shard.\n   * This method helps the shard reconnect.\n   * @param {CloseEvent} [event] Close event that was received\n   */\n  emitClose(\n    event = {\n      code: 1011,\n      reason: 'INTERNAL_ERROR',\n      wasClean: false,\n    },\n  ) {\n    this.debug(`[CLOSE]\n    Event Code: ${event.code}\n    Clean     : ${event.wasClean}\n    Reason    : ${event.reason ?? 'No reason received'}`);\n    /**\n     * Emitted when a shard's WebSocket closes.\n     * @private\n     * @event WebSocketShard#close\n     * @param {CloseEvent} event The received event\n     */\n    this.emit(WebSocketShardEvents.Close, event);\n  }\n  /**\n   * Called whenever a packet is received.\n   * @param {Object} packet The received packet\n   * @private\n   */\n  onPacket(packet) {\n    if (!packet) {\n      this.debug(`Received broken packet: '${packet}'.`);\n      return;\n    }\n\n    switch (packet.t) {\n      case GatewayDispatchEvents.Ready:\n        /**\n         * Emitted when the shard receives the READY payload and is now waiting for guilds\n         * @event WebSocketShard#ready\n         */\n        this.emit(WebSocketShardEvents.Ready);\n\n        this.sessionId = packet.d.session_id;\n        this.resumeURL = packet.d.resume_gateway_url;\n        this.expectedGuilds = new Set(packet.d.guilds.map(d => d.id));\n        this.status = Status.WaitingForGuilds;\n        this.debug(`[READY] Session ${this.sessionId} | Resume url ${this.resumeURL}.`);\n        this.lastHeartbeatAcked = true;\n        this.sendHeartbeat('ReadyHeartbeat');\n        break;\n      case GatewayDispatchEvents.Resumed: {\n        /**\n         * Emitted when the shard resumes successfully\n         * @event WebSocketShard#resumed\n         */\n        this.emit(WebSocketShardEvents.Resumed);\n\n        this.status = Status.Ready;\n        const replayed = packet.s - this.closeSequence;\n        this.debug(`[RESUMED] Session ${this.sessionId} | Replayed ${replayed} events.`);\n        this.lastHeartbeatAcked = true;\n        this.sendHeartbeat('ResumeHeartbeat');\n        break;\n      }\n    }\n\n    if (packet.s > this.sequence) this.sequence = packet.s;\n\n    switch (packet.op) {\n      case GatewayOpcodes.Hello:\n        this.setHelloTimeout(-1);\n        this.setHeartbeatTimer(packet.d.heartbeat_interval);\n        this.identify();\n        break;\n      case GatewayOpcodes.Reconnect:\n        this.debug('[RECONNECT] Discord asked us to reconnect');\n        this.destroy({ closeCode: 4_000 });\n        break;\n      case GatewayOpcodes.InvalidSession:\n        this.debug(`[INVALID SESSION] Resumable: ${packet.d}.`);\n        // If we can resume the session, do so immediately\n        if (packet.d) {\n          this.identifyResume();\n          return;\n        }\n        // Reset the sequence\n        this.sequence = -1;\n        // Reset the session id as it's invalid\n        this.sessionId = null;\n        // Set the status to reconnecting\n        this.status = Status.Reconnecting;\n        // Finally, emit the INVALID_SESSION event\n        /**\n         * Emitted when the session has been invalidated.\n         * @event WebSocketShard#invalidSession\n         */\n        this.emit(WebSocketShardEvents.InvalidSession);\n        break;\n      case GatewayOpcodes.HeartbeatAck:\n        this.ackHeartbeat();\n        break;\n      case GatewayOpcodes.Heartbeat:\n        this.sendHeartbeat('HeartbeatRequest', true);\n        break;\n      default:\n        this.manager.handlePacket(packet, this);\n        if (this.status === Status.WaitingForGuilds && packet.t === GatewayDispatchEvents.GuildCreate) {\n          this.expectedGuilds.delete(packet.d.id);\n          this.checkReady();\n        }\n    }\n  }\n\n  /**\n   * Checks if the shard can be marked as ready\n   * @private\n   */\n  checkReady() {\n    // Step 0. Clear the ready timeout, if it exists\n    if (this.readyTimeout) {\n      clearTimeout(this.readyTimeout);\n      this.readyTimeout = null;\n    }\n    // Step 1. If we don't have any other guilds pending, we are ready\n    if (!this.expectedGuilds.size) {\n      this.debug('Shard received all its guilds. Marking as fully ready.');\n      this.status = Status.Ready;\n\n      /**\n       * Emitted when the shard is fully ready.\n       * This event is emitted if:\n       * * all guilds were received by this shard\n       * * the ready timeout expired, and some guilds are unavailable\n       * @event WebSocketShard#allReady\n       * @param {?Set<string>} unavailableGuilds Set of unavailable guilds, if any\n       */\n      this.emit(WebSocketShardEvents.AllReady);\n      return;\n    }\n    const hasGuildsIntent = this.manager.client.options.intents.has(GatewayIntentBits.Guilds);\n    // Step 2. Create a timeout that will mark the shard as ready if there are still unavailable guilds\n    // * The timeout is 15 seconds by default\n    // * This can be optionally changed in the client options via the `waitGuildTimeout` option\n    // * a timeout time of zero will skip this timeout, which potentially could cause the Client to miss guilds.\n\n    const { waitGuildTimeout } = this.manager.client.options;\n\n    this.readyTimeout = setTimeout(\n      () => {\n        this.debug(\n          `Shard ${hasGuildsIntent ? 'did' : 'will'} not receive any more guild packets` +\n            `${hasGuildsIntent ? ` in ${waitGuildTimeout} ms` : ''}.\\nUnavailable guild count: ${\n              this.expectedGuilds.size\n            }`,\n        );\n\n        this.readyTimeout = null;\n\n        this.status = Status.Ready;\n\n        this.emit(WebSocketShardEvents.AllReady, this.expectedGuilds);\n      },\n      hasGuildsIntent ? waitGuildTimeout : 0,\n    ).unref();\n  }\n\n  /**\n   * Sets the HELLO packet timeout.\n   * @param {number} [time] If set to -1, it will clear the hello timeout\n   * @private\n   */\n  setHelloTimeout(time) {\n    if (time === -1) {\n      if (this.helloTimeout) {\n        this.debug('Clearing the HELLO timeout.');\n        clearTimeout(this.helloTimeout);\n        this.helloTimeout = null;\n      }\n      return;\n    }\n    this.debug('Setting a HELLO timeout for 20s.');\n    this.helloTimeout = setTimeout(() => {\n      this.debug('Did not receive HELLO in time. Destroying and connecting again.');\n      this.destroy({ reset: true, closeCode: 4009 });\n    }, 20_000).unref();\n  }\n\n  /**\n   * Sets the WebSocket Close timeout.\n   * This method is responsible for detecting any zombie connections if the WebSocket fails to close properly.\n   * @param {number} [time] If set to -1, it will clear the timeout\n   * @private\n   */\n  setWsCloseTimeout(time) {\n    if (this.wsCloseTimeout) {\n      this.debug('[WebSocket] Clearing the close timeout.');\n      clearTimeout(this.wsCloseTimeout);\n    }\n    if (time === -1) {\n      this.wsCloseTimeout = null;\n      return;\n    }\n    this.wsCloseTimeout = setTimeout(() => {\n      this.setWsCloseTimeout(-1);\n      this.debug(`[WebSocket] Close Emitted: ${this.closeEmitted}`);\n      // Check if close event was emitted.\n      if (this.closeEmitted) {\n        this.debug(\n          `[WebSocket] was closed. | WS State: ${\n            CONNECTION_STATE[this.connection?.readyState ?? WebSocket.CLOSED]\n          } | Close Emitted: ${this.closeEmitted}`,\n        );\n        // Setting the variable false to check for zombie connections.\n        this.closeEmitted = false;\n        return;\n      }\n\n      this.debug(\n        `[WebSocket] did not close properly, assuming a zombie connection.\\nEmitting close and reconnecting again.`,\n      );\n\n      this.emitClose();\n      // Setting the variable false to check for zombie connections.\n      this.closeEmitted = false;\n    }, time).unref();\n  }\n\n  /**\n   * Sets the heartbeat timer for this shard.\n   * @param {number} time If -1, clears the interval, any other number sets an interval\n   * @private\n   */\n  setHeartbeatTimer(time) {\n    if (time === -1) {\n      if (this.heartbeatInterval) {\n        this.debug('Clearing the heartbeat interval.');\n        clearInterval(this.heartbeatInterval);\n        this.heartbeatInterval = null;\n      }\n      return;\n    }\n    this.debug(`Setting a heartbeat interval for ${time}ms.`);\n    // Sanity checks\n    if (this.heartbeatInterval) clearInterval(this.heartbeatInterval);\n    this.heartbeatInterval = setInterval(() => this.sendHeartbeat(), time).unref();\n  }\n\n  /**\n   * Sends a heartbeat to the WebSocket.\n   * If this shard didn't receive a heartbeat last time, it will destroy it and reconnect\n   * @param {string} [tag='HeartbeatTimer'] What caused this heartbeat to be sent\n   * @param {boolean} [ignoreHeartbeatAck] If we should send the heartbeat forcefully.\n   * @private\n   */\n  sendHeartbeat(\n    tag = 'HeartbeatTimer',\n    ignoreHeartbeatAck = [Status.WaitingForGuilds, Status.Identifying, Status.Resuming].includes(this.status),\n  ) {\n    if (ignoreHeartbeatAck && !this.lastHeartbeatAcked) {\n      this.debug(`[${tag}] Didn't process heartbeat ack yet but we are still connected. Sending one now.`);\n    } else if (!this.lastHeartbeatAcked) {\n      this.debug(\n        `[${tag}] Didn't receive a heartbeat ack last time, assuming zombie connection. Destroying and reconnecting.\n    Status          : ${STATUS_KEYS[this.status]}\n    Sequence        : ${this.sequence}\n    Connection State: ${this.connection ? CONNECTION_STATE[this.connection.readyState] : 'No Connection??'}`,\n      );\n\n      this.destroy({ reset: true, closeCode: 4009 });\n      return;\n    }\n\n    this.debug(`[${tag}] Sending a heartbeat.`);\n    this.lastHeartbeatAcked = false;\n    this.lastPingTimestamp = Date.now();\n    this.send({ op: GatewayOpcodes.Heartbeat, d: this.sequence }, true);\n  }\n\n  /**\n   * Acknowledges a heartbeat.\n   * @private\n   */\n  ackHeartbeat() {\n    this.lastHeartbeatAcked = true;\n    const latency = Date.now() - this.lastPingTimestamp;\n    this.debug(`Heartbeat acknowledged, latency of ${latency}ms.`);\n    this.ping = latency;\n  }\n\n  /**\n   * Identifies the client on the connection.\n   * @private\n   * @returns {void}\n   */\n  identify() {\n    return this.sessionId ? this.identifyResume() : this.identifyNew();\n  }\n\n  /**\n   * Identifies as a new connection on the gateway.\n   * @private\n   */\n  identifyNew() {\n    const { client } = this.manager;\n    if (!client.token) {\n      this.debug('[IDENTIFY] No token available to identify a new session.');\n      return;\n    }\n\n    this.status = Status.Identifying;\n\n    // Clone the identify payload and assign the token and shard info\n    const d = {\n      ...client.options.ws,\n      intents: client.options.intents.bitfield,\n      token: client.token,\n      shard: [this.id, Number(client.options.shardCount)],\n    };\n\n    this.debug(`[IDENTIFY] Shard ${this.id}/${client.options.shardCount} with intents: ${d.intents}`);\n    this.send({ op: GatewayOpcodes.Identify, d }, true);\n  }\n\n  /**\n   * Resumes a session on the gateway.\n   * @private\n   */\n  identifyResume() {\n    if (!this.sessionId) {\n      this.debug('[RESUME] No session id was present; identifying as a new session.');\n      this.identifyNew();\n      return;\n    }\n\n    this.status = Status.Resuming;\n\n    this.debug(`[RESUME] Session ${this.sessionId}, sequence ${this.closeSequence}`);\n\n    const d = {\n      token: this.manager.client.token,\n      session_id: this.sessionId,\n      seq: this.closeSequence,\n    };\n\n    this.send({ op: GatewayOpcodes.Resume, d }, true);\n  }\n\n  /**\n   * Adds a packet to the queue to be sent to the gateway.\n   * <warn>If you use this method, make sure you understand that you need to provide\n   * a full [Payload](https://discord.com/developers/docs/topics/gateway#commands-and-events-gateway-commands).\n   * Do not use this method if you don't know what you're doing.</warn>\n   * @param {Object} data The full packet to send\n   * @param {boolean} [important=false] If this packet should be added first in queue\n   */\n  send(data, important = false) {\n    this.ratelimit.queue[important ? 'unshift' : 'push'](data);\n    this.processQueue();\n  }\n\n  /**\n   * Sends data, bypassing the queue.\n   * @param {Object} data Packet to send\n   * @returns {void}\n   * @private\n   */\n  _send(data) {\n    if (this.connection?.readyState !== WebSocket.OPEN) {\n      this.debug(\n        `Tried to send packet '${JSON.stringify(data).replaceAll(\n          this.manager.client.token,\n          this.manager.client._censoredToken,\n        )}' but no WebSocket is available!`,\n      );\n      this.destroy({ closeCode: 4_000 });\n      return;\n    }\n\n    this.connection.send(WebSocket.pack(data), err => {\n      if (err) this.manager.client.emit(Events.ShardError, err, this.id);\n    });\n  }\n\n  /**\n   * Processes the current WebSocket queue.\n   * @returns {void}\n   * @private\n   */\n  processQueue() {\n    if (this.ratelimit.remaining === 0) return;\n    if (this.ratelimit.queue.length === 0) return;\n    if (this.ratelimit.remaining === this.ratelimit.total) {\n      this.ratelimit.timer = setTimeout(() => {\n        this.ratelimit.remaining = this.ratelimit.total;\n        this.processQueue();\n      }, this.ratelimit.time).unref();\n    }\n    while (this.ratelimit.remaining > 0) {\n      const item = this.ratelimit.queue.shift();\n      if (!item) return;\n      this._send(item);\n      this.ratelimit.remaining--;\n    }\n  }\n\n  /**\n   * Destroys this shard and closes its WebSocket connection.\n   * @param {Object} [options={ closeCode: 1000, reset: false, emit: true, log: true }] Options for destroying the shard\n   * @private\n   */\n  destroy({ closeCode = 1_000, reset = false, emit = true, log = true } = {}) {\n    if (log) {\n      this.debug(`[DESTROY]\n    Close Code    : ${closeCode}\n    Reset         : ${reset}\n    Emit DESTROYED: ${emit}`);\n    }\n\n    // Step 0: Remove all timers\n    this.setHeartbeatTimer(-1);\n    this.setHelloTimeout(-1);\n\n    this.debug(\n      `[WebSocket] Destroy: Attempting to close the WebSocket. | WS State: ${\n        CONNECTION_STATE[this.connection?.readyState ?? WebSocket.CLOSED]\n      }`,\n    );\n    // Step 1: Close the WebSocket connection, if any, otherwise, emit DESTROYED\n    if (this.connection) {\n      // If the connection is currently opened, we will (hopefully) receive close\n      if (this.connection.readyState === WebSocket.OPEN) {\n        this.connection.close(closeCode);\n        this.debug(`[WebSocket] Close: Tried closing. | WS State: ${CONNECTION_STATE[this.connection.readyState]}`);\n      } else {\n        // Connection is not OPEN\n        this.debug(`WS State: ${CONNECTION_STATE[this.connection.readyState]}`);\n        // Remove listeners from the connection\n        this._cleanupConnection();\n        // Attempt to close the connection just in case\n        try {\n          this.connection.close(closeCode);\n        } catch (err) {\n          this.debug(\n            `[WebSocket] Close: Something went wrong while closing the WebSocket: ${\n              err.message || err\n            }. Forcefully terminating the connection | WS State: ${CONNECTION_STATE[this.connection.readyState]}`,\n          );\n          this.connection.terminate();\n        }\n        // Emit the destroyed event if needed\n        if (emit) this._emitDestroyed();\n      }\n    } else if (emit) {\n      // We requested a destroy, but we had no connection. Emit destroyed\n      this._emitDestroyed();\n    }\n\n    if (this.connection?.readyState === WebSocket.CLOSING || this.connection?.readyState === WebSocket.CLOSED) {\n      this.closeEmitted = false;\n      this.debug(\n        `[WebSocket] Adding a WebSocket close timeout to ensure a correct WS reconnect.\n        Timeout: ${this.manager.client.options.closeTimeout}ms`,\n      );\n      this.setWsCloseTimeout(this.manager.client.options.closeTimeout);\n    }\n\n    // Step 2: Null the connection object\n    this.connection = null;\n\n    // Step 3: Set the shard status to disconnected\n    this.status = Status.Disconnected;\n\n    // Step 4: Cache the old sequence (use to attempt a resume)\n    if (this.sequence !== -1) this.closeSequence = this.sequence;\n\n    // Step 5: Reset the sequence, resume url and session id if requested\n    if (reset) {\n      this.sequence = -1;\n      this.sessionId = null;\n      this.resumeURL = null;\n    }\n\n    // Step 6: reset the rate limit data\n    this.ratelimit.remaining = this.ratelimit.total;\n    this.ratelimit.queue.length = 0;\n    if (this.ratelimit.timer) {\n      clearTimeout(this.ratelimit.timer);\n      this.ratelimit.timer = null;\n    }\n  }\n\n  /**\n   * Cleans up the WebSocket connection listeners.\n   * @private\n   */\n  _cleanupConnection() {\n    this.connection.onopen = this.connection.onclose = this.connection.onmessage = null;\n    this.connection.onerror = () => null;\n  }\n\n  /**\n   * Emits the DESTROYED event on the shard\n   * @private\n   */\n  _emitDestroyed() {\n    /**\n     * Emitted when a shard is destroyed, but no WebSocket connection was present.\n     * @private\n     * @event WebSocketShard#destroyed\n     */\n    this.emit(WebSocketShardEvents.Destroyed);\n  }\n}\n\nmodule.exports = WebSocketShard;\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}