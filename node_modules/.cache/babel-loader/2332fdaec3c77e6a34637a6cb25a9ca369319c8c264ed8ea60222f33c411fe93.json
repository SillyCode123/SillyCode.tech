{"ast":null,"code":"'use strict';\n\nconst process = require('node:process');\nconst {\n  Collection\n} = require('@discordjs/collection');\nconst {\n  Routes\n} = require('discord-api-types/v10');\nconst CachedManager = require('./CachedManager');\nconst {\n  DiscordjsTypeError,\n  ErrorCodes\n} = require('../errors');\nconst {\n  Role\n} = require('../structures/Role');\nconst DataResolver = require('../util/DataResolver');\nconst PermissionsBitField = require('../util/PermissionsBitField');\nconst {\n  setPosition,\n  resolveColor\n} = require('../util/Util');\nlet cacheWarningEmitted = false;\n\n/**\n * Manages API methods for roles and stores their cache.\n * @extends {CachedManager}\n */\nclass RoleManager extends CachedManager {\n  constructor(guild, iterable) {\n    super(guild.client, Role, iterable);\n    if (!cacheWarningEmitted && this._cache.constructor.name !== 'Collection') {\n      cacheWarningEmitted = true;\n      process.emitWarning(`Overriding the cache handling for ${this.constructor.name} is unsupported and breaks functionality.`, 'UnsupportedCacheOverwriteWarning');\n    }\n\n    /**\n     * The guild belonging to this manager\n     * @type {Guild}\n     */\n    this.guild = guild;\n  }\n\n  /**\n   * The role cache of this manager\n   * @type {Collection<Snowflake, Role>}\n   * @name RoleManager#cache\n   */\n\n  _add(data, cache) {\n    return super._add(data, cache, {\n      extras: [this.guild]\n    });\n  }\n\n  /**\n   * Obtains a role from Discord, or the role cache if they're already available.\n   * @param {Snowflake} [id] The role's id\n   * @param {BaseFetchOptions} [options] Additional options for this fetch\n   * @returns {Promise<?Role|Collection<Snowflake, Role>>}\n   * @example\n   * // Fetch all roles from the guild\n   * message.guild.roles.fetch()\n   *   .then(roles => console.log(`There are ${roles.size} roles.`))\n   *   .catch(console.error);\n   * @example\n   * // Fetch a single role\n   * message.guild.roles.fetch('222078108977594368')\n   *   .then(role => console.log(`The role color is: ${role.color}`))\n   *   .catch(console.error);\n   */\n  async fetch(id) {\n    let {\n      cache = true,\n      force = false\n    } = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    if (id && !force) {\n      const existing = this.cache.get(id);\n      if (existing) return existing;\n    }\n\n    // We cannot fetch a single role, as of this commit's date, Discord API throws with 405\n    const data = await this.client.rest.get(Routes.guildRoles(this.guild.id));\n    const roles = new Collection();\n    for (const role of data) roles.set(role.id, this._add(role, cache));\n    return id ? roles.get(id) ?? null : roles;\n  }\n\n  /**\n   * Data that can be resolved to a Role object. This can be:\n   * * A Role\n   * * A Snowflake\n   * @typedef {Role|Snowflake} RoleResolvable\n   */\n\n  /**\n   * Resolves a {@link RoleResolvable} to a {@link Role} object.\n   * @method resolve\n   * @memberof RoleManager\n   * @instance\n   * @param {RoleResolvable} role The role resolvable to resolve\n   * @returns {?Role}\n   */\n\n  /**\n   * Resolves a {@link RoleResolvable} to a {@link Role} id.\n   * @method resolveId\n   * @memberof RoleManager\n   * @instance\n   * @param {RoleResolvable} role The role resolvable to resolve\n   * @returns {?Snowflake}\n   */\n\n  /**\n   * Options used to create a new role.\n   * @typedef {Object} CreateRoleOptions\n   * @property {string} [name] The name of the new role\n   * @property {ColorResolvable} [color] The data to create the role with\n   * @property {boolean} [hoist] Whether or not the new role should be hoisted\n   * @property {PermissionResolvable} [permissions] The permissions for the new role\n   * @property {number} [position] The position of the new role\n   * @property {boolean} [mentionable] Whether or not the new role should be mentionable\n   * @property {?(BufferResolvable|Base64Resolvable|EmojiResolvable)} [icon] The icon for the role\n   * <warn>The `EmojiResolvable` should belong to the same guild as the role.\n   * If not, pass the emoji's URL directly</warn>\n   * @property {?string} [unicodeEmoji] The unicode emoji for the role\n   * @property {string} [reason] The reason for creating this role\n   */\n\n  /**\n   * Creates a new role in the guild with given information.\n   * <warn>The position will silently reset to 1 if an invalid one is provided, or none.</warn>\n   * @param {CreateRoleOptions} [options] Options for creating the new role\n   * @returns {Promise<Role>}\n   * @example\n   * // Create a new role\n   * guild.roles.create()\n   *   .then(console.log)\n   *   .catch(console.error);\n   * @example\n   * // Create a new role with data and a reason\n   * guild.roles.create({\n   *   name: 'Super Cool Blue People',\n   *   color: Colors.Blue,\n   *   reason: 'we needed a role for Super Cool People',\n   * })\n   *   .then(console.log)\n   *   .catch(console.error);\n   */\n  async create() {\n    let options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    let {\n      name,\n      color,\n      hoist,\n      permissions,\n      position,\n      mentionable,\n      reason,\n      icon,\n      unicodeEmoji\n    } = options;\n    color &&= resolveColor(color);\n    if (typeof permissions !== 'undefined') permissions = new PermissionsBitField(permissions);\n    if (icon) {\n      const guildEmojiURL = this.guild.emojis.resolve(icon)?.url;\n      icon = guildEmojiURL ? await DataResolver.resolveImage(guildEmojiURL) : await DataResolver.resolveImage(icon);\n      if (typeof icon !== 'string') icon = undefined;\n    }\n    const data = await this.client.rest.post(Routes.guildRoles(this.guild.id), {\n      body: {\n        name,\n        color,\n        hoist,\n        permissions,\n        mentionable,\n        icon,\n        unicode_emoji: unicodeEmoji\n      },\n      reason\n    });\n    const {\n      role\n    } = this.client.actions.GuildRoleCreate.handle({\n      guild_id: this.guild.id,\n      role: data\n    });\n    if (position) return this.setPosition(role, position, {\n      reason\n    });\n    return role;\n  }\n\n  /**\n   * Options for editing a role\n   * @typedef {RoleData} EditRoleOptions\n   * @property {string} [reason] The reason for editing this role\n   */\n\n  /**\n   * Edits a role of the guild.\n   * @param {RoleResolvable} role The role to edit\n   * @param {EditRoleOptions} data The new data for the role\n   * @returns {Promise<Role>}\n   * @example\n   * // Edit a role\n   * guild.roles.edit('222079219327434752', { name: 'buddies' })\n   *   .then(updated => console.log(`Edited role name to ${updated.name}`))\n   *   .catch(console.error);\n   */\n  async edit(role, data) {\n    role = this.resolve(role);\n    if (!role) throw new DiscordjsTypeError(ErrorCodes.InvalidType, 'role', 'RoleResolvable');\n    if (typeof data.position === 'number') {\n      await this.setPosition(role, data.position, {\n        reason: data.reason\n      });\n    }\n    let icon = data.icon;\n    if (icon) {\n      const guildEmojiURL = this.guild.emojis.resolve(icon)?.url;\n      icon = guildEmojiURL ? await DataResolver.resolveImage(guildEmojiURL) : await DataResolver.resolveImage(icon);\n      if (typeof icon !== 'string') icon = undefined;\n    }\n    const body = {\n      name: data.name,\n      color: typeof data.color === 'undefined' ? undefined : resolveColor(data.color),\n      hoist: data.hoist,\n      permissions: typeof data.permissions === 'undefined' ? undefined : new PermissionsBitField(data.permissions),\n      mentionable: data.mentionable,\n      icon,\n      unicode_emoji: data.unicodeEmoji\n    };\n    const d = await this.client.rest.patch(Routes.guildRole(this.guild.id, role.id), {\n      body,\n      reason: data.reason\n    });\n    const clone = role._clone();\n    clone._patch(d);\n    return clone;\n  }\n\n  /**\n   * Deletes a role.\n   * @param {RoleResolvable} role The role to delete\n   * @param {string} [reason] Reason for deleting the role\n   * @returns {Promise<void>}\n   * @example\n   * // Delete a role\n   * guild.roles.delete('222079219327434752', 'The role needed to go')\n   *   .then(() => console.log('Deleted the role'))\n   *   .catch(console.error);\n   */\n  async delete(role, reason) {\n    const id = this.resolveId(role);\n    await this.client.rest.delete(Routes.guildRole(this.guild.id, id), {\n      reason\n    });\n    this.client.actions.GuildRoleDelete.handle({\n      guild_id: this.guild.id,\n      role_id: id\n    });\n  }\n\n  /**\n   * Sets the new position of the role.\n   * @param {RoleResolvable} role The role to change the position of\n   * @param {number} position The new position for the role\n   * @param {SetRolePositionOptions} [options] Options for setting the position\n   * @returns {Promise<Role>}\n   * @example\n   * // Set the position of the role\n   * guild.roles.setPosition('222197033908436994', 1)\n   *   .then(updated => console.log(`Role position: ${updated.position}`))\n   *   .catch(console.error);\n   */\n  async setPosition(role, position) {\n    let {\n      relative,\n      reason\n    } = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n    role = this.resolve(role);\n    if (!role) throw new DiscordjsTypeError(ErrorCodes.InvalidType, 'role', 'RoleResolvable');\n    const updatedRoles = await setPosition(role, position, relative, this.guild._sortedRoles(), this.client, Routes.guildRoles(this.guild.id), reason);\n    this.client.actions.GuildRolesPositionUpdate.handle({\n      guild_id: this.guild.id,\n      roles: updatedRoles\n    });\n    return role;\n  }\n\n  /**\n   * The data needed for updating a guild role's position\n   * @typedef {Object} GuildRolePosition\n   * @property {RoleResolvable} role The role's id\n   * @property {number} position The position to update\n   */\n\n  /**\n   * Batch-updates the guild's role positions\n   * @param {GuildRolePosition[]} rolePositions Role positions to update\n   * @returns {Promise<Guild>}\n   * @example\n   * guild.roles.setPositions([{ role: roleId, position: updatedRoleIndex }])\n   *  .then(guild => console.log(`Role positions updated for ${guild}`))\n   *  .catch(console.error);\n   */\n  async setPositions(rolePositions) {\n    // Make sure rolePositions are prepared for API\n    rolePositions = rolePositions.map(o => ({\n      id: this.resolveId(o.role),\n      position: o.position\n    }));\n\n    // Call the API to update role positions\n    await this.client.rest.patch(Routes.guildRoles(this.guild.id), {\n      body: rolePositions\n    });\n    return this.client.actions.GuildRolesPositionUpdate.handle({\n      guild_id: this.guild.id,\n      roles: rolePositions\n    }).guild;\n  }\n\n  /**\n   * Compares the positions of two roles.\n   * @param {RoleResolvable} role1 First role to compare\n   * @param {RoleResolvable} role2 Second role to compare\n   * @returns {number} Negative number if the first role's position is lower (second role's is higher),\n   * positive number if the first's is higher (second's is lower), 0 if equal\n   */\n  comparePositions(role1, role2) {\n    const resolvedRole1 = this.resolve(role1);\n    const resolvedRole2 = this.resolve(role2);\n    if (!resolvedRole1 || !resolvedRole2) {\n      throw new DiscordjsTypeError(ErrorCodes.InvalidType, 'role', 'Role nor a Snowflake');\n    }\n    if (resolvedRole1.position === resolvedRole2.position) {\n      return Number(BigInt(resolvedRole2.id) - BigInt(resolvedRole1.id));\n    }\n    return resolvedRole1.position - resolvedRole2.position;\n  }\n\n  /**\n   * Gets the managed role a user created when joining the guild, if any\n   * <info>Only ever available for bots</info>\n   * @param {UserResolvable} user The user to access the bot role for\n   * @returns {?Role}\n   */\n  botRoleFor(user) {\n    const userId = this.client.users.resolveId(user);\n    if (!userId) return null;\n    return this.cache.find(role => role.tags?.botId === userId) ?? null;\n  }\n\n  /**\n   * The `@everyone` role of the guild\n   * @type {Role}\n   * @readonly\n   */\n  get everyone() {\n    return this.cache.get(this.guild.id);\n  }\n\n  /**\n   * The premium subscriber role of the guild, if any\n   * @type {?Role}\n   * @readonly\n   */\n  get premiumSubscriberRole() {\n    return this.cache.find(role => role.tags?.premiumSubscriberRole) ?? null;\n  }\n\n  /**\n   * The role with the highest position in the cache\n   * @type {Role}\n   * @readonly\n   */\n  get highest() {\n    return this.cache.reduce((prev, role) => role.comparePositionTo(prev) > 0 ? role : prev, this.cache.first());\n  }\n}\nmodule.exports = RoleManager;","map":{"version":3,"names":["process","require","Collection","Routes","CachedManager","DiscordjsTypeError","ErrorCodes","Role","DataResolver","PermissionsBitField","setPosition","resolveColor","cacheWarningEmitted","RoleManager","constructor","guild","iterable","client","_cache","name","emitWarning","_add","data","cache","extras","fetch","id","force","existing","get","rest","guildRoles","roles","role","set","create","options","color","hoist","permissions","position","mentionable","reason","icon","unicodeEmoji","guildEmojiURL","emojis","resolve","url","resolveImage","undefined","post","body","unicode_emoji","actions","GuildRoleCreate","handle","guild_id","edit","InvalidType","d","patch","guildRole","clone","_clone","_patch","delete","resolveId","GuildRoleDelete","role_id","relative","updatedRoles","_sortedRoles","GuildRolesPositionUpdate","setPositions","rolePositions","map","o","comparePositions","role1","role2","resolvedRole1","resolvedRole2","Number","BigInt","botRoleFor","user","userId","users","find","tags","botId","everyone","premiumSubscriberRole","highest","reduce","prev","comparePositionTo","first","module","exports"],"sources":["J:/Coding/Projekts/Web/JavaScript/sillcode.tech/node_modules/discord.js/src/managers/RoleManager.js"],"sourcesContent":["'use strict';\n\nconst process = require('node:process');\nconst { Collection } = require('@discordjs/collection');\nconst { Routes } = require('discord-api-types/v10');\nconst CachedManager = require('./CachedManager');\nconst { DiscordjsTypeError, ErrorCodes } = require('../errors');\nconst { Role } = require('../structures/Role');\nconst DataResolver = require('../util/DataResolver');\nconst PermissionsBitField = require('../util/PermissionsBitField');\nconst { setPosition, resolveColor } = require('../util/Util');\n\nlet cacheWarningEmitted = false;\n\n/**\n * Manages API methods for roles and stores their cache.\n * @extends {CachedManager}\n */\nclass RoleManager extends CachedManager {\n  constructor(guild, iterable) {\n    super(guild.client, Role, iterable);\n    if (!cacheWarningEmitted && this._cache.constructor.name !== 'Collection') {\n      cacheWarningEmitted = true;\n      process.emitWarning(\n        `Overriding the cache handling for ${this.constructor.name} is unsupported and breaks functionality.`,\n        'UnsupportedCacheOverwriteWarning',\n      );\n    }\n\n    /**\n     * The guild belonging to this manager\n     * @type {Guild}\n     */\n    this.guild = guild;\n  }\n\n  /**\n   * The role cache of this manager\n   * @type {Collection<Snowflake, Role>}\n   * @name RoleManager#cache\n   */\n\n  _add(data, cache) {\n    return super._add(data, cache, { extras: [this.guild] });\n  }\n\n  /**\n   * Obtains a role from Discord, or the role cache if they're already available.\n   * @param {Snowflake} [id] The role's id\n   * @param {BaseFetchOptions} [options] Additional options for this fetch\n   * @returns {Promise<?Role|Collection<Snowflake, Role>>}\n   * @example\n   * // Fetch all roles from the guild\n   * message.guild.roles.fetch()\n   *   .then(roles => console.log(`There are ${roles.size} roles.`))\n   *   .catch(console.error);\n   * @example\n   * // Fetch a single role\n   * message.guild.roles.fetch('222078108977594368')\n   *   .then(role => console.log(`The role color is: ${role.color}`))\n   *   .catch(console.error);\n   */\n  async fetch(id, { cache = true, force = false } = {}) {\n    if (id && !force) {\n      const existing = this.cache.get(id);\n      if (existing) return existing;\n    }\n\n    // We cannot fetch a single role, as of this commit's date, Discord API throws with 405\n    const data = await this.client.rest.get(Routes.guildRoles(this.guild.id));\n    const roles = new Collection();\n    for (const role of data) roles.set(role.id, this._add(role, cache));\n    return id ? roles.get(id) ?? null : roles;\n  }\n\n  /**\n   * Data that can be resolved to a Role object. This can be:\n   * * A Role\n   * * A Snowflake\n   * @typedef {Role|Snowflake} RoleResolvable\n   */\n\n  /**\n   * Resolves a {@link RoleResolvable} to a {@link Role} object.\n   * @method resolve\n   * @memberof RoleManager\n   * @instance\n   * @param {RoleResolvable} role The role resolvable to resolve\n   * @returns {?Role}\n   */\n\n  /**\n   * Resolves a {@link RoleResolvable} to a {@link Role} id.\n   * @method resolveId\n   * @memberof RoleManager\n   * @instance\n   * @param {RoleResolvable} role The role resolvable to resolve\n   * @returns {?Snowflake}\n   */\n\n  /**\n   * Options used to create a new role.\n   * @typedef {Object} CreateRoleOptions\n   * @property {string} [name] The name of the new role\n   * @property {ColorResolvable} [color] The data to create the role with\n   * @property {boolean} [hoist] Whether or not the new role should be hoisted\n   * @property {PermissionResolvable} [permissions] The permissions for the new role\n   * @property {number} [position] The position of the new role\n   * @property {boolean} [mentionable] Whether or not the new role should be mentionable\n   * @property {?(BufferResolvable|Base64Resolvable|EmojiResolvable)} [icon] The icon for the role\n   * <warn>The `EmojiResolvable` should belong to the same guild as the role.\n   * If not, pass the emoji's URL directly</warn>\n   * @property {?string} [unicodeEmoji] The unicode emoji for the role\n   * @property {string} [reason] The reason for creating this role\n   */\n\n  /**\n   * Creates a new role in the guild with given information.\n   * <warn>The position will silently reset to 1 if an invalid one is provided, or none.</warn>\n   * @param {CreateRoleOptions} [options] Options for creating the new role\n   * @returns {Promise<Role>}\n   * @example\n   * // Create a new role\n   * guild.roles.create()\n   *   .then(console.log)\n   *   .catch(console.error);\n   * @example\n   * // Create a new role with data and a reason\n   * guild.roles.create({\n   *   name: 'Super Cool Blue People',\n   *   color: Colors.Blue,\n   *   reason: 'we needed a role for Super Cool People',\n   * })\n   *   .then(console.log)\n   *   .catch(console.error);\n   */\n  async create(options = {}) {\n    let { name, color, hoist, permissions, position, mentionable, reason, icon, unicodeEmoji } = options;\n    color &&= resolveColor(color);\n    if (typeof permissions !== 'undefined') permissions = new PermissionsBitField(permissions);\n    if (icon) {\n      const guildEmojiURL = this.guild.emojis.resolve(icon)?.url;\n      icon = guildEmojiURL ? await DataResolver.resolveImage(guildEmojiURL) : await DataResolver.resolveImage(icon);\n      if (typeof icon !== 'string') icon = undefined;\n    }\n\n    const data = await this.client.rest.post(Routes.guildRoles(this.guild.id), {\n      body: {\n        name,\n        color,\n        hoist,\n        permissions,\n        mentionable,\n        icon,\n        unicode_emoji: unicodeEmoji,\n      },\n      reason,\n    });\n    const { role } = this.client.actions.GuildRoleCreate.handle({\n      guild_id: this.guild.id,\n      role: data,\n    });\n    if (position) return this.setPosition(role, position, { reason });\n    return role;\n  }\n\n  /**\n   * Options for editing a role\n   * @typedef {RoleData} EditRoleOptions\n   * @property {string} [reason] The reason for editing this role\n   */\n\n  /**\n   * Edits a role of the guild.\n   * @param {RoleResolvable} role The role to edit\n   * @param {EditRoleOptions} data The new data for the role\n   * @returns {Promise<Role>}\n   * @example\n   * // Edit a role\n   * guild.roles.edit('222079219327434752', { name: 'buddies' })\n   *   .then(updated => console.log(`Edited role name to ${updated.name}`))\n   *   .catch(console.error);\n   */\n  async edit(role, data) {\n    role = this.resolve(role);\n    if (!role) throw new DiscordjsTypeError(ErrorCodes.InvalidType, 'role', 'RoleResolvable');\n\n    if (typeof data.position === 'number') {\n      await this.setPosition(role, data.position, { reason: data.reason });\n    }\n\n    let icon = data.icon;\n    if (icon) {\n      const guildEmojiURL = this.guild.emojis.resolve(icon)?.url;\n      icon = guildEmojiURL ? await DataResolver.resolveImage(guildEmojiURL) : await DataResolver.resolveImage(icon);\n      if (typeof icon !== 'string') icon = undefined;\n    }\n\n    const body = {\n      name: data.name,\n      color: typeof data.color === 'undefined' ? undefined : resolveColor(data.color),\n      hoist: data.hoist,\n      permissions: typeof data.permissions === 'undefined' ? undefined : new PermissionsBitField(data.permissions),\n      mentionable: data.mentionable,\n      icon,\n      unicode_emoji: data.unicodeEmoji,\n    };\n\n    const d = await this.client.rest.patch(Routes.guildRole(this.guild.id, role.id), { body, reason: data.reason });\n\n    const clone = role._clone();\n    clone._patch(d);\n    return clone;\n  }\n\n  /**\n   * Deletes a role.\n   * @param {RoleResolvable} role The role to delete\n   * @param {string} [reason] Reason for deleting the role\n   * @returns {Promise<void>}\n   * @example\n   * // Delete a role\n   * guild.roles.delete('222079219327434752', 'The role needed to go')\n   *   .then(() => console.log('Deleted the role'))\n   *   .catch(console.error);\n   */\n  async delete(role, reason) {\n    const id = this.resolveId(role);\n    await this.client.rest.delete(Routes.guildRole(this.guild.id, id), { reason });\n    this.client.actions.GuildRoleDelete.handle({ guild_id: this.guild.id, role_id: id });\n  }\n\n  /**\n   * Sets the new position of the role.\n   * @param {RoleResolvable} role The role to change the position of\n   * @param {number} position The new position for the role\n   * @param {SetRolePositionOptions} [options] Options for setting the position\n   * @returns {Promise<Role>}\n   * @example\n   * // Set the position of the role\n   * guild.roles.setPosition('222197033908436994', 1)\n   *   .then(updated => console.log(`Role position: ${updated.position}`))\n   *   .catch(console.error);\n   */\n  async setPosition(role, position, { relative, reason } = {}) {\n    role = this.resolve(role);\n    if (!role) throw new DiscordjsTypeError(ErrorCodes.InvalidType, 'role', 'RoleResolvable');\n    const updatedRoles = await setPosition(\n      role,\n      position,\n      relative,\n      this.guild._sortedRoles(),\n      this.client,\n      Routes.guildRoles(this.guild.id),\n      reason,\n    );\n\n    this.client.actions.GuildRolesPositionUpdate.handle({\n      guild_id: this.guild.id,\n      roles: updatedRoles,\n    });\n    return role;\n  }\n\n  /**\n   * The data needed for updating a guild role's position\n   * @typedef {Object} GuildRolePosition\n   * @property {RoleResolvable} role The role's id\n   * @property {number} position The position to update\n   */\n\n  /**\n   * Batch-updates the guild's role positions\n   * @param {GuildRolePosition[]} rolePositions Role positions to update\n   * @returns {Promise<Guild>}\n   * @example\n   * guild.roles.setPositions([{ role: roleId, position: updatedRoleIndex }])\n   *  .then(guild => console.log(`Role positions updated for ${guild}`))\n   *  .catch(console.error);\n   */\n  async setPositions(rolePositions) {\n    // Make sure rolePositions are prepared for API\n    rolePositions = rolePositions.map(o => ({\n      id: this.resolveId(o.role),\n      position: o.position,\n    }));\n\n    // Call the API to update role positions\n    await this.client.rest.patch(Routes.guildRoles(this.guild.id), { body: rolePositions });\n    return this.client.actions.GuildRolesPositionUpdate.handle({\n      guild_id: this.guild.id,\n      roles: rolePositions,\n    }).guild;\n  }\n\n  /**\n   * Compares the positions of two roles.\n   * @param {RoleResolvable} role1 First role to compare\n   * @param {RoleResolvable} role2 Second role to compare\n   * @returns {number} Negative number if the first role's position is lower (second role's is higher),\n   * positive number if the first's is higher (second's is lower), 0 if equal\n   */\n  comparePositions(role1, role2) {\n    const resolvedRole1 = this.resolve(role1);\n    const resolvedRole2 = this.resolve(role2);\n    if (!resolvedRole1 || !resolvedRole2) {\n      throw new DiscordjsTypeError(ErrorCodes.InvalidType, 'role', 'Role nor a Snowflake');\n    }\n\n    if (resolvedRole1.position === resolvedRole2.position) {\n      return Number(BigInt(resolvedRole2.id) - BigInt(resolvedRole1.id));\n    }\n\n    return resolvedRole1.position - resolvedRole2.position;\n  }\n\n  /**\n   * Gets the managed role a user created when joining the guild, if any\n   * <info>Only ever available for bots</info>\n   * @param {UserResolvable} user The user to access the bot role for\n   * @returns {?Role}\n   */\n  botRoleFor(user) {\n    const userId = this.client.users.resolveId(user);\n    if (!userId) return null;\n    return this.cache.find(role => role.tags?.botId === userId) ?? null;\n  }\n\n  /**\n   * The `@everyone` role of the guild\n   * @type {Role}\n   * @readonly\n   */\n  get everyone() {\n    return this.cache.get(this.guild.id);\n  }\n\n  /**\n   * The premium subscriber role of the guild, if any\n   * @type {?Role}\n   * @readonly\n   */\n  get premiumSubscriberRole() {\n    return this.cache.find(role => role.tags?.premiumSubscriberRole) ?? null;\n  }\n\n  /**\n   * The role with the highest position in the cache\n   * @type {Role}\n   * @readonly\n   */\n  get highest() {\n    return this.cache.reduce((prev, role) => (role.comparePositionTo(prev) > 0 ? role : prev), this.cache.first());\n  }\n}\n\nmodule.exports = RoleManager;\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}