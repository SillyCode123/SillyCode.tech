{"ast":null,"code":"'use strict';\n\nconst {\n  Collection\n} = require('@discordjs/collection');\nconst {\n  ApplicationCommandPermissionType,\n  RESTJSONErrorCodes,\n  Routes\n} = require('discord-api-types/v10');\nconst BaseManager = require('./BaseManager');\nconst {\n  DiscordjsError,\n  DiscordjsTypeError,\n  ErrorCodes\n} = require('../errors');\n\n/**\n * Manages API methods for permissions of Application Commands.\n * @extends {BaseManager}\n */\nclass ApplicationCommandPermissionsManager extends BaseManager {\n  constructor(manager) {\n    super(manager.client);\n\n    /**\n     * The manager or command that this manager belongs to\n     * @type {ApplicationCommandManager|ApplicationCommand}\n     * @private\n     */\n    this.manager = manager;\n\n    /**\n     * The guild that this manager acts on\n     * @type {?Guild}\n     */\n    this.guild = manager.guild ?? null;\n\n    /**\n     * The id of the guild that this manager acts on\n     * @type {?Snowflake}\n     */\n    this.guildId = manager.guildId ?? manager.guild?.id ?? null;\n\n    /**\n     * The id of the command this manager acts on\n     * @type {?Snowflake}\n     */\n    this.commandId = manager.id ?? null;\n  }\n\n  /**\n   * The APIRouter path to the commands\n   * @param {Snowflake} guildId The guild's id to use in the path,\n   * @param {Snowflake} [commandId] The application command's id\n   * @returns {string}\n   * @private\n   */\n  permissionsPath(guildId, commandId) {\n    if (commandId) {\n      return Routes.applicationCommandPermissions(this.client.application.id, guildId, commandId);\n    }\n    return Routes.guildApplicationCommandsPermissions(this.client.application.id, guildId);\n  }\n\n  /* eslint-disable max-len */\n  /**\n   * The object returned when fetching permissions for an application command.\n   * @typedef {Object} ApplicationCommandPermissions\n   * @property {Snowflake} id The role, user, or channel's id. Can also be a\n   * {@link https://discord.com/developers/docs/interactions/application-commands#application-command-permissions-object-application-command-permissions-constants permission constant}.\n   * @property {ApplicationCommandPermissionType} type Whether this permission is for a role or a user\n   * @property {boolean} permission Whether the role or user has the permission to use this command\n   */\n  /* eslint-enable max-len */\n\n  /**\n   * Options for managing permissions for one or more Application Commands\n   * <warn>When passing these options to a manager where `guildId` is `null`,\n   * `guild` is a required parameter</warn>\n   * @typedef {Object} BaseApplicationCommandPermissionsOptions\n   * @property {GuildResolvable} [guild] The guild to modify / check permissions for\n   * <warn>Ignored when the manager has a non-null `guildId` property</warn>\n   * @property {ApplicationCommandResolvable} [command] The command to modify / check permissions for\n   * <warn>Ignored when the manager has a non-null `commandId` property</warn>\n   */\n\n  /**\n   * Fetches the permissions for one or multiple commands. Providing the client's id as the \"command id\" will fetch\n   * *only* the guild level permissions\n   * @param {BaseApplicationCommandPermissionsOptions} [options] Options used to fetch permissions\n   * @returns {Promise<ApplicationCommandPermissions[]|Collection<Snowflake, ApplicationCommandPermissions[]>>}\n   * @example\n   * // Fetch permissions for one command\n   * guild.commands.permissions.fetch({ command: '123456789012345678' })\n   *   .then(perms => console.log(`Fetched ${perms.length} overwrites`))\n   *   .catch(console.error);\n   * @example\n   * // Fetch permissions for all commands in a guild\n   * client.application.commands.permissions.fetch({ guild: '123456789012345678' })\n   *   .then(perms => console.log(`Fetched permissions for ${perms.size} commands`))\n   *   .catch(console.error);\n   * @example\n   * // Fetch guild level permissions\n   * guild.commands.permissions.fetch({ command: client.user.id })\n   *   .then(perms => console.log(`Fetched ${perms.length} guild level permissions`))\n   *   .catch(console.error);\n   */\n  async fetch() {\n    let {\n      guild,\n      command\n    } = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    const {\n      guildId,\n      commandId\n    } = this._validateOptions(guild, command);\n    if (commandId) {\n      const data = await this.client.rest.get(this.permissionsPath(guildId, commandId));\n      return data.permissions;\n    }\n    const data = await this.client.rest.get(this.permissionsPath(guildId));\n    return data.reduce((coll, perm) => coll.set(perm.id, perm.permissions), new Collection());\n  }\n\n  /**\n   * Options used to set permissions for one or more Application Commands in a guild\n   * <warn>Omitting the `command` parameter edits the guild wide permissions\n   * when the manager's `commandId` is `null`</warn>\n   * @typedef {BaseApplicationCommandPermissionsOptions} EditApplicationCommandPermissionsOptions\n   * @property {ApplicationCommandPermissions[]} permissions The new permissions for the guild or overwrite\n   * @property {string} token The bearer token to use that authorizes the permission edit\n   */\n\n  /**\n   * Sets the permissions for the guild or a command overwrite.\n   * @param {EditApplicationCommandPermissionsOptions} options Options used to set permissions\n   * @returns {Promise<ApplicationCommandPermissions[]|Collection<Snowflake, ApplicationCommandPermissions[]>>}\n   * @example\n   * // Set a permission overwrite for a command\n   * client.application.commands.permissions.set({\n   *  guild: '892455839386304532',\n   *  command: '123456789012345678',\n   *  token: 'TotallyRealToken',\n   *  permissions: [\n   *    {\n   *      id: '876543210987654321',\n   *      type: ApplicationCommandPermissionType.User,\n   *      permission: false,\n   *    },\n   * ]})\n   *   .then(console.log)\n   *   .catch(console.error);\n   * @example\n   * // Set the permissions used for the guild (commands without overwrites)\n   * guild.commands.permissions.set({ token: 'TotallyRealToken', permissions: [\n   *   {\n   *     id: '123456789012345678',\n   *     permissions: [{\n   *       id: '876543210987654321',\n   *       type: ApplicationCommandPermissionType.User,\n   *       permission: false,\n   *     }],\n   *   },\n   * ]})\n   *   .then(console.log)\n   *   .catch(console.error);\n   */\n  async set() {\n    let {\n      guild,\n      command,\n      permissions,\n      token\n    } = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    if (!token) {\n      throw new DiscordjsError(ErrorCodes.ApplicationCommandPermissionsTokenMissing);\n    }\n    let {\n      guildId,\n      commandId\n    } = this._validateOptions(guild, command);\n    if (!Array.isArray(permissions)) {\n      throw new DiscordjsTypeError(ErrorCodes.InvalidType, 'permissions', 'Array of ApplicationCommandPermissions', true);\n    }\n    if (!commandId) {\n      commandId = this.client.user.id;\n    }\n    const data = await this.client.rest.put(this.permissionsPath(guildId, commandId), {\n      body: {\n        permissions\n      },\n      auth: false,\n      headers: {\n        Authorization: `Bearer ${token}`\n      }\n    });\n    return data.permissions;\n  }\n\n  /**\n   * Add permissions to a command.\n   * @param {EditApplicationCommandPermissionsOptions} options Options used to add permissions\n   * @returns {Promise<ApplicationCommandPermissions[]>}\n   * @example\n   * // Add a rule to block a role from using a command\n   * guild.commands.permissions.add({ command: '123456789012345678', token: 'TotallyRealToken', permissions: [\n   *   {\n   *     id: '876543211234567890',\n   *     type: ApplicationCommandPermissionType.Role,\n   *     permission: false\n   *   },\n   * ]})\n   *   .then(console.log)\n   *   .catch(console.error);\n   */\n  async add() {\n    let {\n      guild,\n      command,\n      permissions,\n      token\n    } = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    if (!token) {\n      throw new DiscordjsError(ErrorCodes.ApplicationCommandPermissionsTokenMissing);\n    }\n    let {\n      guildId,\n      commandId\n    } = this._validateOptions(guild, command);\n    if (!commandId) {\n      commandId = this.client.user.id;\n    }\n    if (!Array.isArray(permissions)) {\n      throw new DiscordjsTypeError(ErrorCodes.InvalidType, 'permissions', 'Array of ApplicationCommandPermissions', true);\n    }\n    let existing = [];\n    try {\n      existing = await this.fetch({\n        guild: guildId,\n        command: commandId\n      });\n    } catch (error) {\n      if (error.code !== RESTJSONErrorCodes.UnknownApplicationCommandPermissions) throw error;\n    }\n    const newPermissions = permissions.slice();\n    for (const perm of existing) {\n      if (!newPermissions.some(x => x.id === perm.id)) {\n        newPermissions.push(perm);\n      }\n    }\n    return this.set({\n      guild: guildId,\n      command: commandId,\n      permissions: newPermissions,\n      token\n    });\n  }\n\n  /**\n   * A static snowflake that identifies the everyone role for application command permissions.\n   * It is the same as the guild id\n   * @typedef {Snowflake} RolePermissionConstant\n   */\n\n  /**\n   * A static snowflake that identifies the \"all channels\" entity for application command permissions.\n   * It will be the result of the calculation `guildId - 1`\n   * @typedef {Snowflake} ChannelPermissionConstant\n   */\n\n  /**\n   * Options used to remove permissions from a command\n   * <warn>Omitting the `command` parameter removes from the guild wide permissions\n   * when the managers `commandId` is `null`</warn>\n   * <warn>At least one of `users`, `roles`, and `channels` is required</warn>\n   * @typedef {BaseApplicationCommandPermissionsOptions} RemoveApplicationCommandPermissionsOptions\n   * @property {string} token The bearer token to use that authorizes the permission removal\n   * @property {UserResolvable[]} [users] The user(s) to remove\n   * @property {Array<RoleResolvable|RolePermissionConstant>} [roles] The role(s) to remove\n   * @property {Array<GuildChannelResolvable|ChannelPermissionConstant>} [channels] The channel(s) to remove\n   */\n\n  /**\n   * Remove permissions from a command.\n   * @param {RemoveApplicationCommandPermissionsOptions} options Options used to remove permissions\n   * @returns {Promise<ApplicationCommandPermissions[]>}\n   * @example\n   * // Remove a user permission from this command\n   * guild.commands.permissions.remove({\n   *  command: '123456789012345678', users: '876543210123456789', token: 'TotallyRealToken',\n   * })\n   *   .then(console.log)\n   *   .catch(console.error);\n   * @example\n   * // Remove multiple roles from this command\n   * guild.commands.permissions.remove({\n   *   command: '123456789012345678', roles: ['876543210123456789', '765432101234567890'], token: 'TotallyRealToken',\n   * })\n   *    .then(console.log)\n   *    .catch(console.error);\n   */\n  async remove() {\n    let {\n      guild,\n      command,\n      users,\n      roles,\n      channels,\n      token\n    } = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    if (!token) {\n      throw new DiscordjsError(ErrorCodes.ApplicationCommandPermissionsTokenMissing);\n    }\n    let {\n      guildId,\n      commandId\n    } = this._validateOptions(guild, command);\n    if (!commandId) {\n      commandId = this.client.user.id;\n    }\n    if (!users && !roles && !channels) {\n      throw new DiscordjsTypeError(ErrorCodes.InvalidType, 'users OR roles OR channels', 'Array or Resolvable', true);\n    }\n    let resolvedUserIds = [];\n    if (Array.isArray(users)) {\n      for (const user of users) {\n        const userId = this.client.users.resolveId(user);\n        if (!userId) throw new DiscordjsTypeError(ErrorCodes.InvalidElement, 'Array', 'users', user);\n        resolvedUserIds.push(userId);\n      }\n    }\n    let resolvedRoleIds = [];\n    if (Array.isArray(roles)) {\n      for (const role of roles) {\n        if (typeof role === 'string') {\n          resolvedRoleIds.push(role);\n          continue;\n        }\n        if (!this.guild) throw new DiscordjsError(ErrorCodes.GuildUncachedEntityResolve, 'roles');\n        const roleId = this.guild.roles.resolveId(role);\n        if (!roleId) throw new DiscordjsTypeError(ErrorCodes.InvalidElement, 'Array', 'users', role);\n        resolvedRoleIds.push(roleId);\n      }\n    }\n    let resolvedChannelIds = [];\n    if (Array.isArray(channels)) {\n      for (const channel of channels) {\n        if (typeof channel === 'string') {\n          resolvedChannelIds.push(channel);\n          continue;\n        }\n        if (!this.guild) throw new DiscordjsError(ErrorCodes.GuildUncachedEntityResolve, 'channels');\n        const channelId = this.guild.channels.resolveId(channel);\n        if (!channelId) throw new DiscordjsTypeError(ErrorCodes.InvalidElement, 'Array', 'channels', channel);\n        resolvedChannelIds.push(channelId);\n      }\n    }\n    let existing = [];\n    try {\n      existing = await this.fetch({\n        guild: guildId,\n        command: commandId\n      });\n    } catch (error) {\n      if (error.code !== RESTJSONErrorCodes.UnknownApplicationCommandPermissions) throw error;\n    }\n    const permissions = existing.filter(perm => {\n      switch (perm.type) {\n        case ApplicationCommandPermissionType.Role:\n          return !resolvedRoleIds.includes(perm.id);\n        case ApplicationCommandPermissionType.User:\n          return !resolvedUserIds.includes(perm.id);\n        case ApplicationCommandPermissionType.Channel:\n          return !resolvedChannelIds.includes(perm.id);\n      }\n      return true;\n    });\n    return this.set({\n      guild: guildId,\n      command: commandId,\n      permissions,\n      token\n    });\n  }\n\n  /**\n   * Options used to check the existence of permissions on a command\n   * <warn>The `command` parameter is not optional when the managers `commandId` is `null`</warn>\n   * @typedef {BaseApplicationCommandPermissionsOptions} HasApplicationCommandPermissionsOptions\n   * @property {ApplicationCommandPermissionIdResolvable} permissionId The entity to check if a permission exists for\n   * on this command.\n   * @property {ApplicationCommandPermissionType} [permissionType] Check for a specific type of permission\n   */\n\n  /**\n   * Check whether a permission exists for a user, role, or channel\n   * @param {HasApplicationCommandPermissionsOptions} options Options used to check permissions\n   * @returns {Promise<boolean>}\n   * @example\n   * // Check whether a user has permission to use a command\n   * guild.commands.permissions.has({ command: '123456789012345678', permissionId: '876543210123456789' })\n   *  .then(console.log)\n   *  .catch(console.error);\n   */\n  async has(_ref) {\n    let {\n      guild,\n      command,\n      permissionId,\n      permissionType\n    } = _ref;\n    const {\n      guildId,\n      commandId\n    } = this._validateOptions(guild, command);\n    if (!commandId) throw new DiscordjsTypeError(ErrorCodes.InvalidType, 'command', 'ApplicationCommandResolvable');\n    if (!permissionId) {\n      throw new DiscordjsTypeError(ErrorCodes.InvalidType, 'permissionId', 'UserResolvable, RoleResolvable, ChannelResolvable, or Permission Constant');\n    }\n    let resolvedId = permissionId;\n    if (typeof permissionId !== 'string') {\n      resolvedId = this.client.users.resolveId(permissionId);\n      if (!resolvedId) {\n        if (!this.guild) throw new DiscordjsError(ErrorCodes.GuildUncachedEntityResolve, 'roles');\n        resolvedId = this.guild.roles.resolveId(permissionId);\n      }\n      if (!resolvedId) {\n        resolvedId = this.guild.channels.resolveId(permissionId);\n      }\n      if (!resolvedId) {\n        throw new DiscordjsTypeError(ErrorCodes.InvalidType, 'permissionId', 'UserResolvable, RoleResolvable, ChannelResolvable, or Permission Constant');\n      }\n    }\n    let existing = [];\n    try {\n      existing = await this.fetch({\n        guild: guildId,\n        command: commandId\n      });\n    } catch (error) {\n      if (error.code !== RESTJSONErrorCodes.UnknownApplicationCommandPermissions) throw error;\n    }\n\n    // Check permission type if provided for the single edge case where a channel id is the same as the everyone role id\n    return existing.some(perm => perm.id === resolvedId && (permissionType ?? perm.type) === perm.type);\n  }\n  _validateOptions(guild, command) {\n    const guildId = this.guildId ?? this.client.guilds.resolveId(guild);\n    if (!guildId) throw new DiscordjsError(ErrorCodes.GlobalCommandPermissions);\n    let commandId = this.commandId;\n    if (command && !commandId) {\n      commandId = this.manager.resolveId?.(command);\n      if (!commandId && this.guild) {\n        commandId = this.guild.commands.resolveId(command);\n      }\n      commandId ??= this.client.application?.commands.resolveId(command);\n      if (!commandId) {\n        throw new DiscordjsTypeError(ErrorCodes.InvalidType, 'command', 'ApplicationCommandResolvable', true);\n      }\n    }\n    return {\n      guildId,\n      commandId\n    };\n  }\n}\nmodule.exports = ApplicationCommandPermissionsManager;\n\n/* eslint-disable max-len */\n/**\n * @external APIApplicationCommandPermissions\n * @see {@link https://discord.com/developers/docs/interactions/application-commands#application-command-permissions-object-application-command-permissions-structure}\n */\n\n/**\n * Data that resolves to an id used for an application command permission\n * @typedef {UserResolvable|RoleResolvable|GuildChannelResolvable|RolePermissionConstant|ChannelPermissionConstant} ApplicationCommandPermissionIdResolvable\n */","map":{"version":3,"names":["Collection","require","ApplicationCommandPermissionType","RESTJSONErrorCodes","Routes","BaseManager","DiscordjsError","DiscordjsTypeError","ErrorCodes","ApplicationCommandPermissionsManager","constructor","manager","client","guild","guildId","id","commandId","permissionsPath","applicationCommandPermissions","application","guildApplicationCommandsPermissions","fetch","command","_validateOptions","data","rest","get","permissions","reduce","coll","perm","set","token","ApplicationCommandPermissionsTokenMissing","Array","isArray","InvalidType","user","put","body","auth","headers","Authorization","add","existing","error","code","UnknownApplicationCommandPermissions","newPermissions","slice","some","x","push","remove","users","roles","channels","resolvedUserIds","userId","resolveId","InvalidElement","resolvedRoleIds","role","GuildUncachedEntityResolve","roleId","resolvedChannelIds","channel","channelId","filter","type","Role","includes","User","Channel","has","permissionId","permissionType","resolvedId","guilds","GlobalCommandPermissions","commands","module","exports"],"sources":["J:/Coding/Projekts/Web/JavaScript/sillcode.tech/node_modules/discord.js/src/managers/ApplicationCommandPermissionsManager.js"],"sourcesContent":["'use strict';\n\nconst { Collection } = require('@discordjs/collection');\nconst { ApplicationCommandPermissionType, RESTJSONErrorCodes, Routes } = require('discord-api-types/v10');\nconst BaseManager = require('./BaseManager');\nconst { DiscordjsError, DiscordjsTypeError, ErrorCodes } = require('../errors');\n\n/**\n * Manages API methods for permissions of Application Commands.\n * @extends {BaseManager}\n */\nclass ApplicationCommandPermissionsManager extends BaseManager {\n  constructor(manager) {\n    super(manager.client);\n\n    /**\n     * The manager or command that this manager belongs to\n     * @type {ApplicationCommandManager|ApplicationCommand}\n     * @private\n     */\n    this.manager = manager;\n\n    /**\n     * The guild that this manager acts on\n     * @type {?Guild}\n     */\n    this.guild = manager.guild ?? null;\n\n    /**\n     * The id of the guild that this manager acts on\n     * @type {?Snowflake}\n     */\n    this.guildId = manager.guildId ?? manager.guild?.id ?? null;\n\n    /**\n     * The id of the command this manager acts on\n     * @type {?Snowflake}\n     */\n    this.commandId = manager.id ?? null;\n  }\n\n  /**\n   * The APIRouter path to the commands\n   * @param {Snowflake} guildId The guild's id to use in the path,\n   * @param {Snowflake} [commandId] The application command's id\n   * @returns {string}\n   * @private\n   */\n  permissionsPath(guildId, commandId) {\n    if (commandId) {\n      return Routes.applicationCommandPermissions(this.client.application.id, guildId, commandId);\n    }\n\n    return Routes.guildApplicationCommandsPermissions(this.client.application.id, guildId);\n  }\n\n  /* eslint-disable max-len */\n  /**\n   * The object returned when fetching permissions for an application command.\n   * @typedef {Object} ApplicationCommandPermissions\n   * @property {Snowflake} id The role, user, or channel's id. Can also be a\n   * {@link https://discord.com/developers/docs/interactions/application-commands#application-command-permissions-object-application-command-permissions-constants permission constant}.\n   * @property {ApplicationCommandPermissionType} type Whether this permission is for a role or a user\n   * @property {boolean} permission Whether the role or user has the permission to use this command\n   */\n  /* eslint-enable max-len */\n\n  /**\n   * Options for managing permissions for one or more Application Commands\n   * <warn>When passing these options to a manager where `guildId` is `null`,\n   * `guild` is a required parameter</warn>\n   * @typedef {Object} BaseApplicationCommandPermissionsOptions\n   * @property {GuildResolvable} [guild] The guild to modify / check permissions for\n   * <warn>Ignored when the manager has a non-null `guildId` property</warn>\n   * @property {ApplicationCommandResolvable} [command] The command to modify / check permissions for\n   * <warn>Ignored when the manager has a non-null `commandId` property</warn>\n   */\n\n  /**\n   * Fetches the permissions for one or multiple commands. Providing the client's id as the \"command id\" will fetch\n   * *only* the guild level permissions\n   * @param {BaseApplicationCommandPermissionsOptions} [options] Options used to fetch permissions\n   * @returns {Promise<ApplicationCommandPermissions[]|Collection<Snowflake, ApplicationCommandPermissions[]>>}\n   * @example\n   * // Fetch permissions for one command\n   * guild.commands.permissions.fetch({ command: '123456789012345678' })\n   *   .then(perms => console.log(`Fetched ${perms.length} overwrites`))\n   *   .catch(console.error);\n   * @example\n   * // Fetch permissions for all commands in a guild\n   * client.application.commands.permissions.fetch({ guild: '123456789012345678' })\n   *   .then(perms => console.log(`Fetched permissions for ${perms.size} commands`))\n   *   .catch(console.error);\n   * @example\n   * // Fetch guild level permissions\n   * guild.commands.permissions.fetch({ command: client.user.id })\n   *   .then(perms => console.log(`Fetched ${perms.length} guild level permissions`))\n   *   .catch(console.error);\n   */\n  async fetch({ guild, command } = {}) {\n    const { guildId, commandId } = this._validateOptions(guild, command);\n    if (commandId) {\n      const data = await this.client.rest.get(this.permissionsPath(guildId, commandId));\n      return data.permissions;\n    }\n\n    const data = await this.client.rest.get(this.permissionsPath(guildId));\n    return data.reduce((coll, perm) => coll.set(perm.id, perm.permissions), new Collection());\n  }\n\n  /**\n   * Options used to set permissions for one or more Application Commands in a guild\n   * <warn>Omitting the `command` parameter edits the guild wide permissions\n   * when the manager's `commandId` is `null`</warn>\n   * @typedef {BaseApplicationCommandPermissionsOptions} EditApplicationCommandPermissionsOptions\n   * @property {ApplicationCommandPermissions[]} permissions The new permissions for the guild or overwrite\n   * @property {string} token The bearer token to use that authorizes the permission edit\n   */\n\n  /**\n   * Sets the permissions for the guild or a command overwrite.\n   * @param {EditApplicationCommandPermissionsOptions} options Options used to set permissions\n   * @returns {Promise<ApplicationCommandPermissions[]|Collection<Snowflake, ApplicationCommandPermissions[]>>}\n   * @example\n   * // Set a permission overwrite for a command\n   * client.application.commands.permissions.set({\n   *  guild: '892455839386304532',\n   *  command: '123456789012345678',\n   *  token: 'TotallyRealToken',\n   *  permissions: [\n   *    {\n   *      id: '876543210987654321',\n   *      type: ApplicationCommandPermissionType.User,\n   *      permission: false,\n   *    },\n   * ]})\n   *   .then(console.log)\n   *   .catch(console.error);\n   * @example\n   * // Set the permissions used for the guild (commands without overwrites)\n   * guild.commands.permissions.set({ token: 'TotallyRealToken', permissions: [\n   *   {\n   *     id: '123456789012345678',\n   *     permissions: [{\n   *       id: '876543210987654321',\n   *       type: ApplicationCommandPermissionType.User,\n   *       permission: false,\n   *     }],\n   *   },\n   * ]})\n   *   .then(console.log)\n   *   .catch(console.error);\n   */\n  async set({ guild, command, permissions, token } = {}) {\n    if (!token) {\n      throw new DiscordjsError(ErrorCodes.ApplicationCommandPermissionsTokenMissing);\n    }\n    let { guildId, commandId } = this._validateOptions(guild, command);\n\n    if (!Array.isArray(permissions)) {\n      throw new DiscordjsTypeError(\n        ErrorCodes.InvalidType,\n        'permissions',\n        'Array of ApplicationCommandPermissions',\n        true,\n      );\n    }\n\n    if (!commandId) {\n      commandId = this.client.user.id;\n    }\n    const data = await this.client.rest.put(this.permissionsPath(guildId, commandId), {\n      body: { permissions },\n      auth: false,\n      headers: { Authorization: `Bearer ${token}` },\n    });\n    return data.permissions;\n  }\n\n  /**\n   * Add permissions to a command.\n   * @param {EditApplicationCommandPermissionsOptions} options Options used to add permissions\n   * @returns {Promise<ApplicationCommandPermissions[]>}\n   * @example\n   * // Add a rule to block a role from using a command\n   * guild.commands.permissions.add({ command: '123456789012345678', token: 'TotallyRealToken', permissions: [\n   *   {\n   *     id: '876543211234567890',\n   *     type: ApplicationCommandPermissionType.Role,\n   *     permission: false\n   *   },\n   * ]})\n   *   .then(console.log)\n   *   .catch(console.error);\n   */\n  async add({ guild, command, permissions, token } = {}) {\n    if (!token) {\n      throw new DiscordjsError(ErrorCodes.ApplicationCommandPermissionsTokenMissing);\n    }\n    let { guildId, commandId } = this._validateOptions(guild, command);\n    if (!commandId) {\n      commandId = this.client.user.id;\n    }\n    if (!Array.isArray(permissions)) {\n      throw new DiscordjsTypeError(\n        ErrorCodes.InvalidType,\n        'permissions',\n        'Array of ApplicationCommandPermissions',\n        true,\n      );\n    }\n\n    let existing = [];\n    try {\n      existing = await this.fetch({ guild: guildId, command: commandId });\n    } catch (error) {\n      if (error.code !== RESTJSONErrorCodes.UnknownApplicationCommandPermissions) throw error;\n    }\n\n    const newPermissions = permissions.slice();\n    for (const perm of existing) {\n      if (!newPermissions.some(x => x.id === perm.id)) {\n        newPermissions.push(perm);\n      }\n    }\n\n    return this.set({ guild: guildId, command: commandId, permissions: newPermissions, token });\n  }\n\n  /**\n   * A static snowflake that identifies the everyone role for application command permissions.\n   * It is the same as the guild id\n   * @typedef {Snowflake} RolePermissionConstant\n   */\n\n  /**\n   * A static snowflake that identifies the \"all channels\" entity for application command permissions.\n   * It will be the result of the calculation `guildId - 1`\n   * @typedef {Snowflake} ChannelPermissionConstant\n   */\n\n  /**\n   * Options used to remove permissions from a command\n   * <warn>Omitting the `command` parameter removes from the guild wide permissions\n   * when the managers `commandId` is `null`</warn>\n   * <warn>At least one of `users`, `roles`, and `channels` is required</warn>\n   * @typedef {BaseApplicationCommandPermissionsOptions} RemoveApplicationCommandPermissionsOptions\n   * @property {string} token The bearer token to use that authorizes the permission removal\n   * @property {UserResolvable[]} [users] The user(s) to remove\n   * @property {Array<RoleResolvable|RolePermissionConstant>} [roles] The role(s) to remove\n   * @property {Array<GuildChannelResolvable|ChannelPermissionConstant>} [channels] The channel(s) to remove\n   */\n\n  /**\n   * Remove permissions from a command.\n   * @param {RemoveApplicationCommandPermissionsOptions} options Options used to remove permissions\n   * @returns {Promise<ApplicationCommandPermissions[]>}\n   * @example\n   * // Remove a user permission from this command\n   * guild.commands.permissions.remove({\n   *  command: '123456789012345678', users: '876543210123456789', token: 'TotallyRealToken',\n   * })\n   *   .then(console.log)\n   *   .catch(console.error);\n   * @example\n   * // Remove multiple roles from this command\n   * guild.commands.permissions.remove({\n   *   command: '123456789012345678', roles: ['876543210123456789', '765432101234567890'], token: 'TotallyRealToken',\n   * })\n   *    .then(console.log)\n   *    .catch(console.error);\n   */\n  async remove({ guild, command, users, roles, channels, token } = {}) {\n    if (!token) {\n      throw new DiscordjsError(ErrorCodes.ApplicationCommandPermissionsTokenMissing);\n    }\n    let { guildId, commandId } = this._validateOptions(guild, command);\n    if (!commandId) {\n      commandId = this.client.user.id;\n    }\n\n    if (!users && !roles && !channels) {\n      throw new DiscordjsTypeError(ErrorCodes.InvalidType, 'users OR roles OR channels', 'Array or Resolvable', true);\n    }\n\n    let resolvedUserIds = [];\n    if (Array.isArray(users)) {\n      for (const user of users) {\n        const userId = this.client.users.resolveId(user);\n        if (!userId) throw new DiscordjsTypeError(ErrorCodes.InvalidElement, 'Array', 'users', user);\n        resolvedUserIds.push(userId);\n      }\n    }\n\n    let resolvedRoleIds = [];\n    if (Array.isArray(roles)) {\n      for (const role of roles) {\n        if (typeof role === 'string') {\n          resolvedRoleIds.push(role);\n          continue;\n        }\n        if (!this.guild) throw new DiscordjsError(ErrorCodes.GuildUncachedEntityResolve, 'roles');\n        const roleId = this.guild.roles.resolveId(role);\n        if (!roleId) throw new DiscordjsTypeError(ErrorCodes.InvalidElement, 'Array', 'users', role);\n        resolvedRoleIds.push(roleId);\n      }\n    }\n\n    let resolvedChannelIds = [];\n    if (Array.isArray(channels)) {\n      for (const channel of channels) {\n        if (typeof channel === 'string') {\n          resolvedChannelIds.push(channel);\n          continue;\n        }\n        if (!this.guild) throw new DiscordjsError(ErrorCodes.GuildUncachedEntityResolve, 'channels');\n        const channelId = this.guild.channels.resolveId(channel);\n        if (!channelId) throw new DiscordjsTypeError(ErrorCodes.InvalidElement, 'Array', 'channels', channel);\n        resolvedChannelIds.push(channelId);\n      }\n    }\n\n    let existing = [];\n    try {\n      existing = await this.fetch({ guild: guildId, command: commandId });\n    } catch (error) {\n      if (error.code !== RESTJSONErrorCodes.UnknownApplicationCommandPermissions) throw error;\n    }\n\n    const permissions = existing.filter(perm => {\n      switch (perm.type) {\n        case ApplicationCommandPermissionType.Role:\n          return !resolvedRoleIds.includes(perm.id);\n        case ApplicationCommandPermissionType.User:\n          return !resolvedUserIds.includes(perm.id);\n        case ApplicationCommandPermissionType.Channel:\n          return !resolvedChannelIds.includes(perm.id);\n      }\n      return true;\n    });\n\n    return this.set({ guild: guildId, command: commandId, permissions, token });\n  }\n\n  /**\n   * Options used to check the existence of permissions on a command\n   * <warn>The `command` parameter is not optional when the managers `commandId` is `null`</warn>\n   * @typedef {BaseApplicationCommandPermissionsOptions} HasApplicationCommandPermissionsOptions\n   * @property {ApplicationCommandPermissionIdResolvable} permissionId The entity to check if a permission exists for\n   * on this command.\n   * @property {ApplicationCommandPermissionType} [permissionType] Check for a specific type of permission\n   */\n\n  /**\n   * Check whether a permission exists for a user, role, or channel\n   * @param {HasApplicationCommandPermissionsOptions} options Options used to check permissions\n   * @returns {Promise<boolean>}\n   * @example\n   * // Check whether a user has permission to use a command\n   * guild.commands.permissions.has({ command: '123456789012345678', permissionId: '876543210123456789' })\n   *  .then(console.log)\n   *  .catch(console.error);\n   */\n  async has({ guild, command, permissionId, permissionType }) {\n    const { guildId, commandId } = this._validateOptions(guild, command);\n    if (!commandId) throw new DiscordjsTypeError(ErrorCodes.InvalidType, 'command', 'ApplicationCommandResolvable');\n\n    if (!permissionId) {\n      throw new DiscordjsTypeError(\n        ErrorCodes.InvalidType,\n        'permissionId',\n        'UserResolvable, RoleResolvable, ChannelResolvable, or Permission Constant',\n      );\n    }\n    let resolvedId = permissionId;\n    if (typeof permissionId !== 'string') {\n      resolvedId = this.client.users.resolveId(permissionId);\n      if (!resolvedId) {\n        if (!this.guild) throw new DiscordjsError(ErrorCodes.GuildUncachedEntityResolve, 'roles');\n        resolvedId = this.guild.roles.resolveId(permissionId);\n      }\n      if (!resolvedId) {\n        resolvedId = this.guild.channels.resolveId(permissionId);\n      }\n      if (!resolvedId) {\n        throw new DiscordjsTypeError(\n          ErrorCodes.InvalidType,\n          'permissionId',\n          'UserResolvable, RoleResolvable, ChannelResolvable, or Permission Constant',\n        );\n      }\n    }\n\n    let existing = [];\n    try {\n      existing = await this.fetch({ guild: guildId, command: commandId });\n    } catch (error) {\n      if (error.code !== RESTJSONErrorCodes.UnknownApplicationCommandPermissions) throw error;\n    }\n\n    // Check permission type if provided for the single edge case where a channel id is the same as the everyone role id\n    return existing.some(perm => perm.id === resolvedId && (permissionType ?? perm.type) === perm.type);\n  }\n\n  _validateOptions(guild, command) {\n    const guildId = this.guildId ?? this.client.guilds.resolveId(guild);\n    if (!guildId) throw new DiscordjsError(ErrorCodes.GlobalCommandPermissions);\n    let commandId = this.commandId;\n    if (command && !commandId) {\n      commandId = this.manager.resolveId?.(command);\n      if (!commandId && this.guild) {\n        commandId = this.guild.commands.resolveId(command);\n      }\n      commandId ??= this.client.application?.commands.resolveId(command);\n      if (!commandId) {\n        throw new DiscordjsTypeError(ErrorCodes.InvalidType, 'command', 'ApplicationCommandResolvable', true);\n      }\n    }\n    return { guildId, commandId };\n  }\n}\n\nmodule.exports = ApplicationCommandPermissionsManager;\n\n/* eslint-disable max-len */\n/**\n * @external APIApplicationCommandPermissions\n * @see {@link https://discord.com/developers/docs/interactions/application-commands#application-command-permissions-object-application-command-permissions-structure}\n */\n\n/**\n * Data that resolves to an id used for an application command permission\n * @typedef {UserResolvable|RoleResolvable|GuildChannelResolvable|RolePermissionConstant|ChannelPermissionConstant} ApplicationCommandPermissionIdResolvable\n */\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}