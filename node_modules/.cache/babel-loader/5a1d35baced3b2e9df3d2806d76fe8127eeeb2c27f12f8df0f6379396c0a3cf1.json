{"ast":null,"code":"'use strict';\n\nconst {\n  ChannelType,\n  Routes\n} = require('discord-api-types/v10');\nconst CachedManager = require('./CachedManager');\nconst {\n  DiscordjsError,\n  ErrorCodes\n} = require('../errors');\nconst {\n  GuildMember\n} = require('../structures/GuildMember');\nconst {\n  Message\n} = require('../structures/Message');\nconst ThreadMember = require('../structures/ThreadMember');\nconst User = require('../structures/User');\n\n/**\n * Manages API methods for users and stores their cache.\n * @extends {CachedManager}\n */\nclass UserManager extends CachedManager {\n  constructor(client, iterable) {\n    super(client, User, iterable);\n  }\n\n  /**\n   * The cache of this manager\n   * @type {Collection<Snowflake, User>}\n   * @name UserManager#cache\n   */\n\n  /**\n   * Data that resolves to give a User object. This can be:\n   * * A User object\n   * * A Snowflake\n   * * A Message object (resolves to the message author)\n   * * A GuildMember object\n   * * A ThreadMember object\n   * @typedef {User|Snowflake|Message|GuildMember|ThreadMember} UserResolvable\n   */\n\n  /**\n   * The DM between the client's user and a user\n   * @param {Snowflake} userId The user id\n   * @returns {?DMChannel}\n   * @private\n   */\n  dmChannel(userId) {\n    return this.client.channels.cache.find(c => c.type === ChannelType.DM && c.recipientId === userId) ?? null;\n  }\n\n  /**\n   * Creates a {@link DMChannel} between the client and a user.\n   * @param {UserResolvable} user The UserResolvable to identify\n   * @param {BaseFetchOptions} [options] Additional options for this fetch\n   * @returns {Promise<DMChannel>}\n   */\n  async createDM(user) {\n    let {\n      cache = true,\n      force = false\n    } = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    const id = this.resolveId(user);\n    if (!force) {\n      const dmChannel = this.dmChannel(id);\n      if (dmChannel && !dmChannel.partial) return dmChannel;\n    }\n    const data = await this.client.rest.post(Routes.userChannels(), {\n      body: {\n        recipient_id: id\n      }\n    });\n    return this.client.channels._add(data, null, {\n      cache\n    });\n  }\n\n  /**\n   * Deletes a {@link DMChannel} (if one exists) between the client and a user. Resolves with the channel if successful.\n   * @param {UserResolvable} user The UserResolvable to identify\n   * @returns {Promise<DMChannel>}\n   */\n  async deleteDM(user) {\n    const id = this.resolveId(user);\n    const dmChannel = this.dmChannel(id);\n    if (!dmChannel) throw new DiscordjsError(ErrorCodes.UserNoDMChannel);\n    await this.client.rest.delete(Routes.channel(dmChannel.id));\n    this.client.channels._remove(dmChannel.id);\n    return dmChannel;\n  }\n\n  /**\n   * Obtains a user from Discord, or the user cache if it's already available.\n   * @param {UserResolvable} user The user to fetch\n   * @param {BaseFetchOptions} [options] Additional options for this fetch\n   * @returns {Promise<User>}\n   */\n  async fetch(user) {\n    let {\n      cache = true,\n      force = false\n    } = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    const id = this.resolveId(user);\n    if (!force) {\n      const existing = this.cache.get(id);\n      if (existing && !existing.partial) return existing;\n    }\n    const data = await this.client.rest.get(Routes.user(id));\n    return this._add(data, cache);\n  }\n\n  /**\n   * Fetches a user's flags.\n   * @param {UserResolvable} user The UserResolvable to identify\n   * @param {BaseFetchOptions} [options] Additional options for this fetch\n   * @returns {Promise<UserFlagsBitField>}\n   */\n  async fetchFlags(user, options) {\n    return (await this.fetch(user, options)).flags;\n  }\n\n  /**\n   * Sends a message to a user.\n   * @param {UserResolvable} user The UserResolvable to identify\n   * @param {string|MessagePayload|MessageCreateOptions} options The options to provide\n   * @returns {Promise<Message>}\n   */\n  async send(user, options) {\n    return (await this.createDM(user)).send(options);\n  }\n\n  /**\n   * Resolves a {@link UserResolvable} to a {@link User} object.\n   * @param {UserResolvable} user The UserResolvable to identify\n   * @returns {?User}\n   */\n  resolve(user) {\n    if (user instanceof GuildMember || user instanceof ThreadMember) return user.user;\n    if (user instanceof Message) return user.author;\n    return super.resolve(user);\n  }\n\n  /**\n   * Resolves a {@link UserResolvable} to a {@link User} id.\n   * @param {UserResolvable} user The UserResolvable to identify\n   * @returns {?Snowflake}\n   */\n  resolveId(user) {\n    if (user instanceof ThreadMember) return user.id;\n    if (user instanceof GuildMember) return user.user.id;\n    if (user instanceof Message) return user.author.id;\n    return super.resolveId(user);\n  }\n}\nmodule.exports = UserManager;","map":{"version":3,"names":["ChannelType","Routes","require","CachedManager","DiscordjsError","ErrorCodes","GuildMember","Message","ThreadMember","User","UserManager","constructor","client","iterable","dmChannel","userId","channels","cache","find","c","type","DM","recipientId","createDM","user","force","id","resolveId","partial","data","rest","post","userChannels","body","recipient_id","_add","deleteDM","UserNoDMChannel","delete","channel","_remove","fetch","existing","get","fetchFlags","options","flags","send","resolve","author","module","exports"],"sources":["J:/Coding/Projekts/Web/JavaScript/sillcode.tech/node_modules/discord.js/src/managers/UserManager.js"],"sourcesContent":["'use strict';\n\nconst { ChannelType, Routes } = require('discord-api-types/v10');\nconst CachedManager = require('./CachedManager');\nconst { DiscordjsError, ErrorCodes } = require('../errors');\nconst { GuildMember } = require('../structures/GuildMember');\nconst { Message } = require('../structures/Message');\nconst ThreadMember = require('../structures/ThreadMember');\nconst User = require('../structures/User');\n\n/**\n * Manages API methods for users and stores their cache.\n * @extends {CachedManager}\n */\nclass UserManager extends CachedManager {\n  constructor(client, iterable) {\n    super(client, User, iterable);\n  }\n\n  /**\n   * The cache of this manager\n   * @type {Collection<Snowflake, User>}\n   * @name UserManager#cache\n   */\n\n  /**\n   * Data that resolves to give a User object. This can be:\n   * * A User object\n   * * A Snowflake\n   * * A Message object (resolves to the message author)\n   * * A GuildMember object\n   * * A ThreadMember object\n   * @typedef {User|Snowflake|Message|GuildMember|ThreadMember} UserResolvable\n   */\n\n  /**\n   * The DM between the client's user and a user\n   * @param {Snowflake} userId The user id\n   * @returns {?DMChannel}\n   * @private\n   */\n  dmChannel(userId) {\n    return this.client.channels.cache.find(c => c.type === ChannelType.DM && c.recipientId === userId) ?? null;\n  }\n\n  /**\n   * Creates a {@link DMChannel} between the client and a user.\n   * @param {UserResolvable} user The UserResolvable to identify\n   * @param {BaseFetchOptions} [options] Additional options for this fetch\n   * @returns {Promise<DMChannel>}\n   */\n  async createDM(user, { cache = true, force = false } = {}) {\n    const id = this.resolveId(user);\n\n    if (!force) {\n      const dmChannel = this.dmChannel(id);\n      if (dmChannel && !dmChannel.partial) return dmChannel;\n    }\n\n    const data = await this.client.rest.post(Routes.userChannels(), { body: { recipient_id: id } });\n    return this.client.channels._add(data, null, { cache });\n  }\n\n  /**\n   * Deletes a {@link DMChannel} (if one exists) between the client and a user. Resolves with the channel if successful.\n   * @param {UserResolvable} user The UserResolvable to identify\n   * @returns {Promise<DMChannel>}\n   */\n  async deleteDM(user) {\n    const id = this.resolveId(user);\n    const dmChannel = this.dmChannel(id);\n    if (!dmChannel) throw new DiscordjsError(ErrorCodes.UserNoDMChannel);\n    await this.client.rest.delete(Routes.channel(dmChannel.id));\n    this.client.channels._remove(dmChannel.id);\n    return dmChannel;\n  }\n\n  /**\n   * Obtains a user from Discord, or the user cache if it's already available.\n   * @param {UserResolvable} user The user to fetch\n   * @param {BaseFetchOptions} [options] Additional options for this fetch\n   * @returns {Promise<User>}\n   */\n  async fetch(user, { cache = true, force = false } = {}) {\n    const id = this.resolveId(user);\n    if (!force) {\n      const existing = this.cache.get(id);\n      if (existing && !existing.partial) return existing;\n    }\n\n    const data = await this.client.rest.get(Routes.user(id));\n    return this._add(data, cache);\n  }\n\n  /**\n   * Fetches a user's flags.\n   * @param {UserResolvable} user The UserResolvable to identify\n   * @param {BaseFetchOptions} [options] Additional options for this fetch\n   * @returns {Promise<UserFlagsBitField>}\n   */\n  async fetchFlags(user, options) {\n    return (await this.fetch(user, options)).flags;\n  }\n\n  /**\n   * Sends a message to a user.\n   * @param {UserResolvable} user The UserResolvable to identify\n   * @param {string|MessagePayload|MessageCreateOptions} options The options to provide\n   * @returns {Promise<Message>}\n   */\n  async send(user, options) {\n    return (await this.createDM(user)).send(options);\n  }\n\n  /**\n   * Resolves a {@link UserResolvable} to a {@link User} object.\n   * @param {UserResolvable} user The UserResolvable to identify\n   * @returns {?User}\n   */\n  resolve(user) {\n    if (user instanceof GuildMember || user instanceof ThreadMember) return user.user;\n    if (user instanceof Message) return user.author;\n    return super.resolve(user);\n  }\n\n  /**\n   * Resolves a {@link UserResolvable} to a {@link User} id.\n   * @param {UserResolvable} user The UserResolvable to identify\n   * @returns {?Snowflake}\n   */\n  resolveId(user) {\n    if (user instanceof ThreadMember) return user.id;\n    if (user instanceof GuildMember) return user.user.id;\n    if (user instanceof Message) return user.author.id;\n    return super.resolveId(user);\n  }\n}\n\nmodule.exports = UserManager;\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}