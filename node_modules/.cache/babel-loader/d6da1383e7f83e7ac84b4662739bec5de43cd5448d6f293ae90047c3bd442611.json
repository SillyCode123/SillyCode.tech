{"ast":null,"code":"'use strict';\n\nconst process = require('node:process');\nconst {\n  Collection\n} = require('@discordjs/collection');\nconst {\n  OverwriteType,\n  Routes\n} = require('discord-api-types/v10');\nconst CachedManager = require('./CachedManager');\nconst {\n  DiscordjsTypeError,\n  ErrorCodes\n} = require('../errors');\nconst PermissionOverwrites = require('../structures/PermissionOverwrites');\nconst {\n  Role\n} = require('../structures/Role');\nlet cacheWarningEmitted = false;\n\n/**\n * Manages API methods for guild channel permission overwrites and stores their cache.\n * @extends {CachedManager}\n */\nclass PermissionOverwriteManager extends CachedManager {\n  constructor(channel, iterable) {\n    super(channel.client, PermissionOverwrites);\n    if (!cacheWarningEmitted && this._cache.constructor.name !== 'Collection') {\n      cacheWarningEmitted = true;\n      process.emitWarning(`Overriding the cache handling for ${this.constructor.name} is unsupported and breaks functionality.`, 'UnsupportedCacheOverwriteWarning');\n    }\n\n    /**\n     * The channel of the permission overwrite this manager belongs to\n     * @type {GuildChannel}\n     */\n    this.channel = channel;\n    if (iterable) {\n      for (const item of iterable) {\n        this._add(item);\n      }\n    }\n  }\n\n  /**\n   * The cache of this Manager\n   * @type {Collection<Snowflake, PermissionOverwrites>}\n   * @name PermissionOverwriteManager#cache\n   */\n\n  _add(data, cache) {\n    return super._add(data, cache, {\n      extras: [this.channel]\n    });\n  }\n\n  /**\n   * Replaces the permission overwrites in this channel.\n   * @param {OverwriteResolvable[]|Collection<Snowflake, OverwriteResolvable>} overwrites\n   * Permission overwrites the channel gets updated with\n   * @param {string} [reason] Reason for updating the channel overwrites\n   * @returns {Promise<GuildChannel>}\n   * @example\n   * message.channel.permissionOverwrites.set([\n   *   {\n   *      id: message.author.id,\n   *      deny: [PermissionsFlagsBit.ViewChannel],\n   *   },\n   * ], 'Needed to change permissions');\n   */\n  set(overwrites, reason) {\n    if (!Array.isArray(overwrites) && !(overwrites instanceof Collection)) {\n      return Promise.reject(new DiscordjsTypeError(ErrorCodes.InvalidType, 'overwrites', 'Array or Collection of Permission Overwrites', true));\n    }\n    return this.channel.edit({\n      permissionOverwrites: overwrites,\n      reason\n    });\n  }\n\n  /**\n   * Extra information about the overwrite.\n   * @typedef {Object} GuildChannelOverwriteOptions\n   * @property {string} [reason] The reason for creating/editing this overwrite\n   * @property {OverwriteType} [type] The type of overwrite. Use this to bypass automatic resolution of `type`\n   * that results in an error for an uncached structure\n   */\n\n  /**\n   * Creates or edits permission overwrites for a user or role in this channel.\n   * @param {RoleResolvable|UserResolvable} userOrRole The user or role to update\n   * @param {PermissionOverwriteOptions} options The options for the update\n   * @param {GuildChannelOverwriteOptions} [overwriteOptions] The extra information for the update\n   * @param {PermissionOverwrites} [existing] The existing overwrites to merge with this update\n   * @returns {Promise<GuildChannel>}\n   * @private\n   */\n  async upsert(userOrRole, options) {\n    let overwriteOptions = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n    let existing = arguments.length > 3 ? arguments[3] : undefined;\n    let userOrRoleId = this.channel.guild.roles.resolveId(userOrRole) ?? this.client.users.resolveId(userOrRole);\n    let {\n      type,\n      reason\n    } = overwriteOptions;\n    if (typeof type !== 'number') {\n      userOrRole = this.channel.guild.roles.resolve(userOrRole) ?? this.client.users.resolve(userOrRole);\n      if (!userOrRole) throw new DiscordjsTypeError(ErrorCodes.InvalidType, 'parameter', 'User nor a Role');\n      type = userOrRole instanceof Role ? OverwriteType.Role : OverwriteType.Member;\n    }\n    const {\n      allow,\n      deny\n    } = PermissionOverwrites.resolveOverwriteOptions(options, existing);\n    await this.client.rest.put(Routes.channelPermission(this.channel.id, userOrRoleId), {\n      body: {\n        id: userOrRoleId,\n        type,\n        allow,\n        deny\n      },\n      reason\n    });\n    return this.channel;\n  }\n\n  /**\n   * Creates permission overwrites for a user or role in this channel, or replaces them if already present.\n   * @param {RoleResolvable|UserResolvable} userOrRole The user or role to update\n   * @param {PermissionOverwriteOptions} options The options for the update\n   * @param {GuildChannelOverwriteOptions} [overwriteOptions] The extra information for the update\n   * @returns {Promise<GuildChannel>}\n   * @example\n   * // Create or Replace permission overwrites for a message author\n   * message.channel.permissionOverwrites.create(message.author, {\n   *   SendMessages: false\n   * })\n   *   .then(channel => console.log(channel.permissionOverwrites.cache.get(message.author.id)))\n   *   .catch(console.error);\n   */\n  create(userOrRole, options, overwriteOptions) {\n    return this.upsert(userOrRole, options, overwriteOptions);\n  }\n\n  /**\n   * Edits permission overwrites for a user or role in this channel, or creates an entry if not already present.\n   * @param {RoleResolvable|UserResolvable} userOrRole The user or role to update\n   * @param {PermissionOverwriteOptions} options The options for the update\n   * @param {GuildChannelOverwriteOptions} [overwriteOptions] The extra information for the update\n   * @returns {Promise<GuildChannel>}\n   * @example\n   * // Edit or Create permission overwrites for a message author\n   * message.channel.permissionOverwrites.edit(message.author, {\n   *   SendMessages: false\n   * })\n   *   .then(channel => console.log(channel.permissionOverwrites.cache.get(message.author.id)))\n   *   .catch(console.error);\n   */\n  edit(userOrRole, options, overwriteOptions) {\n    const existing = this.cache.get(this.channel.guild.roles.resolveId(userOrRole) ?? this.client.users.resolveId(userOrRole));\n    return this.upsert(userOrRole, options, overwriteOptions, existing);\n  }\n\n  /**\n   * Deletes permission overwrites for a user or role in this channel.\n   * @param {UserResolvable|RoleResolvable} userOrRole The user or role to delete\n   * @param {string} [reason] The reason for deleting the overwrite\n   * @returns {Promise<GuildChannel>}\n   */\n  async delete(userOrRole, reason) {\n    const userOrRoleId = this.channel.guild.roles.resolveId(userOrRole) ?? this.client.users.resolveId(userOrRole);\n    if (!userOrRoleId) throw new DiscordjsTypeError(ErrorCodes.InvalidType, 'parameter', 'User nor a Role');\n    await this.client.rest.delete(Routes.channelPermission(this.channel.id, userOrRoleId), {\n      reason\n    });\n    return this.channel;\n  }\n}\nmodule.exports = PermissionOverwriteManager;","map":{"version":3,"names":["process","require","Collection","OverwriteType","Routes","CachedManager","DiscordjsTypeError","ErrorCodes","PermissionOverwrites","Role","cacheWarningEmitted","PermissionOverwriteManager","constructor","channel","iterable","client","_cache","name","emitWarning","item","_add","data","cache","extras","set","overwrites","reason","Array","isArray","Promise","reject","InvalidType","edit","permissionOverwrites","upsert","userOrRole","options","overwriteOptions","existing","userOrRoleId","guild","roles","resolveId","users","type","resolve","Member","allow","deny","resolveOverwriteOptions","rest","put","channelPermission","id","body","create","get","delete","module","exports"],"sources":["J:/Coding/Projekts/Web/JavaScript/sillcode.tech/node_modules/discord.js/src/managers/PermissionOverwriteManager.js"],"sourcesContent":["'use strict';\n\nconst process = require('node:process');\nconst { Collection } = require('@discordjs/collection');\nconst { OverwriteType, Routes } = require('discord-api-types/v10');\nconst CachedManager = require('./CachedManager');\nconst { DiscordjsTypeError, ErrorCodes } = require('../errors');\nconst PermissionOverwrites = require('../structures/PermissionOverwrites');\nconst { Role } = require('../structures/Role');\n\nlet cacheWarningEmitted = false;\n\n/**\n * Manages API methods for guild channel permission overwrites and stores their cache.\n * @extends {CachedManager}\n */\nclass PermissionOverwriteManager extends CachedManager {\n  constructor(channel, iterable) {\n    super(channel.client, PermissionOverwrites);\n    if (!cacheWarningEmitted && this._cache.constructor.name !== 'Collection') {\n      cacheWarningEmitted = true;\n      process.emitWarning(\n        `Overriding the cache handling for ${this.constructor.name} is unsupported and breaks functionality.`,\n        'UnsupportedCacheOverwriteWarning',\n      );\n    }\n\n    /**\n     * The channel of the permission overwrite this manager belongs to\n     * @type {GuildChannel}\n     */\n    this.channel = channel;\n\n    if (iterable) {\n      for (const item of iterable) {\n        this._add(item);\n      }\n    }\n  }\n\n  /**\n   * The cache of this Manager\n   * @type {Collection<Snowflake, PermissionOverwrites>}\n   * @name PermissionOverwriteManager#cache\n   */\n\n  _add(data, cache) {\n    return super._add(data, cache, { extras: [this.channel] });\n  }\n\n  /**\n   * Replaces the permission overwrites in this channel.\n   * @param {OverwriteResolvable[]|Collection<Snowflake, OverwriteResolvable>} overwrites\n   * Permission overwrites the channel gets updated with\n   * @param {string} [reason] Reason for updating the channel overwrites\n   * @returns {Promise<GuildChannel>}\n   * @example\n   * message.channel.permissionOverwrites.set([\n   *   {\n   *      id: message.author.id,\n   *      deny: [PermissionsFlagsBit.ViewChannel],\n   *   },\n   * ], 'Needed to change permissions');\n   */\n  set(overwrites, reason) {\n    if (!Array.isArray(overwrites) && !(overwrites instanceof Collection)) {\n      return Promise.reject(\n        new DiscordjsTypeError(\n          ErrorCodes.InvalidType,\n          'overwrites',\n          'Array or Collection of Permission Overwrites',\n          true,\n        ),\n      );\n    }\n    return this.channel.edit({ permissionOverwrites: overwrites, reason });\n  }\n\n  /**\n   * Extra information about the overwrite.\n   * @typedef {Object} GuildChannelOverwriteOptions\n   * @property {string} [reason] The reason for creating/editing this overwrite\n   * @property {OverwriteType} [type] The type of overwrite. Use this to bypass automatic resolution of `type`\n   * that results in an error for an uncached structure\n   */\n\n  /**\n   * Creates or edits permission overwrites for a user or role in this channel.\n   * @param {RoleResolvable|UserResolvable} userOrRole The user or role to update\n   * @param {PermissionOverwriteOptions} options The options for the update\n   * @param {GuildChannelOverwriteOptions} [overwriteOptions] The extra information for the update\n   * @param {PermissionOverwrites} [existing] The existing overwrites to merge with this update\n   * @returns {Promise<GuildChannel>}\n   * @private\n   */\n  async upsert(userOrRole, options, overwriteOptions = {}, existing) {\n    let userOrRoleId = this.channel.guild.roles.resolveId(userOrRole) ?? this.client.users.resolveId(userOrRole);\n    let { type, reason } = overwriteOptions;\n    if (typeof type !== 'number') {\n      userOrRole = this.channel.guild.roles.resolve(userOrRole) ?? this.client.users.resolve(userOrRole);\n      if (!userOrRole) throw new DiscordjsTypeError(ErrorCodes.InvalidType, 'parameter', 'User nor a Role');\n      type = userOrRole instanceof Role ? OverwriteType.Role : OverwriteType.Member;\n    }\n\n    const { allow, deny } = PermissionOverwrites.resolveOverwriteOptions(options, existing);\n\n    await this.client.rest.put(Routes.channelPermission(this.channel.id, userOrRoleId), {\n      body: { id: userOrRoleId, type, allow, deny },\n      reason,\n    });\n    return this.channel;\n  }\n\n  /**\n   * Creates permission overwrites for a user or role in this channel, or replaces them if already present.\n   * @param {RoleResolvable|UserResolvable} userOrRole The user or role to update\n   * @param {PermissionOverwriteOptions} options The options for the update\n   * @param {GuildChannelOverwriteOptions} [overwriteOptions] The extra information for the update\n   * @returns {Promise<GuildChannel>}\n   * @example\n   * // Create or Replace permission overwrites for a message author\n   * message.channel.permissionOverwrites.create(message.author, {\n   *   SendMessages: false\n   * })\n   *   .then(channel => console.log(channel.permissionOverwrites.cache.get(message.author.id)))\n   *   .catch(console.error);\n   */\n  create(userOrRole, options, overwriteOptions) {\n    return this.upsert(userOrRole, options, overwriteOptions);\n  }\n\n  /**\n   * Edits permission overwrites for a user or role in this channel, or creates an entry if not already present.\n   * @param {RoleResolvable|UserResolvable} userOrRole The user or role to update\n   * @param {PermissionOverwriteOptions} options The options for the update\n   * @param {GuildChannelOverwriteOptions} [overwriteOptions] The extra information for the update\n   * @returns {Promise<GuildChannel>}\n   * @example\n   * // Edit or Create permission overwrites for a message author\n   * message.channel.permissionOverwrites.edit(message.author, {\n   *   SendMessages: false\n   * })\n   *   .then(channel => console.log(channel.permissionOverwrites.cache.get(message.author.id)))\n   *   .catch(console.error);\n   */\n  edit(userOrRole, options, overwriteOptions) {\n    const existing = this.cache.get(\n      this.channel.guild.roles.resolveId(userOrRole) ?? this.client.users.resolveId(userOrRole),\n    );\n    return this.upsert(userOrRole, options, overwriteOptions, existing);\n  }\n\n  /**\n   * Deletes permission overwrites for a user or role in this channel.\n   * @param {UserResolvable|RoleResolvable} userOrRole The user or role to delete\n   * @param {string} [reason] The reason for deleting the overwrite\n   * @returns {Promise<GuildChannel>}\n   */\n  async delete(userOrRole, reason) {\n    const userOrRoleId = this.channel.guild.roles.resolveId(userOrRole) ?? this.client.users.resolveId(userOrRole);\n    if (!userOrRoleId) throw new DiscordjsTypeError(ErrorCodes.InvalidType, 'parameter', 'User nor a Role');\n\n    await this.client.rest.delete(Routes.channelPermission(this.channel.id, userOrRoleId), { reason });\n    return this.channel;\n  }\n}\n\nmodule.exports = PermissionOverwriteManager;\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}