{"ast":null,"code":"'use strict';\n\nconst {\n  isJSONEncodable\n} = require('@discordjs/builders');\nconst {\n  InteractionResponseType,\n  MessageFlags,\n  Routes,\n  InteractionType\n} = require('discord-api-types/v10');\nconst {\n  DiscordjsError,\n  ErrorCodes\n} = require('../../errors');\nconst InteractionCollector = require('../InteractionCollector');\nconst InteractionResponse = require('../InteractionResponse');\nconst MessagePayload = require('../MessagePayload');\n\n/**\n * @typedef {Object} ModalComponentData\n * @property {string} title The title of the modal\n * @property {string} customId The custom id of the modal\n * @property {ActionRow[]} components The components within this modal\n */\n\n/**\n * Interface for classes that support shared interaction response types.\n * @interface\n */\nclass InteractionResponses {\n  /**\n   * Options for deferring the reply to an {@link BaseInteraction}.\n   * @typedef {Object} InteractionDeferReplyOptions\n   * @property {boolean} [ephemeral] Whether the reply should be ephemeral\n   * @property {boolean} [fetchReply] Whether to fetch the reply\n   */\n\n  /**\n   * Options for deferring and updating the reply to a {@link MessageComponentInteraction}.\n   * @typedef {Object} InteractionDeferUpdateOptions\n   * @property {boolean} [fetchReply] Whether to fetch the reply\n   */\n\n  /**\n   * Options for a reply to a {@link BaseInteraction}.\n   * @typedef {BaseMessageOptions} InteractionReplyOptions\n   * @property {boolean} [tts=false] Whether the message should be spoken aloud\n   * @property {boolean} [ephemeral] Whether the reply should be ephemeral\n   * @property {boolean} [fetchReply] Whether to fetch the reply\n   * @property {MessageFlags} [flags] Which flags to set for the message.\n   * <info>Only `MessageFlags.SuppressEmbeds` and `MessageFlags.Ephemeral` can be set.</info>\n   */\n\n  /**\n   * Options for updating the message received from a {@link MessageComponentInteraction}.\n   * @typedef {MessageEditOptions} InteractionUpdateOptions\n   * @property {boolean} [fetchReply] Whether to fetch the reply\n   */\n\n  /**\n   * Defers the reply to this interaction.\n   * @param {InteractionDeferReplyOptions} [options] Options for deferring the reply to this interaction\n   * @returns {Promise<Message|InteractionResponse>}\n   * @example\n   * // Defer the reply to this interaction\n   * interaction.deferReply()\n   *   .then(console.log)\n   *   .catch(console.error)\n   * @example\n   * // Defer to send an ephemeral reply later\n   * interaction.deferReply({ ephemeral: true })\n   *   .then(console.log)\n   *   .catch(console.error);\n   */\n  async deferReply() {\n    let options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    if (this.deferred || this.replied) throw new DiscordjsError(ErrorCodes.InteractionAlreadyReplied);\n    this.ephemeral = options.ephemeral ?? false;\n    await this.client.rest.post(Routes.interactionCallback(this.id, this.token), {\n      body: {\n        type: InteractionResponseType.DeferredChannelMessageWithSource,\n        data: {\n          flags: options.ephemeral ? MessageFlags.Ephemeral : undefined\n        }\n      },\n      auth: false\n    });\n    this.deferred = true;\n    return options.fetchReply ? this.fetchReply() : new InteractionResponse(this);\n  }\n\n  /**\n   * Creates a reply to this interaction.\n   * <info>Use the `fetchReply` option to get the bot's reply message.</info>\n   * @param {string|MessagePayload|InteractionReplyOptions} options The options for the reply\n   * @returns {Promise<Message|InteractionResponse>}\n   * @example\n   * // Reply to the interaction and fetch the response\n   * interaction.reply({ content: 'Pong!', fetchReply: true })\n   *   .then((message) => console.log(`Reply sent with content ${message.content}`))\n   *   .catch(console.error);\n   * @example\n   * // Create an ephemeral reply with an embed\n   * const embed = new EmbedBuilder().setDescription('Pong!');\n   *\n   * interaction.reply({ embeds: [embed], ephemeral: true })\n   *   .then(() => console.log('Reply sent.'))\n   *   .catch(console.error);\n   */\n  async reply(options) {\n    if (this.deferred || this.replied) throw new DiscordjsError(ErrorCodes.InteractionAlreadyReplied);\n    this.ephemeral = options.ephemeral ?? false;\n    let messagePayload;\n    if (options instanceof MessagePayload) messagePayload = options;else messagePayload = MessagePayload.create(this, options);\n    const {\n      body: data,\n      files\n    } = await messagePayload.resolveBody().resolveFiles();\n    await this.client.rest.post(Routes.interactionCallback(this.id, this.token), {\n      body: {\n        type: InteractionResponseType.ChannelMessageWithSource,\n        data\n      },\n      files,\n      auth: false\n    });\n    this.replied = true;\n    return options.fetchReply ? this.fetchReply() : new InteractionResponse(this);\n  }\n\n  /**\n   * Fetches a reply to this interaction.\n   * @see Webhook#fetchMessage\n   * @param {Snowflake|'@original'} [message='@original'] The response to fetch\n   * @returns {Promise<Message>}\n   * @example\n   * // Fetch the initial reply to this interaction\n   * interaction.fetchReply()\n   *   .then(reply => console.log(`Replied with ${reply.content}`))\n   *   .catch(console.error);\n   */\n  fetchReply() {\n    let message = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : '@original';\n    return this.webhook.fetchMessage(message);\n  }\n\n  /**\n   * Options that can be passed into {@link InteractionResponses#editReply}.\n   * @typedef {WebhookEditMessageOptions} InteractionEditReplyOptions\n   * @property {MessageResolvable|'@original'} [message='@original'] The response to edit\n   */\n\n  /**\n   * Edits a reply to this interaction.\n   * @see Webhook#editMessage\n   * @param {string|MessagePayload|InteractionEditReplyOptions} options The new options for the message\n   * @returns {Promise<Message>}\n   * @example\n   * // Edit the initial reply to this interaction\n   * interaction.editReply('New content')\n   *   .then(console.log)\n   *   .catch(console.error);\n   */\n  async editReply(options) {\n    if (!this.deferred && !this.replied) throw new DiscordjsError(ErrorCodes.InteractionNotReplied);\n    const msg = await this.webhook.editMessage(options.message ?? '@original', options);\n    this.replied = true;\n    return msg;\n  }\n\n  /**\n   * Deletes a reply to this interaction.\n   * @see Webhook#deleteMessage\n   * @param {MessageResolvable|'@original'} [message='@original'] The response to delete\n   * @returns {Promise<void>}\n   * @example\n   * // Delete the initial reply to this interaction\n   * interaction.deleteReply()\n   *   .then(console.log)\n   *   .catch(console.error);\n   */\n  async deleteReply() {\n    let message = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : '@original';\n    await this.webhook.deleteMessage(message);\n  }\n\n  /**\n   * Send a follow-up message to this interaction.\n   * @param {string|MessagePayload|InteractionReplyOptions} options The options for the reply\n   * @returns {Promise<Message>}\n   */\n  followUp(options) {\n    if (!this.deferred && !this.replied) return Promise.reject(new DiscordjsError(ErrorCodes.InteractionNotReplied));\n    return this.webhook.send(options);\n  }\n\n  /**\n   * Defers an update to the message to which the component was attached.\n   * @param {InteractionDeferUpdateOptions} [options] Options for deferring the update to this interaction\n   * @returns {Promise<Message|InteractionResponse>}\n   * @example\n   * // Defer updating and reset the component's loading state\n   * interaction.deferUpdate()\n   *   .then(console.log)\n   *   .catch(console.error);\n   */\n  async deferUpdate() {\n    let options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    if (this.deferred || this.replied) throw new DiscordjsError(ErrorCodes.InteractionAlreadyReplied);\n    await this.client.rest.post(Routes.interactionCallback(this.id, this.token), {\n      body: {\n        type: InteractionResponseType.DeferredMessageUpdate\n      },\n      auth: false\n    });\n    this.deferred = true;\n    return options.fetchReply ? this.fetchReply() : new InteractionResponse(this, this.message?.interaction?.id);\n  }\n\n  /**\n   * Updates the original message of the component on which the interaction was received on.\n   * @param {string|MessagePayload|InteractionUpdateOptions} options The options for the updated message\n   * @returns {Promise<Message|void>}\n   * @example\n   * // Remove the components from the message\n   * interaction.update({\n   *   content: \"A component interaction was received\",\n   *   components: []\n   * })\n   *   .then(console.log)\n   *   .catch(console.error);\n   */\n  async update(options) {\n    if (this.deferred || this.replied) throw new DiscordjsError(ErrorCodes.InteractionAlreadyReplied);\n    let messagePayload;\n    if (options instanceof MessagePayload) messagePayload = options;else messagePayload = MessagePayload.create(this, options);\n    const {\n      body: data,\n      files\n    } = await messagePayload.resolveBody().resolveFiles();\n    await this.client.rest.post(Routes.interactionCallback(this.id, this.token), {\n      body: {\n        type: InteractionResponseType.UpdateMessage,\n        data\n      },\n      files,\n      auth: false\n    });\n    this.replied = true;\n    return options.fetchReply ? this.fetchReply() : new InteractionResponse(this, this.message.interaction?.id);\n  }\n\n  /**\n   * Shows a modal component\n   * @param {APIModal|ModalData|Modal} modal The modal to show\n   * @returns {Promise<void>}\n   */\n  async showModal(modal) {\n    if (this.deferred || this.replied) throw new DiscordjsError(ErrorCodes.InteractionAlreadyReplied);\n    await this.client.rest.post(Routes.interactionCallback(this.id, this.token), {\n      body: {\n        type: InteractionResponseType.Modal,\n        data: isJSONEncodable(modal) ? modal.toJSON() : this.client.options.jsonTransformer(modal)\n      }\n    });\n    this.replied = true;\n  }\n\n  /**\n   * An object containing the same properties as {@link CollectorOptions}, but a few less:\n   * @typedef {Object} AwaitModalSubmitOptions\n   * @property {CollectorFilter} [filter] The filter applied to this collector\n   * @property {number} time Time in milliseconds to wait for an interaction before rejecting\n   */\n\n  /**\n   * Collects a single modal submit interaction that passes the filter.\n   * The Promise will reject if the time expires.\n   * @param {AwaitModalSubmitOptions} options Options to pass to the internal collector\n   * @returns {Promise<ModalSubmitInteraction>}\n   * @example\n   * // Collect a modal submit interaction\n   * const filter = (interaction) => interaction.customId === 'modal';\n   * interaction.awaitModalSubmit({ filter, time: 15_000 })\n   *   .then(interaction => console.log(`${interaction.customId} was submitted!`))\n   *   .catch(console.error);\n   */\n  awaitModalSubmit(options) {\n    if (typeof options.time !== 'number') throw new DiscordjsError(ErrorCodes.InvalidType, 'time', 'number');\n    const _options = {\n      ...options,\n      max: 1,\n      interactionType: InteractionType.ModalSubmit\n    };\n    return new Promise((resolve, reject) => {\n      const collector = new InteractionCollector(this.client, _options);\n      collector.once('end', (interactions, reason) => {\n        const interaction = interactions.first();\n        if (interaction) resolve(interaction);else reject(new DiscordjsError(ErrorCodes.InteractionCollectorError, reason));\n      });\n    });\n  }\n  static applyToClass(structure) {\n    let ignore = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];\n    const props = ['deferReply', 'reply', 'fetchReply', 'editReply', 'deleteReply', 'followUp', 'deferUpdate', 'update', 'showModal', 'awaitModalSubmit'];\n    for (const prop of props) {\n      if (ignore.includes(prop)) continue;\n      Object.defineProperty(structure.prototype, prop, Object.getOwnPropertyDescriptor(InteractionResponses.prototype, prop));\n    }\n  }\n}\nmodule.exports = InteractionResponses;","map":{"version":3,"names":["isJSONEncodable","require","InteractionResponseType","MessageFlags","Routes","InteractionType","DiscordjsError","ErrorCodes","InteractionCollector","InteractionResponse","MessagePayload","InteractionResponses","deferReply","options","deferred","replied","InteractionAlreadyReplied","ephemeral","client","rest","post","interactionCallback","id","token","body","type","DeferredChannelMessageWithSource","data","flags","Ephemeral","undefined","auth","fetchReply","reply","messagePayload","create","files","resolveBody","resolveFiles","ChannelMessageWithSource","message","webhook","fetchMessage","editReply","InteractionNotReplied","msg","editMessage","deleteReply","deleteMessage","followUp","Promise","reject","send","deferUpdate","DeferredMessageUpdate","interaction","update","UpdateMessage","showModal","modal","Modal","toJSON","jsonTransformer","awaitModalSubmit","time","InvalidType","_options","max","interactionType","ModalSubmit","resolve","collector","once","interactions","reason","first","InteractionCollectorError","applyToClass","structure","ignore","props","prop","includes","Object","defineProperty","prototype","getOwnPropertyDescriptor","module","exports"],"sources":["J:/Coding/Projekts/Web/JavaScript/sillcode.tech/node_modules/discord.js/src/structures/interfaces/InteractionResponses.js"],"sourcesContent":["'use strict';\n\nconst { isJSONEncodable } = require('@discordjs/builders');\nconst { InteractionResponseType, MessageFlags, Routes, InteractionType } = require('discord-api-types/v10');\nconst { DiscordjsError, ErrorCodes } = require('../../errors');\nconst InteractionCollector = require('../InteractionCollector');\nconst InteractionResponse = require('../InteractionResponse');\nconst MessagePayload = require('../MessagePayload');\n\n/**\n * @typedef {Object} ModalComponentData\n * @property {string} title The title of the modal\n * @property {string} customId The custom id of the modal\n * @property {ActionRow[]} components The components within this modal\n */\n\n/**\n * Interface for classes that support shared interaction response types.\n * @interface\n */\nclass InteractionResponses {\n  /**\n   * Options for deferring the reply to an {@link BaseInteraction}.\n   * @typedef {Object} InteractionDeferReplyOptions\n   * @property {boolean} [ephemeral] Whether the reply should be ephemeral\n   * @property {boolean} [fetchReply] Whether to fetch the reply\n   */\n\n  /**\n   * Options for deferring and updating the reply to a {@link MessageComponentInteraction}.\n   * @typedef {Object} InteractionDeferUpdateOptions\n   * @property {boolean} [fetchReply] Whether to fetch the reply\n   */\n\n  /**\n   * Options for a reply to a {@link BaseInteraction}.\n   * @typedef {BaseMessageOptions} InteractionReplyOptions\n   * @property {boolean} [tts=false] Whether the message should be spoken aloud\n   * @property {boolean} [ephemeral] Whether the reply should be ephemeral\n   * @property {boolean} [fetchReply] Whether to fetch the reply\n   * @property {MessageFlags} [flags] Which flags to set for the message.\n   * <info>Only `MessageFlags.SuppressEmbeds` and `MessageFlags.Ephemeral` can be set.</info>\n   */\n\n  /**\n   * Options for updating the message received from a {@link MessageComponentInteraction}.\n   * @typedef {MessageEditOptions} InteractionUpdateOptions\n   * @property {boolean} [fetchReply] Whether to fetch the reply\n   */\n\n  /**\n   * Defers the reply to this interaction.\n   * @param {InteractionDeferReplyOptions} [options] Options for deferring the reply to this interaction\n   * @returns {Promise<Message|InteractionResponse>}\n   * @example\n   * // Defer the reply to this interaction\n   * interaction.deferReply()\n   *   .then(console.log)\n   *   .catch(console.error)\n   * @example\n   * // Defer to send an ephemeral reply later\n   * interaction.deferReply({ ephemeral: true })\n   *   .then(console.log)\n   *   .catch(console.error);\n   */\n  async deferReply(options = {}) {\n    if (this.deferred || this.replied) throw new DiscordjsError(ErrorCodes.InteractionAlreadyReplied);\n    this.ephemeral = options.ephemeral ?? false;\n    await this.client.rest.post(Routes.interactionCallback(this.id, this.token), {\n      body: {\n        type: InteractionResponseType.DeferredChannelMessageWithSource,\n        data: {\n          flags: options.ephemeral ? MessageFlags.Ephemeral : undefined,\n        },\n      },\n      auth: false,\n    });\n    this.deferred = true;\n\n    return options.fetchReply ? this.fetchReply() : new InteractionResponse(this);\n  }\n\n  /**\n   * Creates a reply to this interaction.\n   * <info>Use the `fetchReply` option to get the bot's reply message.</info>\n   * @param {string|MessagePayload|InteractionReplyOptions} options The options for the reply\n   * @returns {Promise<Message|InteractionResponse>}\n   * @example\n   * // Reply to the interaction and fetch the response\n   * interaction.reply({ content: 'Pong!', fetchReply: true })\n   *   .then((message) => console.log(`Reply sent with content ${message.content}`))\n   *   .catch(console.error);\n   * @example\n   * // Create an ephemeral reply with an embed\n   * const embed = new EmbedBuilder().setDescription('Pong!');\n   *\n   * interaction.reply({ embeds: [embed], ephemeral: true })\n   *   .then(() => console.log('Reply sent.'))\n   *   .catch(console.error);\n   */\n  async reply(options) {\n    if (this.deferred || this.replied) throw new DiscordjsError(ErrorCodes.InteractionAlreadyReplied);\n    this.ephemeral = options.ephemeral ?? false;\n\n    let messagePayload;\n    if (options instanceof MessagePayload) messagePayload = options;\n    else messagePayload = MessagePayload.create(this, options);\n\n    const { body: data, files } = await messagePayload.resolveBody().resolveFiles();\n\n    await this.client.rest.post(Routes.interactionCallback(this.id, this.token), {\n      body: {\n        type: InteractionResponseType.ChannelMessageWithSource,\n        data,\n      },\n      files,\n      auth: false,\n    });\n    this.replied = true;\n\n    return options.fetchReply ? this.fetchReply() : new InteractionResponse(this);\n  }\n\n  /**\n   * Fetches a reply to this interaction.\n   * @see Webhook#fetchMessage\n   * @param {Snowflake|'@original'} [message='@original'] The response to fetch\n   * @returns {Promise<Message>}\n   * @example\n   * // Fetch the initial reply to this interaction\n   * interaction.fetchReply()\n   *   .then(reply => console.log(`Replied with ${reply.content}`))\n   *   .catch(console.error);\n   */\n  fetchReply(message = '@original') {\n    return this.webhook.fetchMessage(message);\n  }\n\n  /**\n   * Options that can be passed into {@link InteractionResponses#editReply}.\n   * @typedef {WebhookEditMessageOptions} InteractionEditReplyOptions\n   * @property {MessageResolvable|'@original'} [message='@original'] The response to edit\n   */\n\n  /**\n   * Edits a reply to this interaction.\n   * @see Webhook#editMessage\n   * @param {string|MessagePayload|InteractionEditReplyOptions} options The new options for the message\n   * @returns {Promise<Message>}\n   * @example\n   * // Edit the initial reply to this interaction\n   * interaction.editReply('New content')\n   *   .then(console.log)\n   *   .catch(console.error);\n   */\n  async editReply(options) {\n    if (!this.deferred && !this.replied) throw new DiscordjsError(ErrorCodes.InteractionNotReplied);\n    const msg = await this.webhook.editMessage(options.message ?? '@original', options);\n    this.replied = true;\n    return msg;\n  }\n\n  /**\n   * Deletes a reply to this interaction.\n   * @see Webhook#deleteMessage\n   * @param {MessageResolvable|'@original'} [message='@original'] The response to delete\n   * @returns {Promise<void>}\n   * @example\n   * // Delete the initial reply to this interaction\n   * interaction.deleteReply()\n   *   .then(console.log)\n   *   .catch(console.error);\n   */\n  async deleteReply(message = '@original') {\n    await this.webhook.deleteMessage(message);\n  }\n\n  /**\n   * Send a follow-up message to this interaction.\n   * @param {string|MessagePayload|InteractionReplyOptions} options The options for the reply\n   * @returns {Promise<Message>}\n   */\n  followUp(options) {\n    if (!this.deferred && !this.replied) return Promise.reject(new DiscordjsError(ErrorCodes.InteractionNotReplied));\n    return this.webhook.send(options);\n  }\n\n  /**\n   * Defers an update to the message to which the component was attached.\n   * @param {InteractionDeferUpdateOptions} [options] Options for deferring the update to this interaction\n   * @returns {Promise<Message|InteractionResponse>}\n   * @example\n   * // Defer updating and reset the component's loading state\n   * interaction.deferUpdate()\n   *   .then(console.log)\n   *   .catch(console.error);\n   */\n  async deferUpdate(options = {}) {\n    if (this.deferred || this.replied) throw new DiscordjsError(ErrorCodes.InteractionAlreadyReplied);\n    await this.client.rest.post(Routes.interactionCallback(this.id, this.token), {\n      body: {\n        type: InteractionResponseType.DeferredMessageUpdate,\n      },\n      auth: false,\n    });\n    this.deferred = true;\n\n    return options.fetchReply ? this.fetchReply() : new InteractionResponse(this, this.message?.interaction?.id);\n  }\n\n  /**\n   * Updates the original message of the component on which the interaction was received on.\n   * @param {string|MessagePayload|InteractionUpdateOptions} options The options for the updated message\n   * @returns {Promise<Message|void>}\n   * @example\n   * // Remove the components from the message\n   * interaction.update({\n   *   content: \"A component interaction was received\",\n   *   components: []\n   * })\n   *   .then(console.log)\n   *   .catch(console.error);\n   */\n  async update(options) {\n    if (this.deferred || this.replied) throw new DiscordjsError(ErrorCodes.InteractionAlreadyReplied);\n\n    let messagePayload;\n    if (options instanceof MessagePayload) messagePayload = options;\n    else messagePayload = MessagePayload.create(this, options);\n\n    const { body: data, files } = await messagePayload.resolveBody().resolveFiles();\n\n    await this.client.rest.post(Routes.interactionCallback(this.id, this.token), {\n      body: {\n        type: InteractionResponseType.UpdateMessage,\n        data,\n      },\n      files,\n      auth: false,\n    });\n    this.replied = true;\n\n    return options.fetchReply ? this.fetchReply() : new InteractionResponse(this, this.message.interaction?.id);\n  }\n\n  /**\n   * Shows a modal component\n   * @param {APIModal|ModalData|Modal} modal The modal to show\n   * @returns {Promise<void>}\n   */\n  async showModal(modal) {\n    if (this.deferred || this.replied) throw new DiscordjsError(ErrorCodes.InteractionAlreadyReplied);\n    await this.client.rest.post(Routes.interactionCallback(this.id, this.token), {\n      body: {\n        type: InteractionResponseType.Modal,\n        data: isJSONEncodable(modal) ? modal.toJSON() : this.client.options.jsonTransformer(modal),\n      },\n    });\n    this.replied = true;\n  }\n\n  /**\n   * An object containing the same properties as {@link CollectorOptions}, but a few less:\n   * @typedef {Object} AwaitModalSubmitOptions\n   * @property {CollectorFilter} [filter] The filter applied to this collector\n   * @property {number} time Time in milliseconds to wait for an interaction before rejecting\n   */\n\n  /**\n   * Collects a single modal submit interaction that passes the filter.\n   * The Promise will reject if the time expires.\n   * @param {AwaitModalSubmitOptions} options Options to pass to the internal collector\n   * @returns {Promise<ModalSubmitInteraction>}\n   * @example\n   * // Collect a modal submit interaction\n   * const filter = (interaction) => interaction.customId === 'modal';\n   * interaction.awaitModalSubmit({ filter, time: 15_000 })\n   *   .then(interaction => console.log(`${interaction.customId} was submitted!`))\n   *   .catch(console.error);\n   */\n  awaitModalSubmit(options) {\n    if (typeof options.time !== 'number') throw new DiscordjsError(ErrorCodes.InvalidType, 'time', 'number');\n    const _options = { ...options, max: 1, interactionType: InteractionType.ModalSubmit };\n    return new Promise((resolve, reject) => {\n      const collector = new InteractionCollector(this.client, _options);\n      collector.once('end', (interactions, reason) => {\n        const interaction = interactions.first();\n        if (interaction) resolve(interaction);\n        else reject(new DiscordjsError(ErrorCodes.InteractionCollectorError, reason));\n      });\n    });\n  }\n\n  static applyToClass(structure, ignore = []) {\n    const props = [\n      'deferReply',\n      'reply',\n      'fetchReply',\n      'editReply',\n      'deleteReply',\n      'followUp',\n      'deferUpdate',\n      'update',\n      'showModal',\n      'awaitModalSubmit',\n    ];\n\n    for (const prop of props) {\n      if (ignore.includes(prop)) continue;\n      Object.defineProperty(\n        structure.prototype,\n        prop,\n        Object.getOwnPropertyDescriptor(InteractionResponses.prototype, prop),\n      );\n    }\n  }\n}\n\nmodule.exports = InteractionResponses;\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}