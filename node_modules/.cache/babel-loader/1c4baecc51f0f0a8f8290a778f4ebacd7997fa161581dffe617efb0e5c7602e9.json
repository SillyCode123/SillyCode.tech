{"ast":null,"code":"'use strict';\n\nconst {\n  setTimeout,\n  clearTimeout\n} = require('node:timers');\nconst {\n  Collection\n} = require('@discordjs/collection');\nconst {\n  makeURLSearchParams\n} = require('@discordjs/rest');\nconst {\n  DiscordSnowflake\n} = require('@sapphire/snowflake');\nconst {\n  Routes,\n  GatewayOpcodes\n} = require('discord-api-types/v10');\nconst CachedManager = require('./CachedManager');\nconst {\n  DiscordjsError,\n  DiscordjsTypeError,\n  DiscordjsRangeError,\n  ErrorCodes\n} = require('../errors');\nconst BaseGuildVoiceChannel = require('../structures/BaseGuildVoiceChannel');\nconst {\n  GuildMember\n} = require('../structures/GuildMember');\nconst {\n  Role\n} = require('../structures/Role');\nconst Events = require('../util/Events');\nconst Partials = require('../util/Partials');\n\n/**\n * Manages API methods for GuildMembers and stores their cache.\n * @extends {CachedManager}\n */\nclass GuildMemberManager extends CachedManager {\n  constructor(guild, iterable) {\n    super(guild.client, GuildMember, iterable);\n\n    /**\n     * The guild this manager belongs to\n     * @type {Guild}\n     */\n    this.guild = guild;\n  }\n\n  /**\n   * The cache of this Manager\n   * @type {Collection<Snowflake, GuildMember>}\n   * @name GuildMemberManager#cache\n   */\n\n  _add(data) {\n    let cache = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\n    return super._add(data, cache, {\n      id: data.user.id,\n      extras: [this.guild]\n    });\n  }\n\n  /**\n   * Data that resolves to give a GuildMember object. This can be:\n   * * A GuildMember object\n   * * A User resolvable\n   * @typedef {GuildMember|UserResolvable} GuildMemberResolvable\n   */\n\n  /**\n   * Resolves a {@link GuildMemberResolvable} to a {@link GuildMember} object.\n   * @param {GuildMemberResolvable} member The user that is part of the guild\n   * @returns {?GuildMember}\n   */\n  resolve(member) {\n    const memberResolvable = super.resolve(member);\n    if (memberResolvable) return memberResolvable;\n    const userResolvable = this.client.users.resolveId(member);\n    if (userResolvable) return super.resolve(userResolvable);\n    return null;\n  }\n\n  /**\n   * Resolves a {@link GuildMemberResolvable} to a member id.\n   * @param {GuildMemberResolvable} member The user that is part of the guild\n   * @returns {?Snowflake}\n   */\n  resolveId(member) {\n    const memberResolvable = super.resolveId(member);\n    if (memberResolvable) return memberResolvable;\n    const userResolvable = this.client.users.resolveId(member);\n    return this.cache.has(userResolvable) ? userResolvable : null;\n  }\n\n  /**\n   * Options used to add a user to a guild using OAuth2.\n   * @typedef {Object} AddGuildMemberOptions\n   * @property {string} accessToken An OAuth2 access token for the user with the {@link OAuth2Scopes.GuildsJoin}\n   * scope granted to the bot's application\n   * @property {string} [nick] The nickname to give to the member\n   * <info>This property requires the {@link PermissionFlagsBits.ManageNicknames} permission.</info>\n   * @property {Collection<Snowflake, Role>|RoleResolvable[]} [roles] The roles to add to the member\n   * <info>This property requires the {@link PermissionFlagsBits.ManageRoles} permission.</info>\n   * @property {boolean} [mute] Whether the member should be muted\n   * <info>This property requires the {@link PermissionFlagsBits.MuteMembers} permission.</info>\n   * @property {boolean} [deaf] Whether the member should be deafened\n   * <info>This property requires the {@link PermissionFlagsBits.MuteMembers} permission.</info>\n   * @property {boolean} [force] Whether to skip the cache check and request the API directly\n   * @property {boolean} [fetchWhenExisting=true] Whether to fetch the user if not cached and already a member\n   */\n\n  /**\n   * Adds a user to the guild using OAuth2.\n   * <info>This method requires the {@link PermissionFlagsBits.CreateInstantInvite} permission.\n   * @param {UserResolvable} user The user to add to the guild\n   * @param {AddGuildMemberOptions} options Options for adding the user to the guild\n   * @returns {Promise<GuildMember|null>}\n   */\n  async add(user, options) {\n    const userId = this.client.users.resolveId(user);\n    if (!userId) throw new DiscordjsTypeError(ErrorCodes.InvalidType, 'user', 'UserResolvable');\n    if (!options.force) {\n      const cachedUser = this.cache.get(userId);\n      if (cachedUser) return cachedUser;\n    }\n    const resolvedOptions = {\n      access_token: options.accessToken,\n      nick: options.nick,\n      mute: options.mute,\n      deaf: options.deaf\n    };\n    if (options.roles) {\n      if (!Array.isArray(options.roles) && !(options.roles instanceof Collection)) {\n        throw new DiscordjsTypeError(ErrorCodes.InvalidType, 'options.roles', 'Array or Collection of Roles or Snowflakes', true);\n      }\n      const resolvedRoles = [];\n      for (const role of options.roles.values()) {\n        const resolvedRole = this.guild.roles.resolveId(role);\n        if (!resolvedRole) {\n          throw new DiscordjsTypeError(ErrorCodes.InvalidElement, 'Array or Collection', 'options.roles', role);\n        }\n        resolvedRoles.push(resolvedRole);\n      }\n      resolvedOptions.roles = resolvedRoles;\n    }\n    const data = await this.client.rest.put(Routes.guildMember(this.guild.id, userId), {\n      body: resolvedOptions\n    });\n    // Data is an empty Uint8Array if the member is already part of the guild.\n    return data instanceof Uint8Array ? options.fetchWhenExisting === false ? null : this.fetch(userId) : this._add(data);\n  }\n\n  /**\n   * The client user as a GuildMember of this guild\n   * @type {?GuildMember}\n   * @readonly\n   */\n  get me() {\n    return this.resolve(this.client.user.id) ?? (this.client.options.partials.includes(Partials.GuildMember) ? this._add({\n      user: {\n        id: this.client.user.id\n      }\n    }, true) : null);\n  }\n\n  /**\n   * Options used to fetch a single member from a guild.\n   * @typedef {BaseFetchOptions} FetchMemberOptions\n   * @property {UserResolvable} user The user to fetch\n   */\n\n  /**\n   * Options used to fetch multiple members from a guild.\n   * @typedef {Object} FetchMembersOptions\n   * @property {UserResolvable|UserResolvable[]} user The user(s) to fetch\n   * @property {?string} query Limit fetch to members with similar usernames\n   * @property {number} [limit=0] Maximum number of members to request\n   * @property {boolean} [withPresences=false] Whether or not to include the presences\n   * @property {number} [time=120e3] Timeout for receipt of members\n   * @property {?string} nonce Nonce for this request (32 characters max - default to base 16 now timestamp)\n   * @property {boolean} [force=false] Whether to skip the cache check and request the API\n   */\n\n  /**\n   * Fetches member(s) from Discord, even if they're offline.\n   * @param {UserResolvable|FetchMemberOptions|FetchMembersOptions} [options] If a UserResolvable, the user to fetch.\n   * If undefined, fetches all members.\n   * If a query, it limits the results to users with similar usernames.\n   * @returns {Promise<GuildMember|Collection<Snowflake, GuildMember>>}\n   * @example\n   * // Fetch all members from a guild\n   * guild.members.fetch()\n   *   .then(console.log)\n   *   .catch(console.error);\n   * @example\n   * // Fetch a single member\n   * guild.members.fetch('66564597481480192')\n   *   .then(console.log)\n   *   .catch(console.error);\n   * @example\n   * // Fetch a single member without checking cache\n   * guild.members.fetch({ user, force: true })\n   *   .then(console.log)\n   *   .catch(console.error)\n   * @example\n   * // Fetch a single member without caching\n   * guild.members.fetch({ user, cache: false })\n   *   .then(console.log)\n   *   .catch(console.error);\n   * @example\n   * // Fetch by an array of users including their presences\n   * guild.members.fetch({ user: ['66564597481480192', '191615925336670208'], withPresences: true })\n   *   .then(console.log)\n   *   .catch(console.error);\n   * @example\n   * // Fetch by query\n   * guild.members.fetch({ query: 'hydra', limit: 1 })\n   *   .then(console.log)\n   *   .catch(console.error);\n   */\n  fetch(options) {\n    if (!options) return this._fetchMany();\n    const user = this.client.users.resolveId(options);\n    if (user) return this._fetchSingle({\n      user,\n      cache: true\n    });\n    if (options.user) {\n      if (Array.isArray(options.user)) {\n        options.user = options.user.map(u => this.client.users.resolveId(u));\n        return this._fetchMany(options);\n      } else {\n        options.user = this.client.users.resolveId(options.user);\n      }\n      if (!options.limit && !options.withPresences) return this._fetchSingle(options);\n    }\n    return this._fetchMany(options);\n  }\n\n  /**\n   * Fetches the client user as a GuildMember of the guild.\n   * @param {BaseFetchOptions} [options] The options for fetching the member\n   * @returns {Promise<GuildMember>}\n   */\n  fetchMe(options) {\n    return this.fetch({\n      ...options,\n      user: this.client.user.id\n    });\n  }\n\n  /**\n   * Options used for searching guild members.\n   * @typedef {Object} GuildSearchMembersOptions\n   * @property {string} query Filter members whose username or nickname start with this query\n   * @property {number} [limit] Maximum number of members to search\n   * @property {boolean} [cache=true] Whether or not to cache the fetched member(s)\n   */\n\n  /**\n   * Searches for members in the guild based on a query.\n   * @param {GuildSearchMembersOptions} options Options for searching members\n   * @returns {Promise<Collection<Snowflake, GuildMember>>}\n   */\n  async search() {\n    let {\n      query,\n      limit,\n      cache = true\n    } = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    const data = await this.client.rest.get(Routes.guildMembersSearch(this.guild.id), {\n      query: makeURLSearchParams({\n        query,\n        limit\n      })\n    });\n    return data.reduce((col, member) => col.set(member.user.id, this._add(member, cache)), new Collection());\n  }\n\n  /**\n   * Options used for listing guild members.\n   * @typedef {Object} GuildListMembersOptions\n   * @property {Snowflake} [after] Limit fetching members to those with an id greater than the supplied id\n   * @property {number} [limit] Maximum number of members to list\n   * @property {boolean} [cache=true] Whether or not to cache the fetched member(s)\n   */\n\n  /**\n   * Lists up to 1000 members of the guild.\n   * @param {GuildListMembersOptions} [options] Options for listing members\n   * @returns {Promise<Collection<Snowflake, GuildMember>>}\n   */\n  async list() {\n    let {\n      after,\n      limit,\n      cache = true\n    } = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    const query = makeURLSearchParams({\n      limit,\n      after\n    });\n    const data = await this.client.rest.get(Routes.guildMembers(this.guild.id), {\n      query\n    });\n    return data.reduce((col, member) => col.set(member.user.id, this._add(member, cache)), new Collection());\n  }\n\n  /**\n   * The data for editing a guild member.\n   * @typedef {Object} GuildMemberEditData\n   * @property {?string} [nick] The nickname to set for the member\n   * @property {Collection<Snowflake, Role>|RoleResolvable[]} [roles] The roles or role ids to apply\n   * @property {boolean} [mute] Whether or not the member should be muted\n   * @property {boolean} [deaf] Whether or not the member should be deafened\n   * @property {GuildVoiceChannelResolvable|null} [channel] Channel to move the member to\n   * (if they are connected to voice), or `null` if you want to disconnect them from voice\n   * @property {DateResolvable|null} [communicationDisabledUntil] The date or timestamp\n   * for the member's communication to be disabled until. Provide `null` to enable communication again.\n   * @property {string} [reason] Reason for editing this user\n   */\n\n  /**\n   * Edits a member of the guild.\n   * <info>The user must be a member of the guild</info>\n   * @param {UserResolvable} user The member to edit\n   * @param {GuildMemberEditData} data The data to edit the member with\n   * @returns {Promise<GuildMember>}\n   */\n  async edit(user, _ref) {\n    let {\n      reason,\n      ...data\n    } = _ref;\n    const id = this.client.users.resolveId(user);\n    if (!id) throw new DiscordjsTypeError(ErrorCodes.InvalidType, 'user', 'UserResolvable');\n    if (data.channel) {\n      data.channel = this.guild.channels.resolve(data.channel);\n      if (!(data.channel instanceof BaseGuildVoiceChannel)) {\n        throw new DiscordjsError(ErrorCodes.GuildVoiceChannelResolve);\n      }\n      data.channel_id = data.channel.id;\n      data.channel = undefined;\n    } else if (data.channel === null) {\n      data.channel_id = null;\n      data.channel = undefined;\n    }\n    data.roles &&= data.roles.map(role => role instanceof Role ? role.id : role);\n    if (typeof data.communicationDisabledUntil !== 'undefined') {\n      data.communication_disabled_until =\n      // eslint-disable-next-line eqeqeq\n      data.communicationDisabledUntil != null ? new Date(data.communicationDisabledUntil).toISOString() : data.communicationDisabledUntil;\n    }\n    let endpoint;\n    if (id === this.client.user.id) {\n      const keys = Object.keys(data);\n      if (keys.length === 1 && keys[0] === 'nick') endpoint = Routes.guildMember(this.guild.id);else endpoint = Routes.guildMember(this.guild.id, id);\n    } else {\n      endpoint = Routes.guildMember(this.guild.id, id);\n    }\n    const d = await this.client.rest.patch(endpoint, {\n      body: data,\n      reason\n    });\n    const clone = this.cache.get(id)?._clone();\n    clone?._patch(d);\n    return clone ?? this._add(d, false);\n  }\n\n  /**\n   * Options used for pruning guild members.\n   * <info>It's recommended to set {@link GuildPruneMembersOptions#count options.count}\n   * to `false` for large guilds.</info>\n   * @typedef {Object} GuildPruneMembersOptions\n   * @property {number} [days] Number of days of inactivity required to kick\n   * @property {boolean} [dry=false] Get the number of users that will be kicked, without actually kicking them\n   * @property {boolean} [count] Whether or not to return the number of users that have been kicked.\n   * @property {RoleResolvable[]} [roles] Array of roles to bypass the \"...and no roles\" constraint when pruning\n   * @property {string} [reason] Reason for this prune\n   */\n\n  /**\n   * Prunes members from the guild based on how long they have been inactive.\n   * @param {GuildPruneMembersOptions} [options] Options for pruning\n   * @returns {Promise<number|null>} The number of members that were/will be kicked\n   * @example\n   * // See how many members will be pruned\n   * guild.members.prune({ dry: true })\n   *   .then(pruned => console.log(`This will prune ${pruned} people!`))\n   *   .catch(console.error);\n   * @example\n   * // Actually prune the members\n   * guild.members.prune({ days: 1, reason: 'too many people!' })\n   *   .then(pruned => console.log(`I just pruned ${pruned} people!`))\n   *   .catch(console.error);\n   * @example\n   * // Include members with a specified role\n   * guild.members.prune({ days: 7, roles: ['657259391652855808'] })\n   *    .then(pruned => console.log(`I just pruned ${pruned} people!`))\n   *    .catch(console.error);\n   */\n  async prune() {\n    let {\n      days,\n      dry = false,\n      count: compute_prune_count,\n      roles = [],\n      reason\n    } = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    if (typeof days !== 'number') throw new DiscordjsTypeError(ErrorCodes.PruneDaysType);\n    const query = {\n      days\n    };\n    const resolvedRoles = [];\n    for (const role of roles) {\n      const resolvedRole = this.guild.roles.resolveId(role);\n      if (!resolvedRole) {\n        throw new DiscordjsTypeError(ErrorCodes.InvalidElement, 'Array', 'options.roles', role);\n      }\n      resolvedRoles.push(resolvedRole);\n    }\n    if (resolvedRoles.length) {\n      query.include_roles = dry ? resolvedRoles.join(',') : resolvedRoles;\n    }\n    const endpoint = Routes.guildPrune(this.guild.id);\n    const {\n      pruned\n    } = await (dry ? this.client.rest.get(endpoint, {\n      query: makeURLSearchParams(query),\n      reason\n    }) : this.client.rest.post(endpoint, {\n      body: {\n        ...query,\n        compute_prune_count\n      },\n      reason\n    }));\n    return pruned;\n  }\n\n  /**\n   * Kicks a user from the guild.\n   * <info>The user must be a member of the guild</info>\n   * @param {UserResolvable} user The member to kick\n   * @param {string} [reason] Reason for kicking\n   * @returns {Promise<GuildMember|User|Snowflake>} Result object will be resolved as specifically as possible.\n   * If the GuildMember cannot be resolved, the User will instead be attempted to be resolved. If that also cannot\n   * be resolved, the user's id will be the result.\n   * @example\n   * // Kick a user by id (or with a user/guild member object)\n   * guild.members.kick('84484653687267328')\n   *   .then(kickInfo => console.log(`Kicked ${kickInfo.user?.tag ?? kickInfo.tag ?? kickInfo}`))\n   *   .catch(console.error);\n   */\n  async kick(user, reason) {\n    const id = this.client.users.resolveId(user);\n    if (!id) return Promise.reject(new DiscordjsTypeError(ErrorCodes.InvalidType, 'user', 'UserResolvable'));\n    await this.client.rest.delete(Routes.guildMember(this.guild.id, id), {\n      reason\n    });\n    return this.resolve(user) ?? this.client.users.resolve(user) ?? id;\n  }\n\n  /**\n   * Bans a user from the guild.\n   * @param {UserResolvable} user The user to ban\n   * @param {BanOptions} [options] Options for the ban\n   * @returns {Promise<GuildMember|User|Snowflake>} Result object will be resolved as specifically as possible.\n   * If the GuildMember cannot be resolved, the User will instead be attempted to be resolved. If that also cannot\n   * be resolved, the user id will be the result.\n   * Internally calls the GuildBanManager#create method.\n   * @example\n   * // Ban a user by id (or with a user/guild member object)\n   * guild.members.ban('84484653687267328')\n   *   .then(banInfo => console.log(`Banned ${banInfo.user?.tag ?? banInfo.tag ?? banInfo}`))\n   *   .catch(console.error);\n   */\n  ban(user, options) {\n    return this.guild.bans.create(user, options);\n  }\n\n  /**\n   * Unbans a user from the guild. Internally calls the {@link GuildBanManager#remove} method.\n   * @param {UserResolvable} user The user to unban\n   * @param {string} [reason] Reason for unbanning user\n   * @returns {Promise<?User>} The user that was unbanned\n   * @example\n   * // Unban a user by id (or with a user/guild member object)\n   * guild.members.unban('84484653687267328')\n   *   .then(user => console.log(`Unbanned ${user.username} from ${guild.name}`))\n   *   .catch(console.error);\n   */\n  unban(user, reason) {\n    return this.guild.bans.remove(user, reason);\n  }\n\n  /**\n   * Options used for adding or removing a role from a member.\n   * @typedef {Object} AddOrRemoveGuildMemberRoleOptions\n   * @property {GuildMemberResolvable} user The user to add/remove the role from\n   * @property {RoleResolvable} role The role to add/remove\n   * @property {string} [reason] Reason for adding/removing the role\n   */\n\n  /**\n   * Adds a role to a member.\n   * @param {AddOrRemoveGuildMemberRoleOptions} options Options for adding the role\n   * @returns {Promise<GuildMember|User|Snowflake>}\n   */\n  async addRole(options) {\n    const {\n      user,\n      role,\n      reason\n    } = options;\n    const userId = this.guild.members.resolveId(user);\n    const roleId = this.guild.roles.resolveId(role);\n    await this.client.rest.put(Routes.guildMemberRole(this.guild.id, userId, roleId), {\n      reason\n    });\n    return this.resolve(user) ?? this.client.users.resolve(user) ?? userId;\n  }\n\n  /**\n   * Removes a role from a member.\n   * @param {AddOrRemoveGuildMemberRoleOptions} options Options for removing the role\n   * @returns {Promise<GuildMember|User|Snowflake>}\n   */\n  async removeRole(options) {\n    const {\n      user,\n      role,\n      reason\n    } = options;\n    const userId = this.guild.members.resolveId(user);\n    const roleId = this.guild.roles.resolveId(role);\n    await this.client.rest.delete(Routes.guildMemberRole(this.guild.id, userId, roleId), {\n      reason\n    });\n    return this.resolve(user) ?? this.client.users.resolve(user) ?? userId;\n  }\n  async _fetchSingle(_ref2) {\n    let {\n      user,\n      cache,\n      force = false\n    } = _ref2;\n    if (!force) {\n      const existing = this.cache.get(user);\n      if (existing && !existing.partial) return existing;\n    }\n    const data = await this.client.rest.get(Routes.guildMember(this.guild.id, user));\n    return this._add(data, cache);\n  }\n  _fetchMany() {\n    let {\n      limit = 0,\n      withPresences: presences = false,\n      user: user_ids,\n      query,\n      time = 120e3,\n      nonce = DiscordSnowflake.generate().toString()\n    } = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    return new Promise((resolve, reject) => {\n      if (!query && !user_ids) query = '';\n      if (nonce.length > 32) throw new DiscordjsRangeError(ErrorCodes.MemberFetchNonceLength);\n      this.guild.shard.send({\n        op: GatewayOpcodes.RequestGuildMembers,\n        d: {\n          guild_id: this.guild.id,\n          presences,\n          user_ids,\n          query,\n          nonce,\n          limit\n        }\n      });\n      const fetchedMembers = new Collection();\n      let i = 0;\n      const handler = (members, _, chunk) => {\n        timeout.refresh();\n        if (chunk.nonce !== nonce) return;\n        i++;\n        for (const member of members.values()) {\n          fetchedMembers.set(member.id, member);\n        }\n        if (members.size < 1_000 || limit && fetchedMembers.size >= limit || i === chunk.count) {\n          clearTimeout(timeout);\n          this.client.removeListener(Events.GuildMembersChunk, handler);\n          this.client.decrementMaxListeners();\n          let fetched = fetchedMembers;\n          if (user_ids && !Array.isArray(user_ids) && fetched.size) fetched = fetched.first();\n          resolve(fetched);\n        }\n      };\n      const timeout = setTimeout(() => {\n        this.client.removeListener(Events.GuildMembersChunk, handler);\n        this.client.decrementMaxListeners();\n        reject(new DiscordjsError(ErrorCodes.GuildMembersTimeout));\n      }, time).unref();\n      this.client.incrementMaxListeners();\n      this.client.on(Events.GuildMembersChunk, handler);\n    });\n  }\n}\nmodule.exports = GuildMemberManager;","map":{"version":3,"names":["setTimeout","clearTimeout","require","Collection","makeURLSearchParams","DiscordSnowflake","Routes","GatewayOpcodes","CachedManager","DiscordjsError","DiscordjsTypeError","DiscordjsRangeError","ErrorCodes","BaseGuildVoiceChannel","GuildMember","Role","Events","Partials","GuildMemberManager","constructor","guild","iterable","client","_add","data","cache","id","user","extras","resolve","member","memberResolvable","userResolvable","users","resolveId","has","add","options","userId","InvalidType","force","cachedUser","get","resolvedOptions","access_token","accessToken","nick","mute","deaf","roles","Array","isArray","resolvedRoles","role","values","resolvedRole","InvalidElement","push","rest","put","guildMember","body","Uint8Array","fetchWhenExisting","fetch","me","partials","includes","_fetchMany","_fetchSingle","map","u","limit","withPresences","fetchMe","search","query","guildMembersSearch","reduce","col","set","list","after","guildMembers","edit","reason","channel","channels","GuildVoiceChannelResolve","channel_id","undefined","communicationDisabledUntil","communication_disabled_until","Date","toISOString","endpoint","keys","Object","length","d","patch","clone","_clone","_patch","prune","days","dry","count","compute_prune_count","PruneDaysType","include_roles","join","guildPrune","pruned","post","kick","Promise","reject","delete","ban","bans","create","unban","remove","addRole","members","roleId","guildMemberRole","removeRole","existing","partial","presences","user_ids","time","nonce","generate","toString","MemberFetchNonceLength","shard","send","op","RequestGuildMembers","guild_id","fetchedMembers","i","handler","_","chunk","timeout","refresh","size","removeListener","GuildMembersChunk","decrementMaxListeners","fetched","first","GuildMembersTimeout","unref","incrementMaxListeners","on","module","exports"],"sources":["J:/Coding/Projekts/Web/JavaScript/sillcode.tech/node_modules/discord.js/src/managers/GuildMemberManager.js"],"sourcesContent":["'use strict';\n\nconst { setTimeout, clearTimeout } = require('node:timers');\nconst { Collection } = require('@discordjs/collection');\nconst { makeURLSearchParams } = require('@discordjs/rest');\nconst { DiscordSnowflake } = require('@sapphire/snowflake');\nconst { Routes, GatewayOpcodes } = require('discord-api-types/v10');\nconst CachedManager = require('./CachedManager');\nconst { DiscordjsError, DiscordjsTypeError, DiscordjsRangeError, ErrorCodes } = require('../errors');\nconst BaseGuildVoiceChannel = require('../structures/BaseGuildVoiceChannel');\nconst { GuildMember } = require('../structures/GuildMember');\nconst { Role } = require('../structures/Role');\nconst Events = require('../util/Events');\nconst Partials = require('../util/Partials');\n\n/**\n * Manages API methods for GuildMembers and stores their cache.\n * @extends {CachedManager}\n */\nclass GuildMemberManager extends CachedManager {\n  constructor(guild, iterable) {\n    super(guild.client, GuildMember, iterable);\n\n    /**\n     * The guild this manager belongs to\n     * @type {Guild}\n     */\n    this.guild = guild;\n  }\n\n  /**\n   * The cache of this Manager\n   * @type {Collection<Snowflake, GuildMember>}\n   * @name GuildMemberManager#cache\n   */\n\n  _add(data, cache = true) {\n    return super._add(data, cache, { id: data.user.id, extras: [this.guild] });\n  }\n\n  /**\n   * Data that resolves to give a GuildMember object. This can be:\n   * * A GuildMember object\n   * * A User resolvable\n   * @typedef {GuildMember|UserResolvable} GuildMemberResolvable\n   */\n\n  /**\n   * Resolves a {@link GuildMemberResolvable} to a {@link GuildMember} object.\n   * @param {GuildMemberResolvable} member The user that is part of the guild\n   * @returns {?GuildMember}\n   */\n  resolve(member) {\n    const memberResolvable = super.resolve(member);\n    if (memberResolvable) return memberResolvable;\n    const userResolvable = this.client.users.resolveId(member);\n    if (userResolvable) return super.resolve(userResolvable);\n    return null;\n  }\n\n  /**\n   * Resolves a {@link GuildMemberResolvable} to a member id.\n   * @param {GuildMemberResolvable} member The user that is part of the guild\n   * @returns {?Snowflake}\n   */\n  resolveId(member) {\n    const memberResolvable = super.resolveId(member);\n    if (memberResolvable) return memberResolvable;\n    const userResolvable = this.client.users.resolveId(member);\n    return this.cache.has(userResolvable) ? userResolvable : null;\n  }\n\n  /**\n   * Options used to add a user to a guild using OAuth2.\n   * @typedef {Object} AddGuildMemberOptions\n   * @property {string} accessToken An OAuth2 access token for the user with the {@link OAuth2Scopes.GuildsJoin}\n   * scope granted to the bot's application\n   * @property {string} [nick] The nickname to give to the member\n   * <info>This property requires the {@link PermissionFlagsBits.ManageNicknames} permission.</info>\n   * @property {Collection<Snowflake, Role>|RoleResolvable[]} [roles] The roles to add to the member\n   * <info>This property requires the {@link PermissionFlagsBits.ManageRoles} permission.</info>\n   * @property {boolean} [mute] Whether the member should be muted\n   * <info>This property requires the {@link PermissionFlagsBits.MuteMembers} permission.</info>\n   * @property {boolean} [deaf] Whether the member should be deafened\n   * <info>This property requires the {@link PermissionFlagsBits.MuteMembers} permission.</info>\n   * @property {boolean} [force] Whether to skip the cache check and request the API directly\n   * @property {boolean} [fetchWhenExisting=true] Whether to fetch the user if not cached and already a member\n   */\n\n  /**\n   * Adds a user to the guild using OAuth2.\n   * <info>This method requires the {@link PermissionFlagsBits.CreateInstantInvite} permission.\n   * @param {UserResolvable} user The user to add to the guild\n   * @param {AddGuildMemberOptions} options Options for adding the user to the guild\n   * @returns {Promise<GuildMember|null>}\n   */\n  async add(user, options) {\n    const userId = this.client.users.resolveId(user);\n    if (!userId) throw new DiscordjsTypeError(ErrorCodes.InvalidType, 'user', 'UserResolvable');\n    if (!options.force) {\n      const cachedUser = this.cache.get(userId);\n      if (cachedUser) return cachedUser;\n    }\n    const resolvedOptions = {\n      access_token: options.accessToken,\n      nick: options.nick,\n      mute: options.mute,\n      deaf: options.deaf,\n    };\n    if (options.roles) {\n      if (!Array.isArray(options.roles) && !(options.roles instanceof Collection)) {\n        throw new DiscordjsTypeError(\n          ErrorCodes.InvalidType,\n          'options.roles',\n          'Array or Collection of Roles or Snowflakes',\n          true,\n        );\n      }\n      const resolvedRoles = [];\n      for (const role of options.roles.values()) {\n        const resolvedRole = this.guild.roles.resolveId(role);\n        if (!resolvedRole) {\n          throw new DiscordjsTypeError(ErrorCodes.InvalidElement, 'Array or Collection', 'options.roles', role);\n        }\n        resolvedRoles.push(resolvedRole);\n      }\n      resolvedOptions.roles = resolvedRoles;\n    }\n    const data = await this.client.rest.put(Routes.guildMember(this.guild.id, userId), { body: resolvedOptions });\n    // Data is an empty Uint8Array if the member is already part of the guild.\n    return data instanceof Uint8Array\n      ? options.fetchWhenExisting === false\n        ? null\n        : this.fetch(userId)\n      : this._add(data);\n  }\n\n  /**\n   * The client user as a GuildMember of this guild\n   * @type {?GuildMember}\n   * @readonly\n   */\n  get me() {\n    return (\n      this.resolve(this.client.user.id) ??\n      (this.client.options.partials.includes(Partials.GuildMember)\n        ? this._add({ user: { id: this.client.user.id } }, true)\n        : null)\n    );\n  }\n\n  /**\n   * Options used to fetch a single member from a guild.\n   * @typedef {BaseFetchOptions} FetchMemberOptions\n   * @property {UserResolvable} user The user to fetch\n   */\n\n  /**\n   * Options used to fetch multiple members from a guild.\n   * @typedef {Object} FetchMembersOptions\n   * @property {UserResolvable|UserResolvable[]} user The user(s) to fetch\n   * @property {?string} query Limit fetch to members with similar usernames\n   * @property {number} [limit=0] Maximum number of members to request\n   * @property {boolean} [withPresences=false] Whether or not to include the presences\n   * @property {number} [time=120e3] Timeout for receipt of members\n   * @property {?string} nonce Nonce for this request (32 characters max - default to base 16 now timestamp)\n   * @property {boolean} [force=false] Whether to skip the cache check and request the API\n   */\n\n  /**\n   * Fetches member(s) from Discord, even if they're offline.\n   * @param {UserResolvable|FetchMemberOptions|FetchMembersOptions} [options] If a UserResolvable, the user to fetch.\n   * If undefined, fetches all members.\n   * If a query, it limits the results to users with similar usernames.\n   * @returns {Promise<GuildMember|Collection<Snowflake, GuildMember>>}\n   * @example\n   * // Fetch all members from a guild\n   * guild.members.fetch()\n   *   .then(console.log)\n   *   .catch(console.error);\n   * @example\n   * // Fetch a single member\n   * guild.members.fetch('66564597481480192')\n   *   .then(console.log)\n   *   .catch(console.error);\n   * @example\n   * // Fetch a single member without checking cache\n   * guild.members.fetch({ user, force: true })\n   *   .then(console.log)\n   *   .catch(console.error)\n   * @example\n   * // Fetch a single member without caching\n   * guild.members.fetch({ user, cache: false })\n   *   .then(console.log)\n   *   .catch(console.error);\n   * @example\n   * // Fetch by an array of users including their presences\n   * guild.members.fetch({ user: ['66564597481480192', '191615925336670208'], withPresences: true })\n   *   .then(console.log)\n   *   .catch(console.error);\n   * @example\n   * // Fetch by query\n   * guild.members.fetch({ query: 'hydra', limit: 1 })\n   *   .then(console.log)\n   *   .catch(console.error);\n   */\n  fetch(options) {\n    if (!options) return this._fetchMany();\n    const user = this.client.users.resolveId(options);\n    if (user) return this._fetchSingle({ user, cache: true });\n    if (options.user) {\n      if (Array.isArray(options.user)) {\n        options.user = options.user.map(u => this.client.users.resolveId(u));\n        return this._fetchMany(options);\n      } else {\n        options.user = this.client.users.resolveId(options.user);\n      }\n      if (!options.limit && !options.withPresences) return this._fetchSingle(options);\n    }\n    return this._fetchMany(options);\n  }\n\n  /**\n   * Fetches the client user as a GuildMember of the guild.\n   * @param {BaseFetchOptions} [options] The options for fetching the member\n   * @returns {Promise<GuildMember>}\n   */\n  fetchMe(options) {\n    return this.fetch({ ...options, user: this.client.user.id });\n  }\n\n  /**\n   * Options used for searching guild members.\n   * @typedef {Object} GuildSearchMembersOptions\n   * @property {string} query Filter members whose username or nickname start with this query\n   * @property {number} [limit] Maximum number of members to search\n   * @property {boolean} [cache=true] Whether or not to cache the fetched member(s)\n   */\n\n  /**\n   * Searches for members in the guild based on a query.\n   * @param {GuildSearchMembersOptions} options Options for searching members\n   * @returns {Promise<Collection<Snowflake, GuildMember>>}\n   */\n  async search({ query, limit, cache = true } = {}) {\n    const data = await this.client.rest.get(Routes.guildMembersSearch(this.guild.id), {\n      query: makeURLSearchParams({ query, limit }),\n    });\n    return data.reduce((col, member) => col.set(member.user.id, this._add(member, cache)), new Collection());\n  }\n\n  /**\n   * Options used for listing guild members.\n   * @typedef {Object} GuildListMembersOptions\n   * @property {Snowflake} [after] Limit fetching members to those with an id greater than the supplied id\n   * @property {number} [limit] Maximum number of members to list\n   * @property {boolean} [cache=true] Whether or not to cache the fetched member(s)\n   */\n\n  /**\n   * Lists up to 1000 members of the guild.\n   * @param {GuildListMembersOptions} [options] Options for listing members\n   * @returns {Promise<Collection<Snowflake, GuildMember>>}\n   */\n  async list({ after, limit, cache = true } = {}) {\n    const query = makeURLSearchParams({ limit, after });\n    const data = await this.client.rest.get(Routes.guildMembers(this.guild.id), { query });\n    return data.reduce((col, member) => col.set(member.user.id, this._add(member, cache)), new Collection());\n  }\n\n  /**\n   * The data for editing a guild member.\n   * @typedef {Object} GuildMemberEditData\n   * @property {?string} [nick] The nickname to set for the member\n   * @property {Collection<Snowflake, Role>|RoleResolvable[]} [roles] The roles or role ids to apply\n   * @property {boolean} [mute] Whether or not the member should be muted\n   * @property {boolean} [deaf] Whether or not the member should be deafened\n   * @property {GuildVoiceChannelResolvable|null} [channel] Channel to move the member to\n   * (if they are connected to voice), or `null` if you want to disconnect them from voice\n   * @property {DateResolvable|null} [communicationDisabledUntil] The date or timestamp\n   * for the member's communication to be disabled until. Provide `null` to enable communication again.\n   * @property {string} [reason] Reason for editing this user\n   */\n\n  /**\n   * Edits a member of the guild.\n   * <info>The user must be a member of the guild</info>\n   * @param {UserResolvable} user The member to edit\n   * @param {GuildMemberEditData} data The data to edit the member with\n   * @returns {Promise<GuildMember>}\n   */\n  async edit(user, { reason, ...data }) {\n    const id = this.client.users.resolveId(user);\n    if (!id) throw new DiscordjsTypeError(ErrorCodes.InvalidType, 'user', 'UserResolvable');\n\n    if (data.channel) {\n      data.channel = this.guild.channels.resolve(data.channel);\n      if (!(data.channel instanceof BaseGuildVoiceChannel)) {\n        throw new DiscordjsError(ErrorCodes.GuildVoiceChannelResolve);\n      }\n      data.channel_id = data.channel.id;\n      data.channel = undefined;\n    } else if (data.channel === null) {\n      data.channel_id = null;\n      data.channel = undefined;\n    }\n    data.roles &&= data.roles.map(role => (role instanceof Role ? role.id : role));\n\n    if (typeof data.communicationDisabledUntil !== 'undefined') {\n      data.communication_disabled_until =\n        // eslint-disable-next-line eqeqeq\n        data.communicationDisabledUntil != null\n          ? new Date(data.communicationDisabledUntil).toISOString()\n          : data.communicationDisabledUntil;\n    }\n\n    let endpoint;\n    if (id === this.client.user.id) {\n      const keys = Object.keys(data);\n      if (keys.length === 1 && keys[0] === 'nick') endpoint = Routes.guildMember(this.guild.id);\n      else endpoint = Routes.guildMember(this.guild.id, id);\n    } else {\n      endpoint = Routes.guildMember(this.guild.id, id);\n    }\n    const d = await this.client.rest.patch(endpoint, { body: data, reason });\n\n    const clone = this.cache.get(id)?._clone();\n    clone?._patch(d);\n    return clone ?? this._add(d, false);\n  }\n\n  /**\n   * Options used for pruning guild members.\n   * <info>It's recommended to set {@link GuildPruneMembersOptions#count options.count}\n   * to `false` for large guilds.</info>\n   * @typedef {Object} GuildPruneMembersOptions\n   * @property {number} [days] Number of days of inactivity required to kick\n   * @property {boolean} [dry=false] Get the number of users that will be kicked, without actually kicking them\n   * @property {boolean} [count] Whether or not to return the number of users that have been kicked.\n   * @property {RoleResolvable[]} [roles] Array of roles to bypass the \"...and no roles\" constraint when pruning\n   * @property {string} [reason] Reason for this prune\n   */\n\n  /**\n   * Prunes members from the guild based on how long they have been inactive.\n   * @param {GuildPruneMembersOptions} [options] Options for pruning\n   * @returns {Promise<number|null>} The number of members that were/will be kicked\n   * @example\n   * // See how many members will be pruned\n   * guild.members.prune({ dry: true })\n   *   .then(pruned => console.log(`This will prune ${pruned} people!`))\n   *   .catch(console.error);\n   * @example\n   * // Actually prune the members\n   * guild.members.prune({ days: 1, reason: 'too many people!' })\n   *   .then(pruned => console.log(`I just pruned ${pruned} people!`))\n   *   .catch(console.error);\n   * @example\n   * // Include members with a specified role\n   * guild.members.prune({ days: 7, roles: ['657259391652855808'] })\n   *    .then(pruned => console.log(`I just pruned ${pruned} people!`))\n   *    .catch(console.error);\n   */\n  async prune({ days, dry = false, count: compute_prune_count, roles = [], reason } = {}) {\n    if (typeof days !== 'number') throw new DiscordjsTypeError(ErrorCodes.PruneDaysType);\n\n    const query = { days };\n    const resolvedRoles = [];\n\n    for (const role of roles) {\n      const resolvedRole = this.guild.roles.resolveId(role);\n      if (!resolvedRole) {\n        throw new DiscordjsTypeError(ErrorCodes.InvalidElement, 'Array', 'options.roles', role);\n      }\n      resolvedRoles.push(resolvedRole);\n    }\n\n    if (resolvedRoles.length) {\n      query.include_roles = dry ? resolvedRoles.join(',') : resolvedRoles;\n    }\n\n    const endpoint = Routes.guildPrune(this.guild.id);\n\n    const { pruned } = await (dry\n      ? this.client.rest.get(endpoint, { query: makeURLSearchParams(query), reason })\n      : this.client.rest.post(endpoint, { body: { ...query, compute_prune_count }, reason }));\n\n    return pruned;\n  }\n\n  /**\n   * Kicks a user from the guild.\n   * <info>The user must be a member of the guild</info>\n   * @param {UserResolvable} user The member to kick\n   * @param {string} [reason] Reason for kicking\n   * @returns {Promise<GuildMember|User|Snowflake>} Result object will be resolved as specifically as possible.\n   * If the GuildMember cannot be resolved, the User will instead be attempted to be resolved. If that also cannot\n   * be resolved, the user's id will be the result.\n   * @example\n   * // Kick a user by id (or with a user/guild member object)\n   * guild.members.kick('84484653687267328')\n   *   .then(kickInfo => console.log(`Kicked ${kickInfo.user?.tag ?? kickInfo.tag ?? kickInfo}`))\n   *   .catch(console.error);\n   */\n  async kick(user, reason) {\n    const id = this.client.users.resolveId(user);\n    if (!id) return Promise.reject(new DiscordjsTypeError(ErrorCodes.InvalidType, 'user', 'UserResolvable'));\n\n    await this.client.rest.delete(Routes.guildMember(this.guild.id, id), { reason });\n\n    return this.resolve(user) ?? this.client.users.resolve(user) ?? id;\n  }\n\n  /**\n   * Bans a user from the guild.\n   * @param {UserResolvable} user The user to ban\n   * @param {BanOptions} [options] Options for the ban\n   * @returns {Promise<GuildMember|User|Snowflake>} Result object will be resolved as specifically as possible.\n   * If the GuildMember cannot be resolved, the User will instead be attempted to be resolved. If that also cannot\n   * be resolved, the user id will be the result.\n   * Internally calls the GuildBanManager#create method.\n   * @example\n   * // Ban a user by id (or with a user/guild member object)\n   * guild.members.ban('84484653687267328')\n   *   .then(banInfo => console.log(`Banned ${banInfo.user?.tag ?? banInfo.tag ?? banInfo}`))\n   *   .catch(console.error);\n   */\n  ban(user, options) {\n    return this.guild.bans.create(user, options);\n  }\n\n  /**\n   * Unbans a user from the guild. Internally calls the {@link GuildBanManager#remove} method.\n   * @param {UserResolvable} user The user to unban\n   * @param {string} [reason] Reason for unbanning user\n   * @returns {Promise<?User>} The user that was unbanned\n   * @example\n   * // Unban a user by id (or with a user/guild member object)\n   * guild.members.unban('84484653687267328')\n   *   .then(user => console.log(`Unbanned ${user.username} from ${guild.name}`))\n   *   .catch(console.error);\n   */\n  unban(user, reason) {\n    return this.guild.bans.remove(user, reason);\n  }\n\n  /**\n   * Options used for adding or removing a role from a member.\n   * @typedef {Object} AddOrRemoveGuildMemberRoleOptions\n   * @property {GuildMemberResolvable} user The user to add/remove the role from\n   * @property {RoleResolvable} role The role to add/remove\n   * @property {string} [reason] Reason for adding/removing the role\n   */\n\n  /**\n   * Adds a role to a member.\n   * @param {AddOrRemoveGuildMemberRoleOptions} options Options for adding the role\n   * @returns {Promise<GuildMember|User|Snowflake>}\n   */\n  async addRole(options) {\n    const { user, role, reason } = options;\n    const userId = this.guild.members.resolveId(user);\n    const roleId = this.guild.roles.resolveId(role);\n    await this.client.rest.put(Routes.guildMemberRole(this.guild.id, userId, roleId), { reason });\n\n    return this.resolve(user) ?? this.client.users.resolve(user) ?? userId;\n  }\n\n  /**\n   * Removes a role from a member.\n   * @param {AddOrRemoveGuildMemberRoleOptions} options Options for removing the role\n   * @returns {Promise<GuildMember|User|Snowflake>}\n   */\n  async removeRole(options) {\n    const { user, role, reason } = options;\n    const userId = this.guild.members.resolveId(user);\n    const roleId = this.guild.roles.resolveId(role);\n    await this.client.rest.delete(Routes.guildMemberRole(this.guild.id, userId, roleId), { reason });\n\n    return this.resolve(user) ?? this.client.users.resolve(user) ?? userId;\n  }\n\n  async _fetchSingle({ user, cache, force = false }) {\n    if (!force) {\n      const existing = this.cache.get(user);\n      if (existing && !existing.partial) return existing;\n    }\n\n    const data = await this.client.rest.get(Routes.guildMember(this.guild.id, user));\n    return this._add(data, cache);\n  }\n\n  _fetchMany({\n    limit = 0,\n    withPresences: presences = false,\n    user: user_ids,\n    query,\n    time = 120e3,\n    nonce = DiscordSnowflake.generate().toString(),\n  } = {}) {\n    return new Promise((resolve, reject) => {\n      if (!query && !user_ids) query = '';\n      if (nonce.length > 32) throw new DiscordjsRangeError(ErrorCodes.MemberFetchNonceLength);\n      this.guild.shard.send({\n        op: GatewayOpcodes.RequestGuildMembers,\n        d: {\n          guild_id: this.guild.id,\n          presences,\n          user_ids,\n          query,\n          nonce,\n          limit,\n        },\n      });\n      const fetchedMembers = new Collection();\n      let i = 0;\n      const handler = (members, _, chunk) => {\n        timeout.refresh();\n        if (chunk.nonce !== nonce) return;\n        i++;\n        for (const member of members.values()) {\n          fetchedMembers.set(member.id, member);\n        }\n        if (members.size < 1_000 || (limit && fetchedMembers.size >= limit) || i === chunk.count) {\n          clearTimeout(timeout);\n          this.client.removeListener(Events.GuildMembersChunk, handler);\n          this.client.decrementMaxListeners();\n          let fetched = fetchedMembers;\n          if (user_ids && !Array.isArray(user_ids) && fetched.size) fetched = fetched.first();\n          resolve(fetched);\n        }\n      };\n      const timeout = setTimeout(() => {\n        this.client.removeListener(Events.GuildMembersChunk, handler);\n        this.client.decrementMaxListeners();\n        reject(new DiscordjsError(ErrorCodes.GuildMembersTimeout));\n      }, time).unref();\n      this.client.incrementMaxListeners();\n      this.client.on(Events.GuildMembersChunk, handler);\n    });\n  }\n}\n\nmodule.exports = GuildMemberManager;\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}