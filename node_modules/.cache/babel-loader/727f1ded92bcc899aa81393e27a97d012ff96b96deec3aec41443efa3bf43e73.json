{"ast":null,"code":"const assert = require('assert');\nconst {\n  atob\n} = require('buffer');\nconst {\n  format\n} = require('url');\nconst {\n  isValidHTTPToken,\n  isomorphicDecode\n} = require('./util');\nconst encoder = new TextEncoder();\n\n// https://fetch.spec.whatwg.org/#data-url-processor\n/** @param {URL} dataURL */\nfunction dataURLProcessor(dataURL) {\n  // 1. Assert: dataURL’s scheme is \"data\".\n  assert(dataURL.protocol === 'data:');\n\n  // 2. Let input be the result of running the URL\n  // serializer on dataURL with exclude fragment\n  // set to true.\n  let input = URLSerializer(dataURL, true);\n\n  // 3. Remove the leading \"data:\" string from input.\n  input = input.slice(5);\n\n  // 4. Let position point at the start of input.\n  const position = {\n    position: 0\n  };\n\n  // 5. Let mimeType be the result of collecting a\n  // sequence of code points that are not equal\n  // to U+002C (,), given position.\n  let mimeType = collectASequenceOfCodePoints(char => char !== ',', input, position);\n\n  // 6. Strip leading and trailing ASCII whitespace\n  // from mimeType.\n  // Note: This will only remove U+0020 SPACE code\n  // points, if any.\n  // Undici implementation note: we need to store the\n  // length because if the mimetype has spaces removed,\n  // the wrong amount will be sliced from the input in\n  // step #9\n  const mimeTypeLength = mimeType.length;\n  mimeType = mimeType.replace(/^(\\u0020)+|(\\u0020)+$/g, '');\n\n  // 7. If position is past the end of input, then\n  // return failure\n  if (position.position >= input.length) {\n    return 'failure';\n  }\n\n  // 8. Advance position by 1.\n  position.position++;\n\n  // 9. Let encodedBody be the remainder of input.\n  const encodedBody = input.slice(mimeTypeLength + 1);\n\n  // 10. Let body be the percent-decoding of encodedBody.\n  let body = stringPercentDecode(encodedBody);\n\n  // 11. If mimeType ends with U+003B (;), followed by\n  // zero or more U+0020 SPACE, followed by an ASCII\n  // case-insensitive match for \"base64\", then:\n  if (/;(\\u0020){0,}base64$/i.test(mimeType)) {\n    // 1. Let stringBody be the isomorphic decode of body.\n    const stringBody = isomorphicDecode(body);\n\n    // 2. Set body to the forgiving-base64 decode of\n    // stringBody.\n    body = forgivingBase64(stringBody);\n\n    // 3. If body is failure, then return failure.\n    if (body === 'failure') {\n      return 'failure';\n    }\n\n    // 4. Remove the last 6 code points from mimeType.\n    mimeType = mimeType.slice(0, -6);\n\n    // 5. Remove trailing U+0020 SPACE code points from mimeType,\n    // if any.\n    mimeType = mimeType.replace(/(\\u0020)+$/, '');\n\n    // 6. Remove the last U+003B (;) code point from mimeType.\n    mimeType = mimeType.slice(0, -1);\n  }\n\n  // 12. If mimeType starts with U+003B (;), then prepend\n  // \"text/plain\" to mimeType.\n  if (mimeType.startsWith(';')) {\n    mimeType = 'text/plain' + mimeType;\n  }\n\n  // 13. Let mimeTypeRecord be the result of parsing\n  // mimeType.\n  let mimeTypeRecord = parseMIMEType(mimeType);\n\n  // 14. If mimeTypeRecord is failure, then set\n  // mimeTypeRecord to text/plain;charset=US-ASCII.\n  if (mimeTypeRecord === 'failure') {\n    mimeTypeRecord = parseMIMEType('text/plain;charset=US-ASCII');\n  }\n\n  // 15. Return a new data: URL struct whose MIME\n  // type is mimeTypeRecord and body is body.\n  // https://fetch.spec.whatwg.org/#data-url-struct\n  return {\n    mimeType: mimeTypeRecord,\n    body\n  };\n}\n\n// https://url.spec.whatwg.org/#concept-url-serializer\n/**\n * @param {URL} url\n * @param {boolean} excludeFragment\n */\nfunction URLSerializer(url) {\n  let excludeFragment = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n  return format(url, {\n    fragment: !excludeFragment\n  });\n}\n\n// https://infra.spec.whatwg.org/#collect-a-sequence-of-code-points\n/**\n * @param {(char: string) => boolean} condition\n * @param {string} input\n * @param {{ position: number }} position\n */\nfunction collectASequenceOfCodePoints(condition, input, position) {\n  // 1. Let result be the empty string.\n  let result = '';\n\n  // 2. While position doesn’t point past the end of input and the\n  // code point at position within input meets the condition condition:\n  while (position.position < input.length && condition(input[position.position])) {\n    // 1. Append that code point to the end of result.\n    result += input[position.position];\n\n    // 2. Advance position by 1.\n    position.position++;\n  }\n\n  // 3. Return result.\n  return result;\n}\n\n// https://url.spec.whatwg.org/#string-percent-decode\n/** @param {string} input */\nfunction stringPercentDecode(input) {\n  // 1. Let bytes be the UTF-8 encoding of input.\n  const bytes = encoder.encode(input);\n\n  // 2. Return the percent-decoding of bytes.\n  return percentDecode(bytes);\n}\n\n// https://url.spec.whatwg.org/#percent-decode\n/** @param {Uint8Array} input */\nfunction percentDecode(input) {\n  // 1. Let output be an empty byte sequence.\n  /** @type {number[]} */\n  const output = [];\n\n  // 2. For each byte byte in input:\n  for (let i = 0; i < input.length; i++) {\n    const byte = input[i];\n\n    // 1. If byte is not 0x25 (%), then append byte to output.\n    if (byte !== 0x25) {\n      output.push(byte);\n\n      // 2. Otherwise, if byte is 0x25 (%) and the next two bytes\n      // after byte in input are not in the ranges\n      // 0x30 (0) to 0x39 (9), 0x41 (A) to 0x46 (F),\n      // and 0x61 (a) to 0x66 (f), all inclusive, append byte\n      // to output.\n    } else if (byte === 0x25 && !/^[0-9A-Fa-f]{2}$/i.test(String.fromCharCode(input[i + 1], input[i + 2]))) {\n      output.push(0x25);\n\n      // 3. Otherwise:\n    } else {\n      // 1. Let bytePoint be the two bytes after byte in input,\n      // decoded, and then interpreted as hexadecimal number.\n      const nextTwoBytes = String.fromCharCode(input[i + 1], input[i + 2]);\n      const bytePoint = Number.parseInt(nextTwoBytes, 16);\n\n      // 2. Append a byte whose value is bytePoint to output.\n      output.push(bytePoint);\n\n      // 3. Skip the next two bytes in input.\n      i += 2;\n    }\n  }\n\n  // 3. Return output.\n  return Uint8Array.from(output);\n}\n\n// https://mimesniff.spec.whatwg.org/#parse-a-mime-type\n/** @param {string} input */\nfunction parseMIMEType(input) {\n  // 1. Remove any leading and trailing HTTP whitespace\n  // from input.\n  input = input.trim();\n\n  // 2. Let position be a position variable for input,\n  // initially pointing at the start of input.\n  const position = {\n    position: 0\n  };\n\n  // 3. Let type be the result of collecting a sequence\n  // of code points that are not U+002F (/) from\n  // input, given position.\n  const type = collectASequenceOfCodePoints(char => char !== '/', input, position);\n\n  // 4. If type is the empty string or does not solely\n  // contain HTTP token code points, then return failure.\n  // https://mimesniff.spec.whatwg.org/#http-token-code-point\n  if (type.length === 0 || !/^[!#$%&'*+-.^_|~A-z0-9]+$/.test(type)) {\n    return 'failure';\n  }\n\n  // 5. If position is past the end of input, then return\n  // failure\n  if (position.position > input.length) {\n    return 'failure';\n  }\n\n  // 6. Advance position by 1. (This skips past U+002F (/).)\n  position.position++;\n\n  // 7. Let subtype be the result of collecting a sequence of\n  // code points that are not U+003B (;) from input, given\n  // position.\n  let subtype = collectASequenceOfCodePoints(char => char !== ';', input, position);\n\n  // 8. Remove any trailing HTTP whitespace from subtype.\n  subtype = subtype.trimEnd();\n\n  // 9. If subtype is the empty string or does not solely\n  // contain HTTP token code points, then return failure.\n  if (subtype.length === 0 || !/^[!#$%&'*+-.^_|~A-z0-9]+$/.test(subtype)) {\n    return 'failure';\n  }\n\n  // 10. Let mimeType be a new MIME type record whose type\n  // is type, in ASCII lowercase, and subtype is subtype,\n  // in ASCII lowercase.\n  // https://mimesniff.spec.whatwg.org/#mime-type\n  const mimeType = {\n    type: type.toLowerCase(),\n    subtype: subtype.toLowerCase(),\n    /** @type {Map<string, string>} */\n    parameters: new Map(),\n    // https://mimesniff.spec.whatwg.org/#mime-type-essence\n    get essence() {\n      return `${this.type}/${this.subtype}`;\n    }\n  };\n\n  // 11. While position is not past the end of input:\n  while (position.position < input.length) {\n    // 1. Advance position by 1. (This skips past U+003B (;).)\n    position.position++;\n\n    // 2. Collect a sequence of code points that are HTTP\n    // whitespace from input given position.\n    collectASequenceOfCodePoints(\n    // https://fetch.spec.whatwg.org/#http-whitespace\n    char => /(\\u000A|\\u000D|\\u0009|\\u0020)/.test(char),\n    // eslint-disable-line\n    input, position);\n\n    // 3. Let parameterName be the result of collecting a\n    // sequence of code points that are not U+003B (;)\n    // or U+003D (=) from input, given position.\n    let parameterName = collectASequenceOfCodePoints(char => char !== ';' && char !== '=', input, position);\n\n    // 4. Set parameterName to parameterName, in ASCII\n    // lowercase.\n    parameterName = parameterName.toLowerCase();\n\n    // 5. If position is not past the end of input, then:\n    if (position.position < input.length) {\n      // 1. If the code point at position within input is\n      // U+003B (;), then continue.\n      if (input[position.position] === ';') {\n        continue;\n      }\n\n      // 2. Advance position by 1. (This skips past U+003D (=).)\n      position.position++;\n    }\n\n    // 6. If position is past the end of input, then break.\n    if (position.position > input.length) {\n      break;\n    }\n\n    // 7. Let parameterValue be null.\n    let parameterValue = null;\n\n    // 8. If the code point at position within input is\n    // U+0022 (\"), then:\n    if (input[position.position] === '\"') {\n      // 1. Set parameterValue to the result of collecting\n      // an HTTP quoted string from input, given position\n      // and the extract-value flag.\n      parameterValue = collectAnHTTPQuotedString(input, position, true);\n\n      // 2. Collect a sequence of code points that are not\n      // U+003B (;) from input, given position.\n      collectASequenceOfCodePoints(char => char !== ';', input, position);\n\n      // 9. Otherwise:\n    } else {\n      // 1. Set parameterValue to the result of collecting\n      // a sequence of code points that are not U+003B (;)\n      // from input, given position.\n      parameterValue = collectASequenceOfCodePoints(char => char !== ';', input, position);\n\n      // 2. Remove any trailing HTTP whitespace from parameterValue.\n      // Note: it says \"trailing\" whitespace; leading is fine.\n      parameterValue = parameterValue.trimEnd();\n\n      // 3. If parameterValue is the empty string, then continue.\n      if (parameterValue.length === 0) {\n        continue;\n      }\n    }\n\n    // 10. If all of the following are true\n    // - parameterName is not the empty string\n    // - parameterName solely contains HTTP token code points\n    // - parameterValue solely contains HTTP quoted-string token code points\n    // - mimeType’s parameters[parameterName] does not exist\n    // then set mimeType’s parameters[parameterName] to parameterValue.\n    if (parameterName.length !== 0 && /^[!#$%&'*+-.^_|~A-z0-9]+$/.test(parameterName) &&\n    // https://mimesniff.spec.whatwg.org/#http-quoted-string-token-code-point\n    !/^(\\u0009|\\x{0020}-\\x{007E}|\\x{0080}-\\x{00FF})+$/.test(parameterValue) &&\n    // eslint-disable-line\n    !mimeType.parameters.has(parameterName)) {\n      mimeType.parameters.set(parameterName, parameterValue);\n    }\n  }\n\n  // 12. Return mimeType.\n  return mimeType;\n}\n\n// https://infra.spec.whatwg.org/#forgiving-base64-decode\n/** @param {string} data */\nfunction forgivingBase64(data) {\n  // 1. Remove all ASCII whitespace from data.\n  data = data.replace(/[\\u0009\\u000A\\u000C\\u000D\\u0020]/g, ''); // eslint-disable-line\n\n  // 2. If data’s code point length divides by 4 leaving\n  // no remainder, then:\n  if (data.length % 4 === 0) {\n    // 1. If data ends with one or two U+003D (=) code points,\n    // then remove them from data.\n    data = data.replace(/=?=$/, '');\n  }\n\n  // 3. If data’s code point length divides by 4 leaving\n  // a remainder of 1, then return failure.\n  if (data.length % 4 === 1) {\n    return 'failure';\n  }\n\n  // 4. If data contains a code point that is not one of\n  //  U+002B (+)\n  //  U+002F (/)\n  //  ASCII alphanumeric\n  // then return failure.\n  if (/[^+/0-9A-Za-z]/.test(data)) {\n    return 'failure';\n  }\n  const binary = atob(data);\n  const bytes = new Uint8Array(binary.length);\n  for (let byte = 0; byte < binary.length; byte++) {\n    bytes[byte] = binary.charCodeAt(byte);\n  }\n  return bytes;\n}\n\n// https://fetch.spec.whatwg.org/#collect-an-http-quoted-string\n// tests: https://fetch.spec.whatwg.org/#example-http-quoted-string\n/**\n * @param {string} input\n * @param {{ position: number }} position\n * @param {boolean?} extractValue\n */\nfunction collectAnHTTPQuotedString(input, position, extractValue) {\n  // 1. Let positionStart be position.\n  const positionStart = position.position;\n\n  // 2. Let value be the empty string.\n  let value = '';\n\n  // 3. Assert: the code point at position within input\n  // is U+0022 (\").\n  assert(input[position.position] === '\"');\n\n  // 4. Advance position by 1.\n  position.position++;\n\n  // 5. While true:\n  while (true) {\n    // 1. Append the result of collecting a sequence of code points\n    // that are not U+0022 (\") or U+005C (\\) from input, given\n    // position, to value.\n    value += collectASequenceOfCodePoints(char => char !== '\"' && char !== '\\\\', input, position);\n\n    // 2. If position is past the end of input, then break.\n    if (position.position >= input.length) {\n      break;\n    }\n\n    // 3. Let quoteOrBackslash be the code point at position within\n    // input.\n    const quoteOrBackslash = input[position.position];\n\n    // 4. Advance position by 1.\n    position.position++;\n\n    // 5. If quoteOrBackslash is U+005C (\\), then:\n    if (quoteOrBackslash === '\\\\') {\n      // 1. If position is past the end of input, then append\n      // U+005C (\\) to value and break.\n      if (position.position >= input.length) {\n        value += '\\\\';\n        break;\n      }\n\n      // 2. Append the code point at position within input to value.\n      value += input[position.position];\n\n      // 3. Advance position by 1.\n      position.position++;\n\n      // 6. Otherwise:\n    } else {\n      // 1. Assert: quoteOrBackslash is U+0022 (\").\n      assert(quoteOrBackslash === '\"');\n\n      // 2. Break.\n      break;\n    }\n  }\n\n  // 6. If the extract-value flag is set, then return value.\n  if (extractValue) {\n    return value;\n  }\n\n  // 7. Return the code points from positionStart to position,\n  // inclusive, within input.\n  return input.slice(positionStart, position.position);\n}\n\n/**\n * @see https://mimesniff.spec.whatwg.org/#serialize-a-mime-type\n */\nfunction serializeAMimeType(mimeType) {\n  assert(mimeType !== 'failure');\n  const {\n    type,\n    subtype,\n    parameters\n  } = mimeType;\n\n  // 1. Let serialization be the concatenation of mimeType’s\n  //    type, U+002F (/), and mimeType’s subtype.\n  let serialization = `${type}/${subtype}`;\n\n  // 2. For each name → value of mimeType’s parameters:\n  for (let [name, value] of parameters.entries()) {\n    // 1. Append U+003B (;) to serialization.\n    serialization += ';';\n\n    // 2. Append name to serialization.\n    serialization += name;\n\n    // 3. Append U+003D (=) to serialization.\n    serialization += '=';\n\n    // 4. If value does not solely contain HTTP token code\n    //    points or value is the empty string, then:\n    if (!isValidHTTPToken(value)) {\n      // 1. Precede each occurence of U+0022 (\") or\n      //    U+005C (\\) in value with U+005C (\\).\n      value = value.replace(/(\\\\|\")/g, '\\\\$1');\n\n      // 2. Prepend U+0022 (\") to value.\n      value = '\"' + value;\n\n      // 3. Append U+0022 (\") to value.\n      value += '\"';\n    }\n\n    // 5. Append value to serialization.\n    serialization += value;\n  }\n\n  // 3. Return serialization.\n  return serialization;\n}\nmodule.exports = {\n  dataURLProcessor,\n  URLSerializer,\n  collectASequenceOfCodePoints,\n  stringPercentDecode,\n  parseMIMEType,\n  collectAnHTTPQuotedString,\n  serializeAMimeType\n};","map":{"version":3,"names":["assert","require","atob","format","isValidHTTPToken","isomorphicDecode","encoder","TextEncoder","dataURLProcessor","dataURL","protocol","input","URLSerializer","slice","position","mimeType","collectASequenceOfCodePoints","char","mimeTypeLength","length","replace","encodedBody","body","stringPercentDecode","test","stringBody","forgivingBase64","startsWith","mimeTypeRecord","parseMIMEType","url","excludeFragment","fragment","condition","result","bytes","encode","percentDecode","output","i","byte","push","String","fromCharCode","nextTwoBytes","bytePoint","Number","parseInt","Uint8Array","from","trim","type","subtype","trimEnd","toLowerCase","parameters","Map","essence","parameterName","parameterValue","collectAnHTTPQuotedString","has","set","data","binary","charCodeAt","extractValue","positionStart","value","quoteOrBackslash","serializeAMimeType","serialization","name","entries","module","exports"],"sources":["J:/Coding/Projekts/Web/JavaScript/sillcode.tech/node_modules/undici/lib/fetch/dataURL.js"],"sourcesContent":["const assert = require('assert')\nconst { atob } = require('buffer')\nconst { format } = require('url')\nconst { isValidHTTPToken, isomorphicDecode } = require('./util')\n\nconst encoder = new TextEncoder()\n\n// https://fetch.spec.whatwg.org/#data-url-processor\n/** @param {URL} dataURL */\nfunction dataURLProcessor (dataURL) {\n  // 1. Assert: dataURL’s scheme is \"data\".\n  assert(dataURL.protocol === 'data:')\n\n  // 2. Let input be the result of running the URL\n  // serializer on dataURL with exclude fragment\n  // set to true.\n  let input = URLSerializer(dataURL, true)\n\n  // 3. Remove the leading \"data:\" string from input.\n  input = input.slice(5)\n\n  // 4. Let position point at the start of input.\n  const position = { position: 0 }\n\n  // 5. Let mimeType be the result of collecting a\n  // sequence of code points that are not equal\n  // to U+002C (,), given position.\n  let mimeType = collectASequenceOfCodePoints(\n    (char) => char !== ',',\n    input,\n    position\n  )\n\n  // 6. Strip leading and trailing ASCII whitespace\n  // from mimeType.\n  // Note: This will only remove U+0020 SPACE code\n  // points, if any.\n  // Undici implementation note: we need to store the\n  // length because if the mimetype has spaces removed,\n  // the wrong amount will be sliced from the input in\n  // step #9\n  const mimeTypeLength = mimeType.length\n  mimeType = mimeType.replace(/^(\\u0020)+|(\\u0020)+$/g, '')\n\n  // 7. If position is past the end of input, then\n  // return failure\n  if (position.position >= input.length) {\n    return 'failure'\n  }\n\n  // 8. Advance position by 1.\n  position.position++\n\n  // 9. Let encodedBody be the remainder of input.\n  const encodedBody = input.slice(mimeTypeLength + 1)\n\n  // 10. Let body be the percent-decoding of encodedBody.\n  let body = stringPercentDecode(encodedBody)\n\n  // 11. If mimeType ends with U+003B (;), followed by\n  // zero or more U+0020 SPACE, followed by an ASCII\n  // case-insensitive match for \"base64\", then:\n  if (/;(\\u0020){0,}base64$/i.test(mimeType)) {\n    // 1. Let stringBody be the isomorphic decode of body.\n    const stringBody = isomorphicDecode(body)\n\n    // 2. Set body to the forgiving-base64 decode of\n    // stringBody.\n    body = forgivingBase64(stringBody)\n\n    // 3. If body is failure, then return failure.\n    if (body === 'failure') {\n      return 'failure'\n    }\n\n    // 4. Remove the last 6 code points from mimeType.\n    mimeType = mimeType.slice(0, -6)\n\n    // 5. Remove trailing U+0020 SPACE code points from mimeType,\n    // if any.\n    mimeType = mimeType.replace(/(\\u0020)+$/, '')\n\n    // 6. Remove the last U+003B (;) code point from mimeType.\n    mimeType = mimeType.slice(0, -1)\n  }\n\n  // 12. If mimeType starts with U+003B (;), then prepend\n  // \"text/plain\" to mimeType.\n  if (mimeType.startsWith(';')) {\n    mimeType = 'text/plain' + mimeType\n  }\n\n  // 13. Let mimeTypeRecord be the result of parsing\n  // mimeType.\n  let mimeTypeRecord = parseMIMEType(mimeType)\n\n  // 14. If mimeTypeRecord is failure, then set\n  // mimeTypeRecord to text/plain;charset=US-ASCII.\n  if (mimeTypeRecord === 'failure') {\n    mimeTypeRecord = parseMIMEType('text/plain;charset=US-ASCII')\n  }\n\n  // 15. Return a new data: URL struct whose MIME\n  // type is mimeTypeRecord and body is body.\n  // https://fetch.spec.whatwg.org/#data-url-struct\n  return { mimeType: mimeTypeRecord, body }\n}\n\n// https://url.spec.whatwg.org/#concept-url-serializer\n/**\n * @param {URL} url\n * @param {boolean} excludeFragment\n */\nfunction URLSerializer (url, excludeFragment = false) {\n  return format(url, { fragment: !excludeFragment })\n}\n\n// https://infra.spec.whatwg.org/#collect-a-sequence-of-code-points\n/**\n * @param {(char: string) => boolean} condition\n * @param {string} input\n * @param {{ position: number }} position\n */\nfunction collectASequenceOfCodePoints (condition, input, position) {\n  // 1. Let result be the empty string.\n  let result = ''\n\n  // 2. While position doesn’t point past the end of input and the\n  // code point at position within input meets the condition condition:\n  while (position.position < input.length && condition(input[position.position])) {\n    // 1. Append that code point to the end of result.\n    result += input[position.position]\n\n    // 2. Advance position by 1.\n    position.position++\n  }\n\n  // 3. Return result.\n  return result\n}\n\n// https://url.spec.whatwg.org/#string-percent-decode\n/** @param {string} input */\nfunction stringPercentDecode (input) {\n  // 1. Let bytes be the UTF-8 encoding of input.\n  const bytes = encoder.encode(input)\n\n  // 2. Return the percent-decoding of bytes.\n  return percentDecode(bytes)\n}\n\n// https://url.spec.whatwg.org/#percent-decode\n/** @param {Uint8Array} input */\nfunction percentDecode (input) {\n  // 1. Let output be an empty byte sequence.\n  /** @type {number[]} */\n  const output = []\n\n  // 2. For each byte byte in input:\n  for (let i = 0; i < input.length; i++) {\n    const byte = input[i]\n\n    // 1. If byte is not 0x25 (%), then append byte to output.\n    if (byte !== 0x25) {\n      output.push(byte)\n\n    // 2. Otherwise, if byte is 0x25 (%) and the next two bytes\n    // after byte in input are not in the ranges\n    // 0x30 (0) to 0x39 (9), 0x41 (A) to 0x46 (F),\n    // and 0x61 (a) to 0x66 (f), all inclusive, append byte\n    // to output.\n    } else if (\n      byte === 0x25 &&\n      !/^[0-9A-Fa-f]{2}$/i.test(String.fromCharCode(input[i + 1], input[i + 2]))\n    ) {\n      output.push(0x25)\n\n    // 3. Otherwise:\n    } else {\n      // 1. Let bytePoint be the two bytes after byte in input,\n      // decoded, and then interpreted as hexadecimal number.\n      const nextTwoBytes = String.fromCharCode(input[i + 1], input[i + 2])\n      const bytePoint = Number.parseInt(nextTwoBytes, 16)\n\n      // 2. Append a byte whose value is bytePoint to output.\n      output.push(bytePoint)\n\n      // 3. Skip the next two bytes in input.\n      i += 2\n    }\n  }\n\n  // 3. Return output.\n  return Uint8Array.from(output)\n}\n\n// https://mimesniff.spec.whatwg.org/#parse-a-mime-type\n/** @param {string} input */\nfunction parseMIMEType (input) {\n  // 1. Remove any leading and trailing HTTP whitespace\n  // from input.\n  input = input.trim()\n\n  // 2. Let position be a position variable for input,\n  // initially pointing at the start of input.\n  const position = { position: 0 }\n\n  // 3. Let type be the result of collecting a sequence\n  // of code points that are not U+002F (/) from\n  // input, given position.\n  const type = collectASequenceOfCodePoints(\n    (char) => char !== '/',\n    input,\n    position\n  )\n\n  // 4. If type is the empty string or does not solely\n  // contain HTTP token code points, then return failure.\n  // https://mimesniff.spec.whatwg.org/#http-token-code-point\n  if (type.length === 0 || !/^[!#$%&'*+-.^_|~A-z0-9]+$/.test(type)) {\n    return 'failure'\n  }\n\n  // 5. If position is past the end of input, then return\n  // failure\n  if (position.position > input.length) {\n    return 'failure'\n  }\n\n  // 6. Advance position by 1. (This skips past U+002F (/).)\n  position.position++\n\n  // 7. Let subtype be the result of collecting a sequence of\n  // code points that are not U+003B (;) from input, given\n  // position.\n  let subtype = collectASequenceOfCodePoints(\n    (char) => char !== ';',\n    input,\n    position\n  )\n\n  // 8. Remove any trailing HTTP whitespace from subtype.\n  subtype = subtype.trimEnd()\n\n  // 9. If subtype is the empty string or does not solely\n  // contain HTTP token code points, then return failure.\n  if (subtype.length === 0 || !/^[!#$%&'*+-.^_|~A-z0-9]+$/.test(subtype)) {\n    return 'failure'\n  }\n\n  // 10. Let mimeType be a new MIME type record whose type\n  // is type, in ASCII lowercase, and subtype is subtype,\n  // in ASCII lowercase.\n  // https://mimesniff.spec.whatwg.org/#mime-type\n  const mimeType = {\n    type: type.toLowerCase(),\n    subtype: subtype.toLowerCase(),\n    /** @type {Map<string, string>} */\n    parameters: new Map(),\n    // https://mimesniff.spec.whatwg.org/#mime-type-essence\n    get essence () {\n      return `${this.type}/${this.subtype}`\n    }\n  }\n\n  // 11. While position is not past the end of input:\n  while (position.position < input.length) {\n    // 1. Advance position by 1. (This skips past U+003B (;).)\n    position.position++\n\n    // 2. Collect a sequence of code points that are HTTP\n    // whitespace from input given position.\n    collectASequenceOfCodePoints(\n      // https://fetch.spec.whatwg.org/#http-whitespace\n      (char) => /(\\u000A|\\u000D|\\u0009|\\u0020)/.test(char), // eslint-disable-line\n      input,\n      position\n    )\n\n    // 3. Let parameterName be the result of collecting a\n    // sequence of code points that are not U+003B (;)\n    // or U+003D (=) from input, given position.\n    let parameterName = collectASequenceOfCodePoints(\n      (char) => char !== ';' && char !== '=',\n      input,\n      position\n    )\n\n    // 4. Set parameterName to parameterName, in ASCII\n    // lowercase.\n    parameterName = parameterName.toLowerCase()\n\n    // 5. If position is not past the end of input, then:\n    if (position.position < input.length) {\n      // 1. If the code point at position within input is\n      // U+003B (;), then continue.\n      if (input[position.position] === ';') {\n        continue\n      }\n\n      // 2. Advance position by 1. (This skips past U+003D (=).)\n      position.position++\n    }\n\n    // 6. If position is past the end of input, then break.\n    if (position.position > input.length) {\n      break\n    }\n\n    // 7. Let parameterValue be null.\n    let parameterValue = null\n\n    // 8. If the code point at position within input is\n    // U+0022 (\"), then:\n    if (input[position.position] === '\"') {\n      // 1. Set parameterValue to the result of collecting\n      // an HTTP quoted string from input, given position\n      // and the extract-value flag.\n      parameterValue = collectAnHTTPQuotedString(input, position, true)\n\n      // 2. Collect a sequence of code points that are not\n      // U+003B (;) from input, given position.\n      collectASequenceOfCodePoints(\n        (char) => char !== ';',\n        input,\n        position\n      )\n\n    // 9. Otherwise:\n    } else {\n      // 1. Set parameterValue to the result of collecting\n      // a sequence of code points that are not U+003B (;)\n      // from input, given position.\n      parameterValue = collectASequenceOfCodePoints(\n        (char) => char !== ';',\n        input,\n        position\n      )\n\n      // 2. Remove any trailing HTTP whitespace from parameterValue.\n      // Note: it says \"trailing\" whitespace; leading is fine.\n      parameterValue = parameterValue.trimEnd()\n\n      // 3. If parameterValue is the empty string, then continue.\n      if (parameterValue.length === 0) {\n        continue\n      }\n    }\n\n    // 10. If all of the following are true\n    // - parameterName is not the empty string\n    // - parameterName solely contains HTTP token code points\n    // - parameterValue solely contains HTTP quoted-string token code points\n    // - mimeType’s parameters[parameterName] does not exist\n    // then set mimeType’s parameters[parameterName] to parameterValue.\n    if (\n      parameterName.length !== 0 &&\n      /^[!#$%&'*+-.^_|~A-z0-9]+$/.test(parameterName) &&\n      // https://mimesniff.spec.whatwg.org/#http-quoted-string-token-code-point\n      !/^(\\u0009|\\x{0020}-\\x{007E}|\\x{0080}-\\x{00FF})+$/.test(parameterValue) &&  // eslint-disable-line\n      !mimeType.parameters.has(parameterName)\n    ) {\n      mimeType.parameters.set(parameterName, parameterValue)\n    }\n  }\n\n  // 12. Return mimeType.\n  return mimeType\n}\n\n// https://infra.spec.whatwg.org/#forgiving-base64-decode\n/** @param {string} data */\nfunction forgivingBase64 (data) {\n  // 1. Remove all ASCII whitespace from data.\n  data = data.replace(/[\\u0009\\u000A\\u000C\\u000D\\u0020]/g, '')  // eslint-disable-line\n\n  // 2. If data’s code point length divides by 4 leaving\n  // no remainder, then:\n  if (data.length % 4 === 0) {\n    // 1. If data ends with one or two U+003D (=) code points,\n    // then remove them from data.\n    data = data.replace(/=?=$/, '')\n  }\n\n  // 3. If data’s code point length divides by 4 leaving\n  // a remainder of 1, then return failure.\n  if (data.length % 4 === 1) {\n    return 'failure'\n  }\n\n  // 4. If data contains a code point that is not one of\n  //  U+002B (+)\n  //  U+002F (/)\n  //  ASCII alphanumeric\n  // then return failure.\n  if (/[^+/0-9A-Za-z]/.test(data)) {\n    return 'failure'\n  }\n\n  const binary = atob(data)\n  const bytes = new Uint8Array(binary.length)\n\n  for (let byte = 0; byte < binary.length; byte++) {\n    bytes[byte] = binary.charCodeAt(byte)\n  }\n\n  return bytes\n}\n\n// https://fetch.spec.whatwg.org/#collect-an-http-quoted-string\n// tests: https://fetch.spec.whatwg.org/#example-http-quoted-string\n/**\n * @param {string} input\n * @param {{ position: number }} position\n * @param {boolean?} extractValue\n */\nfunction collectAnHTTPQuotedString (input, position, extractValue) {\n  // 1. Let positionStart be position.\n  const positionStart = position.position\n\n  // 2. Let value be the empty string.\n  let value = ''\n\n  // 3. Assert: the code point at position within input\n  // is U+0022 (\").\n  assert(input[position.position] === '\"')\n\n  // 4. Advance position by 1.\n  position.position++\n\n  // 5. While true:\n  while (true) {\n    // 1. Append the result of collecting a sequence of code points\n    // that are not U+0022 (\") or U+005C (\\) from input, given\n    // position, to value.\n    value += collectASequenceOfCodePoints(\n      (char) => char !== '\"' && char !== '\\\\',\n      input,\n      position\n    )\n\n    // 2. If position is past the end of input, then break.\n    if (position.position >= input.length) {\n      break\n    }\n\n    // 3. Let quoteOrBackslash be the code point at position within\n    // input.\n    const quoteOrBackslash = input[position.position]\n\n    // 4. Advance position by 1.\n    position.position++\n\n    // 5. If quoteOrBackslash is U+005C (\\), then:\n    if (quoteOrBackslash === '\\\\') {\n      // 1. If position is past the end of input, then append\n      // U+005C (\\) to value and break.\n      if (position.position >= input.length) {\n        value += '\\\\'\n        break\n      }\n\n      // 2. Append the code point at position within input to value.\n      value += input[position.position]\n\n      // 3. Advance position by 1.\n      position.position++\n\n    // 6. Otherwise:\n    } else {\n      // 1. Assert: quoteOrBackslash is U+0022 (\").\n      assert(quoteOrBackslash === '\"')\n\n      // 2. Break.\n      break\n    }\n  }\n\n  // 6. If the extract-value flag is set, then return value.\n  if (extractValue) {\n    return value\n  }\n\n  // 7. Return the code points from positionStart to position,\n  // inclusive, within input.\n  return input.slice(positionStart, position.position)\n}\n\n/**\n * @see https://mimesniff.spec.whatwg.org/#serialize-a-mime-type\n */\nfunction serializeAMimeType (mimeType) {\n  assert(mimeType !== 'failure')\n  const { type, subtype, parameters } = mimeType\n\n  // 1. Let serialization be the concatenation of mimeType’s\n  //    type, U+002F (/), and mimeType’s subtype.\n  let serialization = `${type}/${subtype}`\n\n  // 2. For each name → value of mimeType’s parameters:\n  for (let [name, value] of parameters.entries()) {\n    // 1. Append U+003B (;) to serialization.\n    serialization += ';'\n\n    // 2. Append name to serialization.\n    serialization += name\n\n    // 3. Append U+003D (=) to serialization.\n    serialization += '='\n\n    // 4. If value does not solely contain HTTP token code\n    //    points or value is the empty string, then:\n    if (!isValidHTTPToken(value)) {\n      // 1. Precede each occurence of U+0022 (\") or\n      //    U+005C (\\) in value with U+005C (\\).\n      value = value.replace(/(\\\\|\")/g, '\\\\$1')\n\n      // 2. Prepend U+0022 (\") to value.\n      value = '\"' + value\n\n      // 3. Append U+0022 (\") to value.\n      value += '\"'\n    }\n\n    // 5. Append value to serialization.\n    serialization += value\n  }\n\n  // 3. Return serialization.\n  return serialization\n}\n\nmodule.exports = {\n  dataURLProcessor,\n  URLSerializer,\n  collectASequenceOfCodePoints,\n  stringPercentDecode,\n  parseMIMEType,\n  collectAnHTTPQuotedString,\n  serializeAMimeType\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}