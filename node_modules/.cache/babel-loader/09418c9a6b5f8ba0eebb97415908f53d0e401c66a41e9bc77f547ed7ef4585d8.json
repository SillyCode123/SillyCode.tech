{"ast":null,"code":"'use strict';\n\nconst {\n  Collection\n} = require('@discordjs/collection');\nconst Action = require('./Action');\nconst Events = require('../../util/Events');\nclass ThreadListSyncAction extends Action {\n  handle(data) {\n    const client = this.client;\n    const guild = client.guilds.cache.get(data.guild_id);\n    if (!guild) return {};\n    if (data.channel_ids) {\n      for (const id of data.channel_ids) {\n        const channel = client.channels.resolve(id);\n        if (channel) this.removeStale(channel);\n      }\n    } else {\n      for (const channel of guild.channels.cache.values()) {\n        this.removeStale(channel);\n      }\n    }\n    const syncedThreads = data.threads.reduce((coll, rawThread) => {\n      const thread = client.channels._add(rawThread);\n      return coll.set(thread.id, thread);\n    }, new Collection());\n    for (const rawMember of Object.values(data.members)) {\n      // Discord sends the thread id as id in this object\n      const thread = client.channels.cache.get(rawMember.id);\n      if (thread) {\n        thread.members._add(rawMember);\n      }\n    }\n\n    /**\n     * Emitted whenever the client user gains access to a text or news channel that contains threads\n     * @event Client#threadListSync\n     * @param {Collection<Snowflake, ThreadChannel>} threads The threads that were synced\n     * @param {Guild} guild The guild that the threads were synced in\n     */\n    client.emit(Events.ThreadListSync, syncedThreads, guild);\n    return {\n      syncedThreads\n    };\n  }\n  removeStale(channel) {\n    channel.threads?.cache.forEach(thread => {\n      if (!thread.archived) {\n        this.client.channels._remove(thread.id);\n      }\n    });\n  }\n}\nmodule.exports = ThreadListSyncAction;","map":{"version":3,"names":["Collection","require","Action","Events","ThreadListSyncAction","handle","data","client","guild","guilds","cache","get","guild_id","channel_ids","id","channel","channels","resolve","removeStale","values","syncedThreads","threads","reduce","coll","rawThread","thread","_add","set","rawMember","Object","members","emit","ThreadListSync","forEach","archived","_remove","module","exports"],"sources":["J:/Coding/Projekts/Web/JavaScript/sillcode.tech/node_modules/discord.js/src/client/actions/ThreadListSync.js"],"sourcesContent":["'use strict';\n\nconst { Collection } = require('@discordjs/collection');\nconst Action = require('./Action');\nconst Events = require('../../util/Events');\n\nclass ThreadListSyncAction extends Action {\n  handle(data) {\n    const client = this.client;\n\n    const guild = client.guilds.cache.get(data.guild_id);\n    if (!guild) return {};\n\n    if (data.channel_ids) {\n      for (const id of data.channel_ids) {\n        const channel = client.channels.resolve(id);\n        if (channel) this.removeStale(channel);\n      }\n    } else {\n      for (const channel of guild.channels.cache.values()) {\n        this.removeStale(channel);\n      }\n    }\n\n    const syncedThreads = data.threads.reduce((coll, rawThread) => {\n      const thread = client.channels._add(rawThread);\n      return coll.set(thread.id, thread);\n    }, new Collection());\n\n    for (const rawMember of Object.values(data.members)) {\n      // Discord sends the thread id as id in this object\n      const thread = client.channels.cache.get(rawMember.id);\n      if (thread) {\n        thread.members._add(rawMember);\n      }\n    }\n\n    /**\n     * Emitted whenever the client user gains access to a text or news channel that contains threads\n     * @event Client#threadListSync\n     * @param {Collection<Snowflake, ThreadChannel>} threads The threads that were synced\n     * @param {Guild} guild The guild that the threads were synced in\n     */\n    client.emit(Events.ThreadListSync, syncedThreads, guild);\n\n    return {\n      syncedThreads,\n    };\n  }\n\n  removeStale(channel) {\n    channel.threads?.cache.forEach(thread => {\n      if (!thread.archived) {\n        this.client.channels._remove(thread.id);\n      }\n    });\n  }\n}\n\nmodule.exports = ThreadListSyncAction;\n"],"mappings":"AAAA,YAAY;;AAEZ,MAAM;EAAEA;AAAW,CAAC,GAAGC,OAAO,CAAC,uBAAuB,CAAC;AACvD,MAAMC,MAAM,GAAGD,OAAO,CAAC,UAAU,CAAC;AAClC,MAAME,MAAM,GAAGF,OAAO,CAAC,mBAAmB,CAAC;AAE3C,MAAMG,oBAAoB,SAASF,MAAM,CAAC;EACxCG,MAAM,CAACC,IAAI,EAAE;IACX,MAAMC,MAAM,GAAG,IAAI,CAACA,MAAM;IAE1B,MAAMC,KAAK,GAAGD,MAAM,CAACE,MAAM,CAACC,KAAK,CAACC,GAAG,CAACL,IAAI,CAACM,QAAQ,CAAC;IACpD,IAAI,CAACJ,KAAK,EAAE,OAAO,CAAC,CAAC;IAErB,IAAIF,IAAI,CAACO,WAAW,EAAE;MACpB,KAAK,MAAMC,EAAE,IAAIR,IAAI,CAACO,WAAW,EAAE;QACjC,MAAME,OAAO,GAAGR,MAAM,CAACS,QAAQ,CAACC,OAAO,CAACH,EAAE,CAAC;QAC3C,IAAIC,OAAO,EAAE,IAAI,CAACG,WAAW,CAACH,OAAO,CAAC;MACxC;IACF,CAAC,MAAM;MACL,KAAK,MAAMA,OAAO,IAAIP,KAAK,CAACQ,QAAQ,CAACN,KAAK,CAACS,MAAM,EAAE,EAAE;QACnD,IAAI,CAACD,WAAW,CAACH,OAAO,CAAC;MAC3B;IACF;IAEA,MAAMK,aAAa,GAAGd,IAAI,CAACe,OAAO,CAACC,MAAM,CAAC,CAACC,IAAI,EAAEC,SAAS,KAAK;MAC7D,MAAMC,MAAM,GAAGlB,MAAM,CAACS,QAAQ,CAACU,IAAI,CAACF,SAAS,CAAC;MAC9C,OAAOD,IAAI,CAACI,GAAG,CAACF,MAAM,CAACX,EAAE,EAAEW,MAAM,CAAC;IACpC,CAAC,EAAE,IAAIzB,UAAU,EAAE,CAAC;IAEpB,KAAK,MAAM4B,SAAS,IAAIC,MAAM,CAACV,MAAM,CAACb,IAAI,CAACwB,OAAO,CAAC,EAAE;MACnD;MACA,MAAML,MAAM,GAAGlB,MAAM,CAACS,QAAQ,CAACN,KAAK,CAACC,GAAG,CAACiB,SAAS,CAACd,EAAE,CAAC;MACtD,IAAIW,MAAM,EAAE;QACVA,MAAM,CAACK,OAAO,CAACJ,IAAI,CAACE,SAAS,CAAC;MAChC;IACF;;IAEA;AACJ;AACA;AACA;AACA;AACA;IACIrB,MAAM,CAACwB,IAAI,CAAC5B,MAAM,CAAC6B,cAAc,EAAEZ,aAAa,EAAEZ,KAAK,CAAC;IAExD,OAAO;MACLY;IACF,CAAC;EACH;EAEAF,WAAW,CAACH,OAAO,EAAE;IACnBA,OAAO,CAACM,OAAO,EAAEX,KAAK,CAACuB,OAAO,CAACR,MAAM,IAAI;MACvC,IAAI,CAACA,MAAM,CAACS,QAAQ,EAAE;QACpB,IAAI,CAAC3B,MAAM,CAACS,QAAQ,CAACmB,OAAO,CAACV,MAAM,CAACX,EAAE,CAAC;MACzC;IACF,CAAC,CAAC;EACJ;AACF;AAEAsB,MAAM,CAACC,OAAO,GAAGjC,oBAAoB"},"metadata":{},"sourceType":"script","externalDependencies":[]}