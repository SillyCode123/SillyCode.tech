{"ast":null,"code":"'use strict';\n\nconst {\n  Collection\n} = require('@discordjs/collection');\nconst {\n  makeURLSearchParams\n} = require('@discordjs/rest');\nconst {\n  Routes\n} = require('discord-api-types/v10');\nconst CachedManager = require('./CachedManager');\nconst {\n  DiscordjsTypeError,\n  ErrorCodes\n} = require('../errors');\nconst ThreadChannel = require('../structures/ThreadChannel');\n\n/**\n * Manages API methods for thread-based channels and stores their cache.\n * @extends {CachedManager}\n */\nclass ThreadManager extends CachedManager {\n  constructor(channel, iterable) {\n    super(channel.client, ThreadChannel, iterable);\n\n    /**\n     * The channel this Manager belongs to\n     * @type {TextChannel|NewsChannel|ForumChannel}\n     */\n    this.channel = channel;\n  }\n\n  /**\n   * Data that can be resolved to a Thread Channel object. This can be:\n   * * A ThreadChannel object\n   * * A Snowflake\n   * @typedef {ThreadChannel|Snowflake} ThreadChannelResolvable\n   */\n\n  /**\n   * The cache of this Manager\n   * @type {Collection<Snowflake, ThreadChannel>}\n   * @name ThreadManager#cache\n   */\n\n  _add(thread) {\n    const existing = this.cache.get(thread.id);\n    if (existing) return existing;\n    this.cache.set(thread.id, thread);\n    return thread;\n  }\n\n  /**\n   * Resolves a {@link ThreadChannelResolvable} to a {@link ThreadChannel} object.\n   * @method resolve\n   * @memberof ThreadManager\n   * @instance\n   * @param {ThreadChannelResolvable} thread The ThreadChannel resolvable to resolve\n   * @returns {?ThreadChannel}\n   */\n\n  /**\n   * Resolves a {@link ThreadChannelResolvable} to a {@link ThreadChannel} id.\n   * @method resolveId\n   * @memberof ThreadManager\n   * @instance\n   * @param {ThreadChannelResolvable} thread The ThreadChannel resolvable to resolve\n   * @returns {?Snowflake}\n   */\n\n  /**\n   * Options for creating a thread. <warn>Only one of `startMessage` or `type` can be defined.</warn>\n   * @typedef {StartThreadOptions} ThreadCreateOptions\n   * @property {MessageResolvable} [startMessage] The message to start a thread from. <warn>If this is defined then type\n   * of thread gets automatically defined and cannot be changed. The provided `type` field will be ignored</warn>\n   * @property {ChannelType.AnnouncementThread|ChannelType.PublicThread|ChannelType.PrivateThread} [type]\n   * The type of thread to create.\n   * Defaults to {@link ChannelType.PublicThread} if created in a {@link TextChannel}\n   * <warn>When creating threads in a {@link NewsChannel} this is ignored and is always\n   * {@link ChannelType.AnnouncementThread}</warn>\n   * @property {boolean} [invitable] Whether non-moderators can add other non-moderators to the thread\n   * <info>Can only be set when type will be {@link ChannelType.PrivateThread}</info>\n   */\n\n  /**\n   * The options for fetching multiple threads, the properties are mutually exclusive\n   * @typedef {Object} FetchThreadsOptions\n   * @property {FetchArchivedThreadOptions} [archived] The options used to fetch archived threads\n   * @property {boolean} [active] When true, fetches active threads. <warn>If `archived` is set, this is ignored!</warn>\n   */\n\n  /**\n   * Obtains a thread from Discord, or the channel cache if it's already available.\n   * @param {ThreadChannelResolvable|FetchThreadsOptions} [options] The options to fetch threads. If it is a\n   * ThreadChannelResolvable then the specified thread will be fetched. Fetches all active threads if `undefined`\n   * @param {BaseFetchOptions} [cacheOptions] Additional options for this fetch. <warn>The `force` field gets ignored\n   * if `options` is not a {@link ThreadChannelResolvable}</warn>\n   * @returns {Promise<?(ThreadChannel|FetchedThreads)>}\n   * @example\n   * // Fetch a thread by its id\n   * channel.threads.fetch('831955138126104859')\n   *   .then(channel => console.log(channel.name))\n   *   .catch(console.error);\n   */\n  fetch(options) {\n    let {\n      cache = true,\n      force = false\n    } = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    if (!options) return this.fetchActive(cache);\n    const channel = this.client.channels.resolveId(options);\n    if (channel) return this.client.channels.fetch(channel, cache, force);\n    if (options.archived) {\n      return this.fetchArchived(options.archived, cache);\n    }\n    return this.fetchActive(cache);\n  }\n\n  /**\n   * Data that can be resolved to a Date object. This can be:\n   * * A Date object\n   * * A number representing a timestamp\n   * * An [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) string\n   * @typedef {Date|number|string} DateResolvable\n   */\n\n  /**\n   * The options used to fetch archived threads.\n   * @typedef {Object} FetchArchivedThreadOptions\n   * @property {string} [type='public'] The type of threads to fetch (`public` or `private`)\n   * @property {boolean} [fetchAll=false] Whether to fetch **all** archived threads when `type` is `private`\n   * <info>This property requires the {@link PermissionFlagsBits.ManageThreads} permission if `true`.</info>\n   * @property {DateResolvable|ThreadChannelResolvable} [before] Only return threads that were created before this Date\n   * or Snowflake\n   * <warn>Must be a {@link ThreadChannelResolvable} when `type` is `private` and `fetchAll` is `false`.</warn>\n   * @property {number} [limit] Maximum number of threads to return\n   */\n\n  /**\n   * The data returned from a thread fetch that returns multiple threads.\n   * @typedef {Object} FetchedThreads\n   * @property {Collection<Snowflake, ThreadChannel>} threads The threads that were fetched, with any members returned\n   * @property {?boolean} hasMore Whether there are potentially additional threads that require a subsequent call\n   */\n\n  /**\n   * Obtains a set of archived threads from Discord.\n   * <info>This method requires the {@link PermissionFlagsBits.ReadMessageHistory} permission\n   * in the parent channel.</info>\n   * @param {FetchArchivedThreadOptions} [options] The options to fetch archived threads\n   * @param {boolean} [cache=true] Whether to cache the new thread objects if they aren't already\n   * @returns {Promise<FetchedThreads>}\n   */\n  async fetchArchived() {\n    let {\n      type = 'public',\n      fetchAll = false,\n      before,\n      limit\n    } = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    let cache = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\n    let path = Routes.channelThreads(this.channel.id, type);\n    if (type === 'private' && !fetchAll) {\n      path = Routes.channelJoinedArchivedThreads(this.channel.id);\n    }\n    let timestamp;\n    let id;\n    const query = makeURLSearchParams({\n      limit\n    });\n    if (typeof before !== 'undefined') {\n      if (before instanceof ThreadChannel || /^\\d{16,19}$/.test(String(before))) {\n        id = this.resolveId(before);\n        timestamp = this.resolve(before)?.archivedAt?.toISOString();\n        const toUse = type === 'private' && !fetchAll ? id : timestamp;\n        if (toUse) {\n          query.set('before', toUse);\n        }\n      } else {\n        try {\n          timestamp = new Date(before).toISOString();\n          if (type === 'public' || fetchAll) {\n            query.set('before', timestamp);\n          }\n        } catch {\n          throw new DiscordjsTypeError(ErrorCodes.InvalidType, 'before', 'DateResolvable or ThreadChannelResolvable');\n        }\n      }\n    }\n    const raw = await this.client.rest.get(path, {\n      query\n    });\n    return this.constructor._mapThreads(raw, this.client, {\n      parent: this.channel,\n      cache\n    });\n  }\n\n  /**\n   * Obtains the accessible active threads from Discord.\n   * <info>This method requires the {@link PermissionFlagsBits.ReadMessageHistory} permission\n   * in the parent channel.</info>\n   * @param {boolean} [cache=true] Whether to cache the new thread objects if they aren't already\n   * @returns {Promise<FetchedThreads>}\n   */\n  async fetchActive() {\n    let cache = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;\n    const raw = await this.client.rest.get(Routes.guildActiveThreads(this.channel.guild.id));\n    return this.constructor._mapThreads(raw, this.client, {\n      parent: this.channel,\n      cache\n    });\n  }\n  static _mapThreads(rawThreads, client, _ref) {\n    let {\n      parent,\n      guild,\n      cache\n    } = _ref;\n    const threads = rawThreads.threads.reduce((coll, raw) => {\n      const thread = client.channels._add(raw, guild ?? parent?.guild, {\n        cache\n      });\n      if (parent && thread.parentId !== parent.id) return coll;\n      return coll.set(thread.id, thread);\n    }, new Collection());\n    // Discord sends the thread id as id in this object\n    for (const rawMember of rawThreads.members) client.channels.cache.get(rawMember.id)?.members._add(rawMember);\n    return {\n      threads,\n      hasMore: rawThreads.has_more ?? false\n    };\n  }\n}\nmodule.exports = ThreadManager;","map":{"version":3,"names":["Collection","require","makeURLSearchParams","Routes","CachedManager","DiscordjsTypeError","ErrorCodes","ThreadChannel","ThreadManager","constructor","channel","iterable","client","_add","thread","existing","cache","get","id","set","fetch","options","force","fetchActive","channels","resolveId","archived","fetchArchived","type","fetchAll","before","limit","path","channelThreads","channelJoinedArchivedThreads","timestamp","query","test","String","resolve","archivedAt","toISOString","toUse","Date","InvalidType","raw","rest","_mapThreads","parent","guildActiveThreads","guild","rawThreads","threads","reduce","coll","parentId","rawMember","members","hasMore","has_more","module","exports"],"sources":["J:/Coding/Projekts/Web/JavaScript/sillcode.tech/node_modules/discord.js/src/managers/ThreadManager.js"],"sourcesContent":["'use strict';\n\nconst { Collection } = require('@discordjs/collection');\nconst { makeURLSearchParams } = require('@discordjs/rest');\nconst { Routes } = require('discord-api-types/v10');\nconst CachedManager = require('./CachedManager');\nconst { DiscordjsTypeError, ErrorCodes } = require('../errors');\nconst ThreadChannel = require('../structures/ThreadChannel');\n\n/**\n * Manages API methods for thread-based channels and stores their cache.\n * @extends {CachedManager}\n */\nclass ThreadManager extends CachedManager {\n  constructor(channel, iterable) {\n    super(channel.client, ThreadChannel, iterable);\n\n    /**\n     * The channel this Manager belongs to\n     * @type {TextChannel|NewsChannel|ForumChannel}\n     */\n    this.channel = channel;\n  }\n\n  /**\n   * Data that can be resolved to a Thread Channel object. This can be:\n   * * A ThreadChannel object\n   * * A Snowflake\n   * @typedef {ThreadChannel|Snowflake} ThreadChannelResolvable\n   */\n\n  /**\n   * The cache of this Manager\n   * @type {Collection<Snowflake, ThreadChannel>}\n   * @name ThreadManager#cache\n   */\n\n  _add(thread) {\n    const existing = this.cache.get(thread.id);\n    if (existing) return existing;\n    this.cache.set(thread.id, thread);\n    return thread;\n  }\n\n  /**\n   * Resolves a {@link ThreadChannelResolvable} to a {@link ThreadChannel} object.\n   * @method resolve\n   * @memberof ThreadManager\n   * @instance\n   * @param {ThreadChannelResolvable} thread The ThreadChannel resolvable to resolve\n   * @returns {?ThreadChannel}\n   */\n\n  /**\n   * Resolves a {@link ThreadChannelResolvable} to a {@link ThreadChannel} id.\n   * @method resolveId\n   * @memberof ThreadManager\n   * @instance\n   * @param {ThreadChannelResolvable} thread The ThreadChannel resolvable to resolve\n   * @returns {?Snowflake}\n   */\n\n  /**\n   * Options for creating a thread. <warn>Only one of `startMessage` or `type` can be defined.</warn>\n   * @typedef {StartThreadOptions} ThreadCreateOptions\n   * @property {MessageResolvable} [startMessage] The message to start a thread from. <warn>If this is defined then type\n   * of thread gets automatically defined and cannot be changed. The provided `type` field will be ignored</warn>\n   * @property {ChannelType.AnnouncementThread|ChannelType.PublicThread|ChannelType.PrivateThread} [type]\n   * The type of thread to create.\n   * Defaults to {@link ChannelType.PublicThread} if created in a {@link TextChannel}\n   * <warn>When creating threads in a {@link NewsChannel} this is ignored and is always\n   * {@link ChannelType.AnnouncementThread}</warn>\n   * @property {boolean} [invitable] Whether non-moderators can add other non-moderators to the thread\n   * <info>Can only be set when type will be {@link ChannelType.PrivateThread}</info>\n   */\n\n  /**\n   * The options for fetching multiple threads, the properties are mutually exclusive\n   * @typedef {Object} FetchThreadsOptions\n   * @property {FetchArchivedThreadOptions} [archived] The options used to fetch archived threads\n   * @property {boolean} [active] When true, fetches active threads. <warn>If `archived` is set, this is ignored!</warn>\n   */\n\n  /**\n   * Obtains a thread from Discord, or the channel cache if it's already available.\n   * @param {ThreadChannelResolvable|FetchThreadsOptions} [options] The options to fetch threads. If it is a\n   * ThreadChannelResolvable then the specified thread will be fetched. Fetches all active threads if `undefined`\n   * @param {BaseFetchOptions} [cacheOptions] Additional options for this fetch. <warn>The `force` field gets ignored\n   * if `options` is not a {@link ThreadChannelResolvable}</warn>\n   * @returns {Promise<?(ThreadChannel|FetchedThreads)>}\n   * @example\n   * // Fetch a thread by its id\n   * channel.threads.fetch('831955138126104859')\n   *   .then(channel => console.log(channel.name))\n   *   .catch(console.error);\n   */\n  fetch(options, { cache = true, force = false } = {}) {\n    if (!options) return this.fetchActive(cache);\n    const channel = this.client.channels.resolveId(options);\n    if (channel) return this.client.channels.fetch(channel, cache, force);\n    if (options.archived) {\n      return this.fetchArchived(options.archived, cache);\n    }\n    return this.fetchActive(cache);\n  }\n\n  /**\n   * Data that can be resolved to a Date object. This can be:\n   * * A Date object\n   * * A number representing a timestamp\n   * * An [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) string\n   * @typedef {Date|number|string} DateResolvable\n   */\n\n  /**\n   * The options used to fetch archived threads.\n   * @typedef {Object} FetchArchivedThreadOptions\n   * @property {string} [type='public'] The type of threads to fetch (`public` or `private`)\n   * @property {boolean} [fetchAll=false] Whether to fetch **all** archived threads when `type` is `private`\n   * <info>This property requires the {@link PermissionFlagsBits.ManageThreads} permission if `true`.</info>\n   * @property {DateResolvable|ThreadChannelResolvable} [before] Only return threads that were created before this Date\n   * or Snowflake\n   * <warn>Must be a {@link ThreadChannelResolvable} when `type` is `private` and `fetchAll` is `false`.</warn>\n   * @property {number} [limit] Maximum number of threads to return\n   */\n\n  /**\n   * The data returned from a thread fetch that returns multiple threads.\n   * @typedef {Object} FetchedThreads\n   * @property {Collection<Snowflake, ThreadChannel>} threads The threads that were fetched, with any members returned\n   * @property {?boolean} hasMore Whether there are potentially additional threads that require a subsequent call\n   */\n\n  /**\n   * Obtains a set of archived threads from Discord.\n   * <info>This method requires the {@link PermissionFlagsBits.ReadMessageHistory} permission\n   * in the parent channel.</info>\n   * @param {FetchArchivedThreadOptions} [options] The options to fetch archived threads\n   * @param {boolean} [cache=true] Whether to cache the new thread objects if they aren't already\n   * @returns {Promise<FetchedThreads>}\n   */\n  async fetchArchived({ type = 'public', fetchAll = false, before, limit } = {}, cache = true) {\n    let path = Routes.channelThreads(this.channel.id, type);\n    if (type === 'private' && !fetchAll) {\n      path = Routes.channelJoinedArchivedThreads(this.channel.id);\n    }\n    let timestamp;\n    let id;\n    const query = makeURLSearchParams({ limit });\n    if (typeof before !== 'undefined') {\n      if (before instanceof ThreadChannel || /^\\d{16,19}$/.test(String(before))) {\n        id = this.resolveId(before);\n        timestamp = this.resolve(before)?.archivedAt?.toISOString();\n        const toUse = type === 'private' && !fetchAll ? id : timestamp;\n        if (toUse) {\n          query.set('before', toUse);\n        }\n      } else {\n        try {\n          timestamp = new Date(before).toISOString();\n          if (type === 'public' || fetchAll) {\n            query.set('before', timestamp);\n          }\n        } catch {\n          throw new DiscordjsTypeError(ErrorCodes.InvalidType, 'before', 'DateResolvable or ThreadChannelResolvable');\n        }\n      }\n    }\n\n    const raw = await this.client.rest.get(path, { query });\n    return this.constructor._mapThreads(raw, this.client, { parent: this.channel, cache });\n  }\n\n  /**\n   * Obtains the accessible active threads from Discord.\n   * <info>This method requires the {@link PermissionFlagsBits.ReadMessageHistory} permission\n   * in the parent channel.</info>\n   * @param {boolean} [cache=true] Whether to cache the new thread objects if they aren't already\n   * @returns {Promise<FetchedThreads>}\n   */\n  async fetchActive(cache = true) {\n    const raw = await this.client.rest.get(Routes.guildActiveThreads(this.channel.guild.id));\n    return this.constructor._mapThreads(raw, this.client, { parent: this.channel, cache });\n  }\n\n  static _mapThreads(rawThreads, client, { parent, guild, cache }) {\n    const threads = rawThreads.threads.reduce((coll, raw) => {\n      const thread = client.channels._add(raw, guild ?? parent?.guild, { cache });\n      if (parent && thread.parentId !== parent.id) return coll;\n      return coll.set(thread.id, thread);\n    }, new Collection());\n    // Discord sends the thread id as id in this object\n    for (const rawMember of rawThreads.members) client.channels.cache.get(rawMember.id)?.members._add(rawMember);\n    return {\n      threads,\n      hasMore: rawThreads.has_more ?? false,\n    };\n  }\n}\n\nmodule.exports = ThreadManager;\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}