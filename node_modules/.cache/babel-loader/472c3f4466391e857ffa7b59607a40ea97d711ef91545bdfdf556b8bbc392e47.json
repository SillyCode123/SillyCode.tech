{"ast":null,"code":"'use strict';\n\nconst {\n  Collection\n} = require('@discordjs/collection');\nconst {\n  makeURLSearchParams\n} = require('@discordjs/rest');\nconst {\n  Routes\n} = require('discord-api-types/v10');\nconst CachedManager = require('./CachedManager');\nconst {\n  DiscordjsTypeError,\n  ErrorCodes\n} = require('../errors');\nconst {\n  Message\n} = require('../structures/Message');\nconst MessagePayload = require('../structures/MessagePayload');\nconst {\n  resolvePartialEmoji\n} = require('../util/Util');\n\n/**\n * Manages API methods for Messages and holds their cache.\n * @extends {CachedManager}\n */\nclass MessageManager extends CachedManager {\n  constructor(channel, iterable) {\n    super(channel.client, Message, iterable);\n\n    /**\n     * The channel that the messages belong to\n     * @type {TextBasedChannels}\n     */\n    this.channel = channel;\n  }\n\n  /**\n   * The cache of Messages\n   * @type {Collection<Snowflake, Message>}\n   * @name MessageManager#cache\n   */\n\n  _add(data, cache) {\n    return super._add(data, cache);\n  }\n\n  /**\n   * Data that can be resolved to a Message object. This can be:\n   * * A Message\n   * * A Snowflake\n   * @typedef {Message|Snowflake} MessageResolvable\n   */\n\n  /**\n   * Options used to fetch a message.\n   * @typedef {BaseFetchOptions} FetchMessageOptions\n   * @property {MessageResolvable} message The message to fetch\n   */\n\n  /**\n   * Options used to fetch multiple messages.\n   * @typedef {Object} FetchMessagesOptions\n   * @property {number} [limit] The maximum number of messages to return\n   * @property {Snowflake} [before] Consider only messages before this id\n   * @property {Snowflake} [after] Consider only messages after this id\n   * @property {Snowflake} [around] Consider only messages around this id\n   * @property {boolean} [cache] Whether to cache the fetched messages\n   */\n\n  /**\n   * Fetches message(s) from a channel.\n   * <info>The returned Collection does not contain reaction users of the messages if they were not cached.\n   * Those need to be fetched separately in such a case.</info>\n   * @param {MessageResolvable|FetchMessageOptions|FetchMessagesOptions} [options] Options for fetching message(s)\n   * @returns {Promise<Message|Collection<Snowflake, Message>>}\n   * @example\n   * // Fetch a message\n   * channel.messages.fetch('99539446449315840')\n   *   .then(message => console.log(message.content))\n   *   .catch(console.error);\n   * @example\n   * // Fetch a maximum of 10 messages without caching\n   * channel.messages.fetch({ limit: 10, cache: false })\n   *   .then(messages => console.log(`Received ${messages.size} messages`))\n   *   .catch(console.error);\n   * @example\n   * // Fetch a maximum of 10 messages without caching around a message id\n   * channel.messages.fetch({ limit: 10, cache: false, around: '99539446449315840' })\n   *   .then(messages => console.log(`Received ${messages.size} messages`))\n   *   .catch(console.error);\n   * @example\n   * // Fetch messages and filter by a user id\n   * channel.messages.fetch()\n   *   .then(messages => console.log(`${messages.filter(m => m.author.id === '84484653687267328').size} messages`))\n   *   .catch(console.error);\n   */\n  fetch(options) {\n    if (!options) return this._fetchMany();\n    const {\n      message,\n      cache,\n      force\n    } = options;\n    const resolvedMessage = this.resolveId(message ?? options);\n    if (resolvedMessage) return this._fetchSingle({\n      message: resolvedMessage,\n      cache,\n      force\n    });\n    return this._fetchMany(options);\n  }\n  async _fetchSingle(_ref) {\n    let {\n      message,\n      cache,\n      force = false\n    } = _ref;\n    if (!force) {\n      const existing = this.cache.get(message);\n      if (existing && !existing.partial) return existing;\n    }\n    const data = await this.client.rest.get(Routes.channelMessage(this.channel.id, message));\n    return this._add(data, cache);\n  }\n  async _fetchMany() {\n    let options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    const data = await this.client.rest.get(Routes.channelMessages(this.channel.id), {\n      query: makeURLSearchParams(options)\n    });\n    return data.reduce((_data, message) => _data.set(message.id, this._add(message, options.cache)), new Collection());\n  }\n\n  /**\n   * Fetches the pinned messages of this channel and returns a collection of them.\n   * <info>The returned Collection does not contain any reaction data of the messages.\n   * Those need to be fetched separately.</info>\n   * @param {boolean} [cache=true] Whether to cache the message(s)\n   * @returns {Promise<Collection<Snowflake, Message>>}\n   * @example\n   * // Get pinned messages\n   * channel.messages.fetchPinned()\n   *   .then(messages => console.log(`Received ${messages.size} messages`))\n   *   .catch(console.error);\n   */\n  async fetchPinned() {\n    let cache = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;\n    const data = await this.client.rest.get(Routes.channelPins(this.channel.id));\n    const messages = new Collection();\n    for (const message of data) messages.set(message.id, this._add(message, cache));\n    return messages;\n  }\n\n  /**\n   * Resolves a {@link MessageResolvable} to a {@link Message} object.\n   * @method resolve\n   * @memberof MessageManager\n   * @instance\n   * @param {MessageResolvable} message The message resolvable to resolve\n   * @returns {?Message}\n   */\n\n  /**\n   * Resolves a {@link MessageResolvable} to a {@link Message} id.\n   * @method resolveId\n   * @memberof MessageManager\n   * @instance\n   * @param {MessageResolvable} message The message resolvable to resolve\n   * @returns {?Snowflake}\n   */\n\n  /**\n   * Options that can be passed to edit a message.\n   * @typedef {BaseMessageOptions} MessageEditOptions\n   * @property {Array<JSONEncodable<AttachmentPayload>>} [attachments] An array of attachments to keep,\n   * all attachments will be kept if omitted\n   * @property {MessageFlags} [flags] Which flags to set for the message\n   * <info>Only the {@link MessageFlags.SuppressEmbeds} flag can be modified.</info>\n   */\n\n  /**\n   * Edits a message, even if it's not cached.\n   * @param {MessageResolvable} message The message to edit\n   * @param {string|MessageEditOptions|MessagePayload} options The options to edit the message\n   * @returns {Promise<Message>}\n   */\n  async edit(message, options) {\n    const messageId = this.resolveId(message);\n    if (!messageId) throw new DiscordjsTypeError(ErrorCodes.InvalidType, 'message', 'MessageResolvable');\n    const {\n      body,\n      files\n    } = await (options instanceof MessagePayload ? options : MessagePayload.create(message instanceof Message ? message : this, options)).resolveBody().resolveFiles();\n    const d = await this.client.rest.patch(Routes.channelMessage(this.channel.id, messageId), {\n      body,\n      files\n    });\n    const existing = this.cache.get(messageId);\n    if (existing) {\n      const clone = existing._clone();\n      clone._patch(d);\n      return clone;\n    }\n    return this._add(d);\n  }\n\n  /**\n   * Publishes a message in an announcement channel to all channels following it, even if it's not cached.\n   * @param {MessageResolvable} message The message to publish\n   * @returns {Promise<Message>}\n   */\n  async crosspost(message) {\n    message = this.resolveId(message);\n    if (!message) throw new DiscordjsTypeError(ErrorCodes.InvalidType, 'message', 'MessageResolvable');\n    const data = await this.client.rest.post(Routes.channelMessageCrosspost(this.channel.id, message));\n    return this.cache.get(data.id) ?? this._add(data);\n  }\n\n  /**\n   * Pins a message to the channel's pinned messages, even if it's not cached.\n   * @param {MessageResolvable} message The message to pin\n   * @param {string} [reason] Reason for pinning\n   * @returns {Promise<void>}\n   */\n  async pin(message, reason) {\n    message = this.resolveId(message);\n    if (!message) throw new DiscordjsTypeError(ErrorCodes.InvalidType, 'message', 'MessageResolvable');\n    await this.client.rest.put(Routes.channelPin(this.channel.id, message), {\n      reason\n    });\n  }\n\n  /**\n   * Unpins a message from the channel's pinned messages, even if it's not cached.\n   * @param {MessageResolvable} message The message to unpin\n   * @param {string} [reason] Reason for unpinning\n   * @returns {Promise<void>}\n   */\n  async unpin(message, reason) {\n    message = this.resolveId(message);\n    if (!message) throw new DiscordjsTypeError(ErrorCodes.InvalidType, 'message', 'MessageResolvable');\n    await this.client.rest.delete(Routes.channelPin(this.channel.id, message), {\n      reason\n    });\n  }\n\n  /**\n   * Adds a reaction to a message, even if it's not cached.\n   * @param {MessageResolvable} message The message to react to\n   * @param {EmojiIdentifierResolvable} emoji The emoji to react with\n   * @returns {Promise<void>}\n   */\n  async react(message, emoji) {\n    message = this.resolveId(message);\n    if (!message) throw new DiscordjsTypeError(ErrorCodes.InvalidType, 'message', 'MessageResolvable');\n    emoji = resolvePartialEmoji(emoji);\n    if (!emoji) throw new DiscordjsTypeError(ErrorCodes.EmojiType, 'emoji', 'EmojiIdentifierResolvable');\n    const emojiId = emoji.id ? `${emoji.animated ? 'a:' : ''}${emoji.name}:${emoji.id}` : encodeURIComponent(emoji.name);\n    await this.client.rest.put(Routes.channelMessageOwnReaction(this.channel.id, message, emojiId));\n  }\n\n  /**\n   * Deletes a message, even if it's not cached.\n   * @param {MessageResolvable} message The message to delete\n   * @returns {Promise<void>}\n   */\n  async delete(message) {\n    message = this.resolveId(message);\n    if (!message) throw new DiscordjsTypeError(ErrorCodes.InvalidType, 'message', 'MessageResolvable');\n    await this.client.rest.delete(Routes.channelMessage(this.channel.id, message));\n  }\n}\nmodule.exports = MessageManager;","map":{"version":3,"names":["Collection","require","makeURLSearchParams","Routes","CachedManager","DiscordjsTypeError","ErrorCodes","Message","MessagePayload","resolvePartialEmoji","MessageManager","constructor","channel","iterable","client","_add","data","cache","fetch","options","_fetchMany","message","force","resolvedMessage","resolveId","_fetchSingle","existing","get","partial","rest","channelMessage","id","channelMessages","query","reduce","_data","set","fetchPinned","channelPins","messages","edit","messageId","InvalidType","body","files","create","resolveBody","resolveFiles","d","patch","clone","_clone","_patch","crosspost","post","channelMessageCrosspost","pin","reason","put","channelPin","unpin","delete","react","emoji","EmojiType","emojiId","animated","name","encodeURIComponent","channelMessageOwnReaction","module","exports"],"sources":["J:/Coding/Projekts/Web/JavaScript/sillcode.tech/node_modules/discord.js/src/managers/MessageManager.js"],"sourcesContent":["'use strict';\n\nconst { Collection } = require('@discordjs/collection');\nconst { makeURLSearchParams } = require('@discordjs/rest');\nconst { Routes } = require('discord-api-types/v10');\nconst CachedManager = require('./CachedManager');\nconst { DiscordjsTypeError, ErrorCodes } = require('../errors');\nconst { Message } = require('../structures/Message');\nconst MessagePayload = require('../structures/MessagePayload');\nconst { resolvePartialEmoji } = require('../util/Util');\n\n/**\n * Manages API methods for Messages and holds their cache.\n * @extends {CachedManager}\n */\nclass MessageManager extends CachedManager {\n  constructor(channel, iterable) {\n    super(channel.client, Message, iterable);\n\n    /**\n     * The channel that the messages belong to\n     * @type {TextBasedChannels}\n     */\n    this.channel = channel;\n  }\n\n  /**\n   * The cache of Messages\n   * @type {Collection<Snowflake, Message>}\n   * @name MessageManager#cache\n   */\n\n  _add(data, cache) {\n    return super._add(data, cache);\n  }\n\n  /**\n   * Data that can be resolved to a Message object. This can be:\n   * * A Message\n   * * A Snowflake\n   * @typedef {Message|Snowflake} MessageResolvable\n   */\n\n  /**\n   * Options used to fetch a message.\n   * @typedef {BaseFetchOptions} FetchMessageOptions\n   * @property {MessageResolvable} message The message to fetch\n   */\n\n  /**\n   * Options used to fetch multiple messages.\n   * @typedef {Object} FetchMessagesOptions\n   * @property {number} [limit] The maximum number of messages to return\n   * @property {Snowflake} [before] Consider only messages before this id\n   * @property {Snowflake} [after] Consider only messages after this id\n   * @property {Snowflake} [around] Consider only messages around this id\n   * @property {boolean} [cache] Whether to cache the fetched messages\n   */\n\n  /**\n   * Fetches message(s) from a channel.\n   * <info>The returned Collection does not contain reaction users of the messages if they were not cached.\n   * Those need to be fetched separately in such a case.</info>\n   * @param {MessageResolvable|FetchMessageOptions|FetchMessagesOptions} [options] Options for fetching message(s)\n   * @returns {Promise<Message|Collection<Snowflake, Message>>}\n   * @example\n   * // Fetch a message\n   * channel.messages.fetch('99539446449315840')\n   *   .then(message => console.log(message.content))\n   *   .catch(console.error);\n   * @example\n   * // Fetch a maximum of 10 messages without caching\n   * channel.messages.fetch({ limit: 10, cache: false })\n   *   .then(messages => console.log(`Received ${messages.size} messages`))\n   *   .catch(console.error);\n   * @example\n   * // Fetch a maximum of 10 messages without caching around a message id\n   * channel.messages.fetch({ limit: 10, cache: false, around: '99539446449315840' })\n   *   .then(messages => console.log(`Received ${messages.size} messages`))\n   *   .catch(console.error);\n   * @example\n   * // Fetch messages and filter by a user id\n   * channel.messages.fetch()\n   *   .then(messages => console.log(`${messages.filter(m => m.author.id === '84484653687267328').size} messages`))\n   *   .catch(console.error);\n   */\n  fetch(options) {\n    if (!options) return this._fetchMany();\n    const { message, cache, force } = options;\n    const resolvedMessage = this.resolveId(message ?? options);\n    if (resolvedMessage) return this._fetchSingle({ message: resolvedMessage, cache, force });\n    return this._fetchMany(options);\n  }\n\n  async _fetchSingle({ message, cache, force = false }) {\n    if (!force) {\n      const existing = this.cache.get(message);\n      if (existing && !existing.partial) return existing;\n    }\n\n    const data = await this.client.rest.get(Routes.channelMessage(this.channel.id, message));\n    return this._add(data, cache);\n  }\n\n  async _fetchMany(options = {}) {\n    const data = await this.client.rest.get(Routes.channelMessages(this.channel.id), {\n      query: makeURLSearchParams(options),\n    });\n\n    return data.reduce((_data, message) => _data.set(message.id, this._add(message, options.cache)), new Collection());\n  }\n\n  /**\n   * Fetches the pinned messages of this channel and returns a collection of them.\n   * <info>The returned Collection does not contain any reaction data of the messages.\n   * Those need to be fetched separately.</info>\n   * @param {boolean} [cache=true] Whether to cache the message(s)\n   * @returns {Promise<Collection<Snowflake, Message>>}\n   * @example\n   * // Get pinned messages\n   * channel.messages.fetchPinned()\n   *   .then(messages => console.log(`Received ${messages.size} messages`))\n   *   .catch(console.error);\n   */\n  async fetchPinned(cache = true) {\n    const data = await this.client.rest.get(Routes.channelPins(this.channel.id));\n    const messages = new Collection();\n    for (const message of data) messages.set(message.id, this._add(message, cache));\n    return messages;\n  }\n\n  /**\n   * Resolves a {@link MessageResolvable} to a {@link Message} object.\n   * @method resolve\n   * @memberof MessageManager\n   * @instance\n   * @param {MessageResolvable} message The message resolvable to resolve\n   * @returns {?Message}\n   */\n\n  /**\n   * Resolves a {@link MessageResolvable} to a {@link Message} id.\n   * @method resolveId\n   * @memberof MessageManager\n   * @instance\n   * @param {MessageResolvable} message The message resolvable to resolve\n   * @returns {?Snowflake}\n   */\n\n  /**\n   * Options that can be passed to edit a message.\n   * @typedef {BaseMessageOptions} MessageEditOptions\n   * @property {Array<JSONEncodable<AttachmentPayload>>} [attachments] An array of attachments to keep,\n   * all attachments will be kept if omitted\n   * @property {MessageFlags} [flags] Which flags to set for the message\n   * <info>Only the {@link MessageFlags.SuppressEmbeds} flag can be modified.</info>\n   */\n\n  /**\n   * Edits a message, even if it's not cached.\n   * @param {MessageResolvable} message The message to edit\n   * @param {string|MessageEditOptions|MessagePayload} options The options to edit the message\n   * @returns {Promise<Message>}\n   */\n  async edit(message, options) {\n    const messageId = this.resolveId(message);\n    if (!messageId) throw new DiscordjsTypeError(ErrorCodes.InvalidType, 'message', 'MessageResolvable');\n\n    const { body, files } = await (options instanceof MessagePayload\n      ? options\n      : MessagePayload.create(message instanceof Message ? message : this, options)\n    )\n      .resolveBody()\n      .resolveFiles();\n    const d = await this.client.rest.patch(Routes.channelMessage(this.channel.id, messageId), { body, files });\n\n    const existing = this.cache.get(messageId);\n    if (existing) {\n      const clone = existing._clone();\n      clone._patch(d);\n      return clone;\n    }\n    return this._add(d);\n  }\n\n  /**\n   * Publishes a message in an announcement channel to all channels following it, even if it's not cached.\n   * @param {MessageResolvable} message The message to publish\n   * @returns {Promise<Message>}\n   */\n  async crosspost(message) {\n    message = this.resolveId(message);\n    if (!message) throw new DiscordjsTypeError(ErrorCodes.InvalidType, 'message', 'MessageResolvable');\n\n    const data = await this.client.rest.post(Routes.channelMessageCrosspost(this.channel.id, message));\n    return this.cache.get(data.id) ?? this._add(data);\n  }\n\n  /**\n   * Pins a message to the channel's pinned messages, even if it's not cached.\n   * @param {MessageResolvable} message The message to pin\n   * @param {string} [reason] Reason for pinning\n   * @returns {Promise<void>}\n   */\n  async pin(message, reason) {\n    message = this.resolveId(message);\n    if (!message) throw new DiscordjsTypeError(ErrorCodes.InvalidType, 'message', 'MessageResolvable');\n\n    await this.client.rest.put(Routes.channelPin(this.channel.id, message), { reason });\n  }\n\n  /**\n   * Unpins a message from the channel's pinned messages, even if it's not cached.\n   * @param {MessageResolvable} message The message to unpin\n   * @param {string} [reason] Reason for unpinning\n   * @returns {Promise<void>}\n   */\n  async unpin(message, reason) {\n    message = this.resolveId(message);\n    if (!message) throw new DiscordjsTypeError(ErrorCodes.InvalidType, 'message', 'MessageResolvable');\n\n    await this.client.rest.delete(Routes.channelPin(this.channel.id, message), { reason });\n  }\n\n  /**\n   * Adds a reaction to a message, even if it's not cached.\n   * @param {MessageResolvable} message The message to react to\n   * @param {EmojiIdentifierResolvable} emoji The emoji to react with\n   * @returns {Promise<void>}\n   */\n  async react(message, emoji) {\n    message = this.resolveId(message);\n    if (!message) throw new DiscordjsTypeError(ErrorCodes.InvalidType, 'message', 'MessageResolvable');\n\n    emoji = resolvePartialEmoji(emoji);\n    if (!emoji) throw new DiscordjsTypeError(ErrorCodes.EmojiType, 'emoji', 'EmojiIdentifierResolvable');\n\n    const emojiId = emoji.id\n      ? `${emoji.animated ? 'a:' : ''}${emoji.name}:${emoji.id}`\n      : encodeURIComponent(emoji.name);\n\n    await this.client.rest.put(Routes.channelMessageOwnReaction(this.channel.id, message, emojiId));\n  }\n\n  /**\n   * Deletes a message, even if it's not cached.\n   * @param {MessageResolvable} message The message to delete\n   * @returns {Promise<void>}\n   */\n  async delete(message) {\n    message = this.resolveId(message);\n    if (!message) throw new DiscordjsTypeError(ErrorCodes.InvalidType, 'message', 'MessageResolvable');\n\n    await this.client.rest.delete(Routes.channelMessage(this.channel.id, message));\n  }\n}\n\nmodule.exports = MessageManager;\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}