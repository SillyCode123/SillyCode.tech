{"ast":null,"code":"'use strict';\n\nconst {\n  DiscordjsRangeError,\n  ErrorCodes\n} = require('../errors');\n\n/**\n * Data structure that makes it easy to interact with a bitfield.\n */\nclass BitField {\n  /**\n   * Numeric bitfield flags.\n   * <info>Defined in extension classes</info>\n   * @type {Object}\n   * @memberof BitField\n   * @abstract\n   */\n  static Flags = {};\n\n  /**\n   * @type {number|bigint}\n   * @memberof BitField\n   * @private\n   */\n  static DefaultBit = 0;\n\n  /**\n   * @param {BitFieldResolvable} [bits=this.constructor.DefaultBit] Bit(s) to read from\n   */\n  constructor() {\n    let bits = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.constructor.DefaultBit;\n    /**\n     * Bitfield of the packed bits\n     * @type {number|bigint}\n     */\n    this.bitfield = this.constructor.resolve(bits);\n  }\n\n  /**\n   * Checks whether the bitfield has a bit, or any of multiple bits.\n   * @param {BitFieldResolvable} bit Bit(s) to check for\n   * @returns {boolean}\n   */\n  any(bit) {\n    return (this.bitfield & this.constructor.resolve(bit)) !== this.constructor.DefaultBit;\n  }\n\n  /**\n   * Checks if this bitfield equals another\n   * @param {BitFieldResolvable} bit Bit(s) to check for\n   * @returns {boolean}\n   */\n  equals(bit) {\n    return this.bitfield === this.constructor.resolve(bit);\n  }\n\n  /**\n   * Checks whether the bitfield has a bit, or multiple bits.\n   * @param {BitFieldResolvable} bit Bit(s) to check for\n   * @returns {boolean}\n   */\n  has(bit) {\n    bit = this.constructor.resolve(bit);\n    return (this.bitfield & bit) === bit;\n  }\n\n  /**\n   * Gets all given bits that are missing from the bitfield.\n   * @param {BitFieldResolvable} bits Bit(s) to check for\n   * @param {...*} hasParams Additional parameters for the has method, if any\n   * @returns {string[]}\n   */\n  missing(bits) {\n    for (var _len = arguments.length, hasParams = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n      hasParams[_key - 1] = arguments[_key];\n    }\n    return new this.constructor(bits).remove(this).toArray(...hasParams);\n  }\n\n  /**\n   * Freezes these bits, making them immutable.\n   * @returns {Readonly<BitField>}\n   */\n  freeze() {\n    return Object.freeze(this);\n  }\n\n  /**\n   * Adds bits to these ones.\n   * @param {...BitFieldResolvable} [bits] Bits to add\n   * @returns {BitField} These bits or new BitField if the instance is frozen.\n   */\n  add() {\n    let total = this.constructor.DefaultBit;\n    for (var _len2 = arguments.length, bits = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {\n      bits[_key2] = arguments[_key2];\n    }\n    for (const bit of bits) {\n      total |= this.constructor.resolve(bit);\n    }\n    if (Object.isFrozen(this)) return new this.constructor(this.bitfield | total);\n    this.bitfield |= total;\n    return this;\n  }\n\n  /**\n   * Removes bits from these.\n   * @param {...BitFieldResolvable} [bits] Bits to remove\n   * @returns {BitField} These bits or new BitField if the instance is frozen.\n   */\n  remove() {\n    let total = this.constructor.DefaultBit;\n    for (var _len3 = arguments.length, bits = new Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {\n      bits[_key3] = arguments[_key3];\n    }\n    for (const bit of bits) {\n      total |= this.constructor.resolve(bit);\n    }\n    if (Object.isFrozen(this)) return new this.constructor(this.bitfield & ~total);\n    this.bitfield &= ~total;\n    return this;\n  }\n\n  /**\n   * Gets an object mapping field names to a {@link boolean} indicating whether the\n   * bit is available.\n   * @param {...*} hasParams Additional parameters for the has method, if any\n   * @returns {Object}\n   */\n  serialize() {\n    const serialized = {};\n    for (var _len4 = arguments.length, hasParams = new Array(_len4), _key4 = 0; _key4 < _len4; _key4++) {\n      hasParams[_key4] = arguments[_key4];\n    }\n    for (const [flag, bit] of Object.entries(this.constructor.Flags)) serialized[flag] = this.has(bit, ...hasParams);\n    return serialized;\n  }\n\n  /**\n   * Gets an {@link Array} of bitfield names based on the bits available.\n   * @param {...*} hasParams Additional parameters for the has method, if any\n   * @returns {string[]}\n   */\n  toArray() {\n    for (var _len5 = arguments.length, hasParams = new Array(_len5), _key5 = 0; _key5 < _len5; _key5++) {\n      hasParams[_key5] = arguments[_key5];\n    }\n    return Object.keys(this.constructor.Flags).filter(bit => this.has(bit, ...hasParams));\n  }\n  toJSON() {\n    return typeof this.bitfield === 'number' ? this.bitfield : this.bitfield.toString();\n  }\n  valueOf() {\n    return this.bitfield;\n  }\n  *[Symbol.iterator]() {\n    yield* this.toArray();\n  }\n\n  /**\n   * Data that can be resolved to give a bitfield. This can be:\n   * * A bit number (this can be a number literal or a value taken from {@link BitField.Flags})\n   * * A string bit number\n   * * An instance of BitField\n   * * An Array of BitFieldResolvable\n   * @typedef {number|string|bigint|BitField|BitFieldResolvable[]} BitFieldResolvable\n   */\n\n  /**\n   * Resolves bitfields to their numeric form.\n   * @param {BitFieldResolvable} [bit] bit(s) to resolve\n   * @returns {number|bigint}\n   */\n  static resolve(bit) {\n    const {\n      DefaultBit\n    } = this;\n    if (typeof DefaultBit === typeof bit && bit >= DefaultBit) return bit;\n    if (bit instanceof BitField) return bit.bitfield;\n    if (Array.isArray(bit)) return bit.map(p => this.resolve(p)).reduce((prev, p) => prev | p, DefaultBit);\n    if (typeof bit === 'string') {\n      if (typeof this.Flags[bit] !== 'undefined') return this.Flags[bit];\n      if (!isNaN(bit)) return typeof DefaultBit === 'bigint' ? BigInt(bit) : Number(bit);\n    }\n    throw new DiscordjsRangeError(ErrorCodes.BitFieldInvalid, bit);\n  }\n}\nmodule.exports = BitField;","map":{"version":3,"names":["DiscordjsRangeError","ErrorCodes","require","BitField","Flags","DefaultBit","constructor","bits","bitfield","resolve","any","bit","equals","has","missing","hasParams","remove","toArray","freeze","Object","add","total","isFrozen","serialize","serialized","flag","entries","keys","filter","toJSON","toString","valueOf","Symbol","iterator","Array","isArray","map","p","reduce","prev","isNaN","BigInt","Number","BitFieldInvalid","module","exports"],"sources":["J:/Coding/Projekts/Web/JavaScript/sillcode.tech/node_modules/discord.js/src/util/BitField.js"],"sourcesContent":["'use strict';\n\nconst { DiscordjsRangeError, ErrorCodes } = require('../errors');\n\n/**\n * Data structure that makes it easy to interact with a bitfield.\n */\nclass BitField {\n  /**\n   * Numeric bitfield flags.\n   * <info>Defined in extension classes</info>\n   * @type {Object}\n   * @memberof BitField\n   * @abstract\n   */\n  static Flags = {};\n\n  /**\n   * @type {number|bigint}\n   * @memberof BitField\n   * @private\n   */\n  static DefaultBit = 0;\n\n  /**\n   * @param {BitFieldResolvable} [bits=this.constructor.DefaultBit] Bit(s) to read from\n   */\n  constructor(bits = this.constructor.DefaultBit) {\n    /**\n     * Bitfield of the packed bits\n     * @type {number|bigint}\n     */\n    this.bitfield = this.constructor.resolve(bits);\n  }\n\n  /**\n   * Checks whether the bitfield has a bit, or any of multiple bits.\n   * @param {BitFieldResolvable} bit Bit(s) to check for\n   * @returns {boolean}\n   */\n  any(bit) {\n    return (this.bitfield & this.constructor.resolve(bit)) !== this.constructor.DefaultBit;\n  }\n\n  /**\n   * Checks if this bitfield equals another\n   * @param {BitFieldResolvable} bit Bit(s) to check for\n   * @returns {boolean}\n   */\n  equals(bit) {\n    return this.bitfield === this.constructor.resolve(bit);\n  }\n\n  /**\n   * Checks whether the bitfield has a bit, or multiple bits.\n   * @param {BitFieldResolvable} bit Bit(s) to check for\n   * @returns {boolean}\n   */\n  has(bit) {\n    bit = this.constructor.resolve(bit);\n    return (this.bitfield & bit) === bit;\n  }\n\n  /**\n   * Gets all given bits that are missing from the bitfield.\n   * @param {BitFieldResolvable} bits Bit(s) to check for\n   * @param {...*} hasParams Additional parameters for the has method, if any\n   * @returns {string[]}\n   */\n  missing(bits, ...hasParams) {\n    return new this.constructor(bits).remove(this).toArray(...hasParams);\n  }\n\n  /**\n   * Freezes these bits, making them immutable.\n   * @returns {Readonly<BitField>}\n   */\n  freeze() {\n    return Object.freeze(this);\n  }\n\n  /**\n   * Adds bits to these ones.\n   * @param {...BitFieldResolvable} [bits] Bits to add\n   * @returns {BitField} These bits or new BitField if the instance is frozen.\n   */\n  add(...bits) {\n    let total = this.constructor.DefaultBit;\n    for (const bit of bits) {\n      total |= this.constructor.resolve(bit);\n    }\n    if (Object.isFrozen(this)) return new this.constructor(this.bitfield | total);\n    this.bitfield |= total;\n    return this;\n  }\n\n  /**\n   * Removes bits from these.\n   * @param {...BitFieldResolvable} [bits] Bits to remove\n   * @returns {BitField} These bits or new BitField if the instance is frozen.\n   */\n  remove(...bits) {\n    let total = this.constructor.DefaultBit;\n    for (const bit of bits) {\n      total |= this.constructor.resolve(bit);\n    }\n    if (Object.isFrozen(this)) return new this.constructor(this.bitfield & ~total);\n    this.bitfield &= ~total;\n    return this;\n  }\n\n  /**\n   * Gets an object mapping field names to a {@link boolean} indicating whether the\n   * bit is available.\n   * @param {...*} hasParams Additional parameters for the has method, if any\n   * @returns {Object}\n   */\n  serialize(...hasParams) {\n    const serialized = {};\n    for (const [flag, bit] of Object.entries(this.constructor.Flags)) serialized[flag] = this.has(bit, ...hasParams);\n    return serialized;\n  }\n\n  /**\n   * Gets an {@link Array} of bitfield names based on the bits available.\n   * @param {...*} hasParams Additional parameters for the has method, if any\n   * @returns {string[]}\n   */\n  toArray(...hasParams) {\n    return Object.keys(this.constructor.Flags).filter(bit => this.has(bit, ...hasParams));\n  }\n\n  toJSON() {\n    return typeof this.bitfield === 'number' ? this.bitfield : this.bitfield.toString();\n  }\n\n  valueOf() {\n    return this.bitfield;\n  }\n\n  *[Symbol.iterator]() {\n    yield* this.toArray();\n  }\n\n  /**\n   * Data that can be resolved to give a bitfield. This can be:\n   * * A bit number (this can be a number literal or a value taken from {@link BitField.Flags})\n   * * A string bit number\n   * * An instance of BitField\n   * * An Array of BitFieldResolvable\n   * @typedef {number|string|bigint|BitField|BitFieldResolvable[]} BitFieldResolvable\n   */\n\n  /**\n   * Resolves bitfields to their numeric form.\n   * @param {BitFieldResolvable} [bit] bit(s) to resolve\n   * @returns {number|bigint}\n   */\n  static resolve(bit) {\n    const { DefaultBit } = this;\n    if (typeof DefaultBit === typeof bit && bit >= DefaultBit) return bit;\n    if (bit instanceof BitField) return bit.bitfield;\n    if (Array.isArray(bit)) return bit.map(p => this.resolve(p)).reduce((prev, p) => prev | p, DefaultBit);\n    if (typeof bit === 'string') {\n      if (typeof this.Flags[bit] !== 'undefined') return this.Flags[bit];\n      if (!isNaN(bit)) return typeof DefaultBit === 'bigint' ? BigInt(bit) : Number(bit);\n    }\n    throw new DiscordjsRangeError(ErrorCodes.BitFieldInvalid, bit);\n  }\n}\n\nmodule.exports = BitField;\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}