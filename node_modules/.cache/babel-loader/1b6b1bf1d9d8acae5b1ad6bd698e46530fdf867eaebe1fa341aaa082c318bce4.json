{"ast":null,"code":"'use strict';\n\nconst {\n  ApplicationCommandOptionType\n} = require('discord-api-types/v10');\nconst {\n  DiscordjsTypeError,\n  ErrorCodes\n} = require('../errors');\n\n/**\n * A resolver for command interaction options.\n */\nclass CommandInteractionOptionResolver {\n  constructor(client, options, resolved) {\n    /**\n     * The client that instantiated this.\n     * @name CommandInteractionOptionResolver#client\n     * @type {Client}\n     * @readonly\n     */\n    Object.defineProperty(this, 'client', {\n      value: client\n    });\n\n    /**\n     * The name of the subcommand group.\n     * @type {?string}\n     * @private\n     */\n    this._group = null;\n\n    /**\n     * The name of the subcommand.\n     * @type {?string}\n     * @private\n     */\n    this._subcommand = null;\n\n    /**\n     * The bottom-level options for the interaction.\n     * If there is a subcommand (or subcommand and group), this is the options for the subcommand.\n     * @type {CommandInteractionOption[]}\n     * @private\n     */\n    this._hoistedOptions = options;\n\n    // Hoist subcommand group if present\n    if (this._hoistedOptions[0]?.type === ApplicationCommandOptionType.SubcommandGroup) {\n      this._group = this._hoistedOptions[0].name;\n      this._hoistedOptions = this._hoistedOptions[0].options ?? [];\n    }\n    // Hoist subcommand if present\n    if (this._hoistedOptions[0]?.type === ApplicationCommandOptionType.Subcommand) {\n      this._subcommand = this._hoistedOptions[0].name;\n      this._hoistedOptions = this._hoistedOptions[0].options ?? [];\n    }\n\n    /**\n     * The interaction options array.\n     * @name CommandInteractionOptionResolver#data\n     * @type {ReadonlyArray<CommandInteractionOption>}\n     * @readonly\n     */\n    Object.defineProperty(this, 'data', {\n      value: Object.freeze([...options])\n    });\n\n    /**\n     * The interaction resolved data\n     * @name CommandInteractionOptionResolver#resolved\n     * @type {?Readonly<CommandInteractionResolvedData>}\n     */\n    Object.defineProperty(this, 'resolved', {\n      value: resolved ? Object.freeze(resolved) : null\n    });\n  }\n\n  /**\n   * Gets an option by its name.\n   * @param {string} name The name of the option.\n   * @param {boolean} [required=false] Whether to throw an error if the option is not found.\n   * @returns {?CommandInteractionOption} The option, if found.\n   */\n  get(name) {\n    let required = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n    const option = this._hoistedOptions.find(opt => opt.name === name);\n    if (!option) {\n      if (required) {\n        throw new DiscordjsTypeError(ErrorCodes.CommandInteractionOptionNotFound, name);\n      }\n      return null;\n    }\n    return option;\n  }\n\n  /**\n   * Gets an option by name and property and checks its type.\n   * @param {string} name The name of the option.\n   * @param {ApplicationCommandOptionType} type The type of the option.\n   * @param {string[]} properties The properties to check for for `required`.\n   * @param {boolean} required Whether to throw an error if the option is not found.\n   * @returns {?CommandInteractionOption} The option, if found.\n   * @private\n   */\n  _getTypedOption(name, type, properties, required) {\n    const option = this.get(name, required);\n    if (!option) {\n      return null;\n    } else if (option.type !== type) {\n      throw new DiscordjsTypeError(ErrorCodes.CommandInteractionOptionType, name, option.type, type);\n    } else if (required && properties.every(prop => option[prop] === null || typeof option[prop] === 'undefined')) {\n      throw new DiscordjsTypeError(ErrorCodes.CommandInteractionOptionEmpty, name, option.type);\n    }\n    return option;\n  }\n\n  /**\n   * Gets the selected subcommand.\n   * @param {boolean} [required=true] Whether to throw an error if there is no subcommand.\n   * @returns {?string} The name of the selected subcommand, or null if not set and not required.\n   */\n  getSubcommand() {\n    let required = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;\n    if (required && !this._subcommand) {\n      throw new DiscordjsTypeError(ErrorCodes.CommandInteractionOptionNoSubcommand);\n    }\n    return this._subcommand;\n  }\n\n  /**\n   * Gets the selected subcommand group.\n   * @param {boolean} [required=false] Whether to throw an error if there is no subcommand group.\n   * @returns {?string} The name of the selected subcommand group, or null if not set and not required.\n   */\n  getSubcommandGroup() {\n    let required = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;\n    if (required && !this._group) {\n      throw new DiscordjsTypeError(ErrorCodes.CommandInteractionOptionNoSubcommandGroup);\n    }\n    return this._group;\n  }\n\n  /**\n   * Gets a boolean option.\n   * @param {string} name The name of the option.\n   * @param {boolean} [required=false] Whether to throw an error if the option is not found.\n   * @returns {?boolean} The value of the option, or null if not set and not required.\n   */\n  getBoolean(name) {\n    let required = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n    const option = this._getTypedOption(name, ApplicationCommandOptionType.Boolean, ['value'], required);\n    return option?.value ?? null;\n  }\n\n  /**\n   * Gets a channel option.\n   * @param {string} name The name of the option.\n   * @param {boolean} [required=false] Whether to throw an error if the option is not found.\n   * @returns {?(GuildChannel|ThreadChannel|APIChannel)}\n   * The value of the option, or null if not set and not required.\n   */\n  getChannel(name) {\n    let required = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n    const option = this._getTypedOption(name, ApplicationCommandOptionType.Channel, ['channel'], required);\n    return option?.channel ?? null;\n  }\n\n  /**\n   * Gets a string option.\n   * @param {string} name The name of the option.\n   * @param {boolean} [required=false] Whether to throw an error if the option is not found.\n   * @returns {?string} The value of the option, or null if not set and not required.\n   */\n  getString(name) {\n    let required = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n    const option = this._getTypedOption(name, ApplicationCommandOptionType.String, ['value'], required);\n    return option?.value ?? null;\n  }\n\n  /**\n   * Gets an integer option.\n   * @param {string} name The name of the option.\n   * @param {boolean} [required=false] Whether to throw an error if the option is not found.\n   * @returns {?number} The value of the option, or null if not set and not required.\n   */\n  getInteger(name) {\n    let required = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n    const option = this._getTypedOption(name, ApplicationCommandOptionType.Integer, ['value'], required);\n    return option?.value ?? null;\n  }\n\n  /**\n   * Gets a number option.\n   * @param {string} name The name of the option.\n   * @param {boolean} [required=false] Whether to throw an error if the option is not found.\n   * @returns {?number} The value of the option, or null if not set and not required.\n   */\n  getNumber(name) {\n    let required = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n    const option = this._getTypedOption(name, ApplicationCommandOptionType.Number, ['value'], required);\n    return option?.value ?? null;\n  }\n\n  /**\n   * Gets a user option.\n   * @param {string} name The name of the option.\n   * @param {boolean} [required=false] Whether to throw an error if the option is not found.\n   * @returns {?User} The value of the option, or null if not set and not required.\n   */\n  getUser(name) {\n    let required = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n    const option = this._getTypedOption(name, ApplicationCommandOptionType.User, ['user'], required);\n    return option?.user ?? null;\n  }\n\n  /**\n   * Gets a member option.\n   * @param {string} name The name of the option.\n   * @returns {?(GuildMember|APIGuildMember)}\n   * The value of the option, or null if the user is not present in the guild or the option is not set.\n   */\n  getMember(name) {\n    const option = this._getTypedOption(name, ApplicationCommandOptionType.User, ['member'], false);\n    return option?.member ?? null;\n  }\n\n  /**\n   * Gets a role option.\n   * @param {string} name The name of the option.\n   * @param {boolean} [required=false] Whether to throw an error if the option is not found.\n   * @returns {?(Role|APIRole)} The value of the option, or null if not set and not required.\n   */\n  getRole(name) {\n    let required = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n    const option = this._getTypedOption(name, ApplicationCommandOptionType.Role, ['role'], required);\n    return option?.role ?? null;\n  }\n\n  /**\n   * Gets an attachment option.\n   * @param {string} name The name of the option.\n   * @param {boolean} [required=false] Whether to throw an error if the option is not found.\n   * @returns {?Attachment} The value of the option, or null if not set and not required.\n   */\n  getAttachment(name) {\n    let required = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n    const option = this._getTypedOption(name, ApplicationCommandOptionType.Attachment, ['attachment'], required);\n    return option?.attachment ?? null;\n  }\n\n  /**\n   * Gets a mentionable option.\n   * @param {string} name The name of the option.\n   * @param {boolean} [required=false] Whether to throw an error if the option is not found.\n   * @returns {?(User|GuildMember|APIGuildMember|Role|APIRole)}\n   * The value of the option, or null if not set and not required.\n   */\n  getMentionable(name) {\n    let required = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n    const option = this._getTypedOption(name, ApplicationCommandOptionType.Mentionable, ['user', 'member', 'role'], required);\n    return option?.member ?? option?.user ?? option?.role ?? null;\n  }\n\n  /**\n   * Gets a message option.\n   * @param {string} name The name of the option.\n   * @param {boolean} [required=false] Whether to throw an error if the option is not found.\n   * @returns {?Message}\n   * The value of the option, or null if not set and not required.\n   */\n  getMessage(name) {\n    let required = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n    const option = this._getTypedOption(name, '_MESSAGE', ['message'], required);\n    return option?.message ?? null;\n  }\n\n  /**\n   * The full autocomplete option object.\n   * @typedef {Object} AutocompleteFocusedOption\n   * @property {string} name The name of the option\n   * @property {ApplicationCommandOptionType} type The type of the application command option\n   * @property {string} value The value of the option\n   * @property {boolean} focused Whether this option is currently in focus for autocomplete\n   */\n\n  /**\n   * Gets the focused option.\n   * @param {boolean} [getFull=false] Whether to get the full option object\n   * @returns {string|AutocompleteFocusedOption}\n   * The value of the option, or the whole option if getFull is true\n   */\n  getFocused() {\n    let getFull = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;\n    const focusedOption = this._hoistedOptions.find(option => option.focused);\n    if (!focusedOption) throw new DiscordjsTypeError(ErrorCodes.AutocompleteInteractionOptionNoFocusedOption);\n    return getFull ? focusedOption : focusedOption.value;\n  }\n}\nmodule.exports = CommandInteractionOptionResolver;","map":{"version":3,"names":["ApplicationCommandOptionType","require","DiscordjsTypeError","ErrorCodes","CommandInteractionOptionResolver","constructor","client","options","resolved","Object","defineProperty","value","_group","_subcommand","_hoistedOptions","type","SubcommandGroup","name","Subcommand","freeze","get","required","option","find","opt","CommandInteractionOptionNotFound","_getTypedOption","properties","CommandInteractionOptionType","every","prop","CommandInteractionOptionEmpty","getSubcommand","CommandInteractionOptionNoSubcommand","getSubcommandGroup","CommandInteractionOptionNoSubcommandGroup","getBoolean","Boolean","getChannel","Channel","channel","getString","String","getInteger","Integer","getNumber","Number","getUser","User","user","getMember","member","getRole","Role","role","getAttachment","Attachment","attachment","getMentionable","Mentionable","getMessage","message","getFocused","getFull","focusedOption","focused","AutocompleteInteractionOptionNoFocusedOption","module","exports"],"sources":["J:/Coding/Projekts/Web/JavaScript/sillcode.tech/node_modules/discord.js/src/structures/CommandInteractionOptionResolver.js"],"sourcesContent":["'use strict';\n\nconst { ApplicationCommandOptionType } = require('discord-api-types/v10');\nconst { DiscordjsTypeError, ErrorCodes } = require('../errors');\n\n/**\n * A resolver for command interaction options.\n */\nclass CommandInteractionOptionResolver {\n  constructor(client, options, resolved) {\n    /**\n     * The client that instantiated this.\n     * @name CommandInteractionOptionResolver#client\n     * @type {Client}\n     * @readonly\n     */\n    Object.defineProperty(this, 'client', { value: client });\n\n    /**\n     * The name of the subcommand group.\n     * @type {?string}\n     * @private\n     */\n    this._group = null;\n\n    /**\n     * The name of the subcommand.\n     * @type {?string}\n     * @private\n     */\n    this._subcommand = null;\n\n    /**\n     * The bottom-level options for the interaction.\n     * If there is a subcommand (or subcommand and group), this is the options for the subcommand.\n     * @type {CommandInteractionOption[]}\n     * @private\n     */\n    this._hoistedOptions = options;\n\n    // Hoist subcommand group if present\n    if (this._hoistedOptions[0]?.type === ApplicationCommandOptionType.SubcommandGroup) {\n      this._group = this._hoistedOptions[0].name;\n      this._hoistedOptions = this._hoistedOptions[0].options ?? [];\n    }\n    // Hoist subcommand if present\n    if (this._hoistedOptions[0]?.type === ApplicationCommandOptionType.Subcommand) {\n      this._subcommand = this._hoistedOptions[0].name;\n      this._hoistedOptions = this._hoistedOptions[0].options ?? [];\n    }\n\n    /**\n     * The interaction options array.\n     * @name CommandInteractionOptionResolver#data\n     * @type {ReadonlyArray<CommandInteractionOption>}\n     * @readonly\n     */\n    Object.defineProperty(this, 'data', { value: Object.freeze([...options]) });\n\n    /**\n     * The interaction resolved data\n     * @name CommandInteractionOptionResolver#resolved\n     * @type {?Readonly<CommandInteractionResolvedData>}\n     */\n    Object.defineProperty(this, 'resolved', { value: resolved ? Object.freeze(resolved) : null });\n  }\n\n  /**\n   * Gets an option by its name.\n   * @param {string} name The name of the option.\n   * @param {boolean} [required=false] Whether to throw an error if the option is not found.\n   * @returns {?CommandInteractionOption} The option, if found.\n   */\n  get(name, required = false) {\n    const option = this._hoistedOptions.find(opt => opt.name === name);\n    if (!option) {\n      if (required) {\n        throw new DiscordjsTypeError(ErrorCodes.CommandInteractionOptionNotFound, name);\n      }\n      return null;\n    }\n    return option;\n  }\n\n  /**\n   * Gets an option by name and property and checks its type.\n   * @param {string} name The name of the option.\n   * @param {ApplicationCommandOptionType} type The type of the option.\n   * @param {string[]} properties The properties to check for for `required`.\n   * @param {boolean} required Whether to throw an error if the option is not found.\n   * @returns {?CommandInteractionOption} The option, if found.\n   * @private\n   */\n  _getTypedOption(name, type, properties, required) {\n    const option = this.get(name, required);\n    if (!option) {\n      return null;\n    } else if (option.type !== type) {\n      throw new DiscordjsTypeError(ErrorCodes.CommandInteractionOptionType, name, option.type, type);\n    } else if (required && properties.every(prop => option[prop] === null || typeof option[prop] === 'undefined')) {\n      throw new DiscordjsTypeError(ErrorCodes.CommandInteractionOptionEmpty, name, option.type);\n    }\n    return option;\n  }\n\n  /**\n   * Gets the selected subcommand.\n   * @param {boolean} [required=true] Whether to throw an error if there is no subcommand.\n   * @returns {?string} The name of the selected subcommand, or null if not set and not required.\n   */\n  getSubcommand(required = true) {\n    if (required && !this._subcommand) {\n      throw new DiscordjsTypeError(ErrorCodes.CommandInteractionOptionNoSubcommand);\n    }\n    return this._subcommand;\n  }\n\n  /**\n   * Gets the selected subcommand group.\n   * @param {boolean} [required=false] Whether to throw an error if there is no subcommand group.\n   * @returns {?string} The name of the selected subcommand group, or null if not set and not required.\n   */\n  getSubcommandGroup(required = false) {\n    if (required && !this._group) {\n      throw new DiscordjsTypeError(ErrorCodes.CommandInteractionOptionNoSubcommandGroup);\n    }\n    return this._group;\n  }\n\n  /**\n   * Gets a boolean option.\n   * @param {string} name The name of the option.\n   * @param {boolean} [required=false] Whether to throw an error if the option is not found.\n   * @returns {?boolean} The value of the option, or null if not set and not required.\n   */\n  getBoolean(name, required = false) {\n    const option = this._getTypedOption(name, ApplicationCommandOptionType.Boolean, ['value'], required);\n    return option?.value ?? null;\n  }\n\n  /**\n   * Gets a channel option.\n   * @param {string} name The name of the option.\n   * @param {boolean} [required=false] Whether to throw an error if the option is not found.\n   * @returns {?(GuildChannel|ThreadChannel|APIChannel)}\n   * The value of the option, or null if not set and not required.\n   */\n  getChannel(name, required = false) {\n    const option = this._getTypedOption(name, ApplicationCommandOptionType.Channel, ['channel'], required);\n    return option?.channel ?? null;\n  }\n\n  /**\n   * Gets a string option.\n   * @param {string} name The name of the option.\n   * @param {boolean} [required=false] Whether to throw an error if the option is not found.\n   * @returns {?string} The value of the option, or null if not set and not required.\n   */\n  getString(name, required = false) {\n    const option = this._getTypedOption(name, ApplicationCommandOptionType.String, ['value'], required);\n    return option?.value ?? null;\n  }\n\n  /**\n   * Gets an integer option.\n   * @param {string} name The name of the option.\n   * @param {boolean} [required=false] Whether to throw an error if the option is not found.\n   * @returns {?number} The value of the option, or null if not set and not required.\n   */\n  getInteger(name, required = false) {\n    const option = this._getTypedOption(name, ApplicationCommandOptionType.Integer, ['value'], required);\n    return option?.value ?? null;\n  }\n\n  /**\n   * Gets a number option.\n   * @param {string} name The name of the option.\n   * @param {boolean} [required=false] Whether to throw an error if the option is not found.\n   * @returns {?number} The value of the option, or null if not set and not required.\n   */\n  getNumber(name, required = false) {\n    const option = this._getTypedOption(name, ApplicationCommandOptionType.Number, ['value'], required);\n    return option?.value ?? null;\n  }\n\n  /**\n   * Gets a user option.\n   * @param {string} name The name of the option.\n   * @param {boolean} [required=false] Whether to throw an error if the option is not found.\n   * @returns {?User} The value of the option, or null if not set and not required.\n   */\n  getUser(name, required = false) {\n    const option = this._getTypedOption(name, ApplicationCommandOptionType.User, ['user'], required);\n    return option?.user ?? null;\n  }\n\n  /**\n   * Gets a member option.\n   * @param {string} name The name of the option.\n   * @returns {?(GuildMember|APIGuildMember)}\n   * The value of the option, or null if the user is not present in the guild or the option is not set.\n   */\n  getMember(name) {\n    const option = this._getTypedOption(name, ApplicationCommandOptionType.User, ['member'], false);\n    return option?.member ?? null;\n  }\n\n  /**\n   * Gets a role option.\n   * @param {string} name The name of the option.\n   * @param {boolean} [required=false] Whether to throw an error if the option is not found.\n   * @returns {?(Role|APIRole)} The value of the option, or null if not set and not required.\n   */\n  getRole(name, required = false) {\n    const option = this._getTypedOption(name, ApplicationCommandOptionType.Role, ['role'], required);\n    return option?.role ?? null;\n  }\n\n  /**\n   * Gets an attachment option.\n   * @param {string} name The name of the option.\n   * @param {boolean} [required=false] Whether to throw an error if the option is not found.\n   * @returns {?Attachment} The value of the option, or null if not set and not required.\n   */\n  getAttachment(name, required = false) {\n    const option = this._getTypedOption(name, ApplicationCommandOptionType.Attachment, ['attachment'], required);\n    return option?.attachment ?? null;\n  }\n\n  /**\n   * Gets a mentionable option.\n   * @param {string} name The name of the option.\n   * @param {boolean} [required=false] Whether to throw an error if the option is not found.\n   * @returns {?(User|GuildMember|APIGuildMember|Role|APIRole)}\n   * The value of the option, or null if not set and not required.\n   */\n  getMentionable(name, required = false) {\n    const option = this._getTypedOption(\n      name,\n      ApplicationCommandOptionType.Mentionable,\n      ['user', 'member', 'role'],\n      required,\n    );\n    return option?.member ?? option?.user ?? option?.role ?? null;\n  }\n\n  /**\n   * Gets a message option.\n   * @param {string} name The name of the option.\n   * @param {boolean} [required=false] Whether to throw an error if the option is not found.\n   * @returns {?Message}\n   * The value of the option, or null if not set and not required.\n   */\n  getMessage(name, required = false) {\n    const option = this._getTypedOption(name, '_MESSAGE', ['message'], required);\n    return option?.message ?? null;\n  }\n\n  /**\n   * The full autocomplete option object.\n   * @typedef {Object} AutocompleteFocusedOption\n   * @property {string} name The name of the option\n   * @property {ApplicationCommandOptionType} type The type of the application command option\n   * @property {string} value The value of the option\n   * @property {boolean} focused Whether this option is currently in focus for autocomplete\n   */\n\n  /**\n   * Gets the focused option.\n   * @param {boolean} [getFull=false] Whether to get the full option object\n   * @returns {string|AutocompleteFocusedOption}\n   * The value of the option, or the whole option if getFull is true\n   */\n  getFocused(getFull = false) {\n    const focusedOption = this._hoistedOptions.find(option => option.focused);\n    if (!focusedOption) throw new DiscordjsTypeError(ErrorCodes.AutocompleteInteractionOptionNoFocusedOption);\n    return getFull ? focusedOption : focusedOption.value;\n  }\n}\n\nmodule.exports = CommandInteractionOptionResolver;\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}