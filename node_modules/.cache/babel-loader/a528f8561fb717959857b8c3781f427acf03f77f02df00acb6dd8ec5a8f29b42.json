{"ast":null,"code":"'use strict';\n\nconst EventEmitter = require('node:events');\nconst fs = require('node:fs');\nconst path = require('node:path');\nconst process = require('node:process');\nconst {\n  setTimeout: sleep\n} = require('node:timers/promises');\nconst {\n  Collection\n} = require('@discordjs/collection');\nconst Shard = require('./Shard');\nconst {\n  DiscordjsError,\n  DiscordjsTypeError,\n  DiscordjsRangeError,\n  ErrorCodes\n} = require('../errors');\nconst {\n  mergeDefault,\n  fetchRecommendedShardCount\n} = require('../util/Util');\n\n/**\n * This is a utility class that makes multi-process sharding of a bot an easy and painless experience.\n * It works by spawning a self-contained {@link ChildProcess} or {@link Worker} for each individual shard, each\n * containing its own instance of your bot's {@link Client}. They all have a line of communication with the master\n * process, and there are several useful methods that utilise it in order to simplify tasks that are normally difficult\n * with sharding. It can spawn a specific number of shards or the amount that Discord suggests for the bot, and takes a\n * path to your main bot script to launch for each one.\n * @extends {EventEmitter}\n */\nclass ShardingManager extends EventEmitter {\n  /**\n   * The mode to spawn shards with for a {@link ShardingManager}. Can be either one of:\n   * * 'process' to use child processes\n   * * 'worker' to use [Worker threads](https://nodejs.org/api/worker_threads.html)\n   * @typedef {string} ShardingManagerMode\n   */\n\n  /**\n   * The options to spawn shards with for a {@link ShardingManager}.\n   * @typedef {Object} ShardingManagerOptions\n   * @property {string|number} [totalShards='auto'] Number of total shards of all shard managers or \"auto\"\n   * @property {string|number[]} [shardList='auto'] List of shards to spawn or \"auto\"\n   * @property {ShardingManagerMode} [mode='process'] Which mode to use for shards\n   * @property {boolean} [respawn=true] Whether shards should automatically respawn upon exiting\n   * @property {string[]} [shardArgs=[]] Arguments to pass to the shard script when spawning\n   * (only available when mode is set to 'process')\n   * @property {string[]} [execArgv=[]] Arguments to pass to the shard script executable when spawning\n   * (only available when mode is set to 'process')\n   * @property {string} [token] Token to use for automatic shard count and passing to shards\n   */\n\n  /**\n   * @param {string} file Path to your shard script file\n   * @param {ShardingManagerOptions} [options] Options for the sharding manager\n   */\n  constructor(file) {\n    let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    super();\n    options = mergeDefault({\n      totalShards: 'auto',\n      mode: 'process',\n      respawn: true,\n      shardArgs: [],\n      execArgv: [],\n      token: process.env.DISCORD_TOKEN\n    }, options);\n\n    /**\n     * Path to the shard script file\n     * @type {string}\n     */\n    this.file = file;\n    if (!file) throw new DiscordjsError(ErrorCodes.ClientInvalidOption, 'File', 'specified.');\n    if (!path.isAbsolute(file)) this.file = path.resolve(process.cwd(), file);\n    const stats = fs.statSync(this.file);\n    if (!stats.isFile()) throw new DiscordjsError(ErrorCodes.ClientInvalidOption, 'File', 'a file');\n\n    /**\n     * List of shards this sharding manager spawns\n     * @type {string|number[]}\n     */\n    this.shardList = options.shardList ?? 'auto';\n    if (this.shardList !== 'auto') {\n      if (!Array.isArray(this.shardList)) {\n        throw new DiscordjsTypeError(ErrorCodes.ClientInvalidOption, 'shardList', 'an array.');\n      }\n      this.shardList = [...new Set(this.shardList)];\n      if (this.shardList.length < 1) {\n        throw new DiscordjsRangeError(ErrorCodes.ClientInvalidOption, 'shardList', 'at least 1 id.');\n      }\n      if (this.shardList.some(shardId => typeof shardId !== 'number' || isNaN(shardId) || !Number.isInteger(shardId) || shardId < 0)) {\n        throw new DiscordjsTypeError(ErrorCodes.ClientInvalidOption, 'shardList', 'an array of positive integers.');\n      }\n    }\n\n    /**\n     * Amount of shards that all sharding managers spawn in total\n     * @type {number}\n     */\n    this.totalShards = options.totalShards || 'auto';\n    if (this.totalShards !== 'auto') {\n      if (typeof this.totalShards !== 'number' || isNaN(this.totalShards)) {\n        throw new DiscordjsTypeError(ErrorCodes.ClientInvalidOption, 'Amount of shards', 'a number.');\n      }\n      if (this.totalShards < 1) {\n        throw new DiscordjsRangeError(ErrorCodes.ClientInvalidOption, 'Amount of shards', 'at least 1.');\n      }\n      if (!Number.isInteger(this.totalShards)) {\n        throw new DiscordjsRangeError(ErrorCodes.ClientInvalidOption, 'Amount of shards', 'an integer.');\n      }\n    }\n\n    /**\n     * Mode for shards to spawn with\n     * @type {ShardingManagerMode}\n     */\n    this.mode = options.mode;\n    if (this.mode !== 'process' && this.mode !== 'worker') {\n      throw new DiscordjsRangeError(ErrorCodes.ClientInvalidOption, 'Sharding mode', '\"process\" or \"worker\"');\n    }\n\n    /**\n     * Whether shards should automatically respawn upon exiting\n     * @type {boolean}\n     */\n    this.respawn = options.respawn;\n\n    /**\n     * An array of arguments to pass to shards (only when {@link ShardingManager#mode} is `process`)\n     * @type {string[]}\n     */\n    this.shardArgs = options.shardArgs;\n\n    /**\n     * An array of arguments to pass to the executable (only when {@link ShardingManager#mode} is `process`)\n     * @type {string[]}\n     */\n    this.execArgv = options.execArgv;\n\n    /**\n     * Token to use for obtaining the automatic shard count, and passing to shards\n     * @type {?string}\n     */\n    this.token = options.token?.replace(/^Bot\\s*/i, '') ?? null;\n\n    /**\n     * A collection of shards that this manager has spawned\n     * @type {Collection<number, Shard>}\n     */\n    this.shards = new Collection();\n    process.env.SHARDING_MANAGER = true;\n    process.env.SHARDING_MANAGER_MODE = this.mode;\n    process.env.DISCORD_TOKEN = this.token;\n  }\n\n  /**\n   * Creates a single shard.\n   * <warn>Using this method is usually not necessary if you use the spawn method.</warn>\n   * @param {number} [id=this.shards.size] Id of the shard to create\n   * <info>This is usually not necessary to manually specify.</info>\n   * @returns {Shard} Note that the created shard needs to be explicitly spawned using its spawn method.\n   */\n  createShard() {\n    let id = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.shards.size;\n    const shard = new Shard(this, id);\n    this.shards.set(id, shard);\n    /**\n     * Emitted upon creating a shard.\n     * @event ShardingManager#shardCreate\n     * @param {Shard} shard Shard that was created\n     */\n    this.emit('shardCreate', shard);\n    return shard;\n  }\n\n  /**\n   * Options used to spawn multiple shards.\n   * @typedef {Object} MultipleShardSpawnOptions\n   * @property {number|string} [amount=this.totalShards] Number of shards to spawn\n   * @property {number} [delay=5500] How long to wait in between spawning each shard (in milliseconds)\n   * @property {number} [timeout=30000] The amount in milliseconds to wait until the {@link Client} has become ready\n   */\n\n  /**\n   * Spawns multiple shards.\n   * @param {MultipleShardSpawnOptions} [options] Options for spawning shards\n   * @returns {Promise<Collection<number, Shard>>}\n   */\n  async spawn() {\n    let {\n      amount = this.totalShards,\n      delay = 5500,\n      timeout = 30_000\n    } = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    // Obtain/verify the number of shards to spawn\n    if (amount === 'auto') {\n      amount = await fetchRecommendedShardCount(this.token);\n    } else {\n      if (typeof amount !== 'number' || isNaN(amount)) {\n        throw new DiscordjsTypeError(ErrorCodes.ClientInvalidOption, 'Amount of shards', 'a number.');\n      }\n      if (amount < 1) throw new DiscordjsRangeError(ErrorCodes.ClientInvalidOption, 'Amount of shards', 'at least 1.');\n      if (!Number.isInteger(amount)) {\n        throw new DiscordjsTypeError(ErrorCodes.ClientInvalidOption, 'Amount of shards', 'an integer.');\n      }\n    }\n\n    // Make sure this many shards haven't already been spawned\n    if (this.shards.size >= amount) throw new DiscordjsError(ErrorCodes.ShardingAlreadySpawned, this.shards.size);\n    if (this.shardList === 'auto' || this.totalShards === 'auto' || this.totalShards !== amount) {\n      this.shardList = [...Array(amount).keys()];\n    }\n    if (this.totalShards === 'auto' || this.totalShards !== amount) {\n      this.totalShards = amount;\n    }\n    if (this.shardList.some(shardId => shardId >= amount)) {\n      throw new DiscordjsRangeError(ErrorCodes.ClientInvalidOption, 'Amount of shards', 'bigger than the highest shardId in the shardList option.');\n    }\n\n    // Spawn the shards\n    for (const shardId of this.shardList) {\n      const promises = [];\n      const shard = this.createShard(shardId);\n      promises.push(shard.spawn(timeout));\n      if (delay > 0 && this.shards.size !== this.shardList.length) promises.push(sleep(delay));\n      await Promise.all(promises); // eslint-disable-line no-await-in-loop\n    }\n\n    return this.shards;\n  }\n\n  /**\n   * Sends a message to all shards.\n   * @param {*} message Message to be sent to the shards\n   * @returns {Promise<Shard[]>}\n   */\n  broadcast(message) {\n    const promises = [];\n    for (const shard of this.shards.values()) promises.push(shard.send(message));\n    return Promise.all(promises);\n  }\n\n  /**\n   * Options for {@link ShardingManager#broadcastEval} and {@link ShardClientUtil#broadcastEval}.\n   * @typedef {Object} BroadcastEvalOptions\n   * @property {number} [shard] Shard to run script on, all if undefined\n   * @property {*} [context] The JSON-serializable values to call the script with\n   */\n\n  /**\n   * Evaluates a script on all shards, or a given shard, in the context of the {@link Client}s.\n   * @param {Function} script JavaScript to run on each shard\n   * @param {BroadcastEvalOptions} [options={}] The options for the broadcast\n   * @returns {Promise<*|Array<*>>} Results of the script execution\n   */\n  broadcastEval(script) {\n    let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    if (typeof script !== 'function') {\n      return Promise.reject(new DiscordjsTypeError(ErrorCodes.ShardingInvalidEvalBroadcast));\n    }\n    return this._performOnShards('eval', [`(${script})(this, ${JSON.stringify(options.context)})`], options.shard);\n  }\n\n  /**\n   * Fetches a client property value of each shard, or a given shard.\n   * @param {string} prop Name of the client property to get, using periods for nesting\n   * @param {number} [shard] Shard to fetch property from, all if undefined\n   * @returns {Promise<*|Array<*>>}\n   * @example\n   * manager.fetchClientValues('guilds.cache.size')\n   *   .then(results => console.log(`${results.reduce((prev, val) => prev + val, 0)} total guilds`))\n   *   .catch(console.error);\n   */\n  fetchClientValues(prop, shard) {\n    return this._performOnShards('fetchClientValue', [prop], shard);\n  }\n\n  /**\n   * Runs a method with given arguments on all shards, or a given shard.\n   * @param {string} method Method name to run on each shard\n   * @param {Array<*>} args Arguments to pass through to the method call\n   * @param {number} [shard] Shard to run on, all if undefined\n   * @returns {Promise<*|Array<*>>} Results of the method execution\n   * @private\n   */\n  _performOnShards(method, args, shard) {\n    if (this.shards.size === 0) return Promise.reject(new DiscordjsError(ErrorCodes.ShardingNoShards));\n    if (typeof shard === 'number') {\n      if (this.shards.has(shard)) return this.shards.get(shard)[method](...args);\n      return Promise.reject(new DiscordjsError(ErrorCodes.ShardingShardNotFound, shard));\n    }\n    if (this.shards.size !== this.shardList.length) {\n      return Promise.reject(new DiscordjsError(ErrorCodes.ShardingInProcess));\n    }\n    const promises = [];\n    for (const sh of this.shards.values()) promises.push(sh[method](...args));\n    return Promise.all(promises);\n  }\n\n  /**\n   * Options used to respawn all shards.\n   * @typedef {Object} MultipleShardRespawnOptions\n   * @property {number} [shardDelay=5000] How long to wait between shards (in milliseconds)\n   * @property {number} [respawnDelay=500] How long to wait between killing a shard's process and restarting it\n   * (in milliseconds)\n   * @property {number} [timeout=30000] The amount in milliseconds to wait for a shard to become ready before\n   * continuing to another (`-1` or `Infinity` for no wait)\n   */\n\n  /**\n   * Kills all running shards and respawns them.\n   * @param {MultipleShardRespawnOptions} [options] Options for respawning shards\n   * @returns {Promise<Collection<number, Shard>>}\n   */\n  async respawnAll() {\n    let {\n      shardDelay = 5_000,\n      respawnDelay = 500,\n      timeout = 30_000\n    } = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    let s = 0;\n    for (const shard of this.shards.values()) {\n      const promises = [shard.respawn({\n        delay: respawnDelay,\n        timeout\n      })];\n      if (++s < this.shards.size && shardDelay > 0) promises.push(sleep(shardDelay));\n      await Promise.all(promises); // eslint-disable-line no-await-in-loop\n    }\n\n    return this.shards;\n  }\n}\nmodule.exports = ShardingManager;","map":{"version":3,"names":["EventEmitter","require","fs","path","process","setTimeout","sleep","Collection","Shard","DiscordjsError","DiscordjsTypeError","DiscordjsRangeError","ErrorCodes","mergeDefault","fetchRecommendedShardCount","ShardingManager","constructor","file","options","totalShards","mode","respawn","shardArgs","execArgv","token","env","DISCORD_TOKEN","ClientInvalidOption","isAbsolute","resolve","cwd","stats","statSync","isFile","shardList","Array","isArray","Set","length","some","shardId","isNaN","Number","isInteger","replace","shards","SHARDING_MANAGER","SHARDING_MANAGER_MODE","createShard","id","size","shard","set","emit","spawn","amount","delay","timeout","ShardingAlreadySpawned","keys","promises","push","Promise","all","broadcast","message","values","send","broadcastEval","script","reject","ShardingInvalidEvalBroadcast","_performOnShards","JSON","stringify","context","fetchClientValues","prop","method","args","ShardingNoShards","has","get","ShardingShardNotFound","ShardingInProcess","sh","respawnAll","shardDelay","respawnDelay","s","module","exports"],"sources":["J:/Coding/Projekts/Web/JavaScript/sillcode.tech/node_modules/discord.js/src/sharding/ShardingManager.js"],"sourcesContent":["'use strict';\n\nconst EventEmitter = require('node:events');\nconst fs = require('node:fs');\nconst path = require('node:path');\nconst process = require('node:process');\nconst { setTimeout: sleep } = require('node:timers/promises');\nconst { Collection } = require('@discordjs/collection');\nconst Shard = require('./Shard');\nconst { DiscordjsError, DiscordjsTypeError, DiscordjsRangeError, ErrorCodes } = require('../errors');\nconst { mergeDefault, fetchRecommendedShardCount } = require('../util/Util');\n\n/**\n * This is a utility class that makes multi-process sharding of a bot an easy and painless experience.\n * It works by spawning a self-contained {@link ChildProcess} or {@link Worker} for each individual shard, each\n * containing its own instance of your bot's {@link Client}. They all have a line of communication with the master\n * process, and there are several useful methods that utilise it in order to simplify tasks that are normally difficult\n * with sharding. It can spawn a specific number of shards or the amount that Discord suggests for the bot, and takes a\n * path to your main bot script to launch for each one.\n * @extends {EventEmitter}\n */\nclass ShardingManager extends EventEmitter {\n  /**\n   * The mode to spawn shards with for a {@link ShardingManager}. Can be either one of:\n   * * 'process' to use child processes\n   * * 'worker' to use [Worker threads](https://nodejs.org/api/worker_threads.html)\n   * @typedef {string} ShardingManagerMode\n   */\n\n  /**\n   * The options to spawn shards with for a {@link ShardingManager}.\n   * @typedef {Object} ShardingManagerOptions\n   * @property {string|number} [totalShards='auto'] Number of total shards of all shard managers or \"auto\"\n   * @property {string|number[]} [shardList='auto'] List of shards to spawn or \"auto\"\n   * @property {ShardingManagerMode} [mode='process'] Which mode to use for shards\n   * @property {boolean} [respawn=true] Whether shards should automatically respawn upon exiting\n   * @property {string[]} [shardArgs=[]] Arguments to pass to the shard script when spawning\n   * (only available when mode is set to 'process')\n   * @property {string[]} [execArgv=[]] Arguments to pass to the shard script executable when spawning\n   * (only available when mode is set to 'process')\n   * @property {string} [token] Token to use for automatic shard count and passing to shards\n   */\n\n  /**\n   * @param {string} file Path to your shard script file\n   * @param {ShardingManagerOptions} [options] Options for the sharding manager\n   */\n  constructor(file, options = {}) {\n    super();\n    options = mergeDefault(\n      {\n        totalShards: 'auto',\n        mode: 'process',\n        respawn: true,\n        shardArgs: [],\n        execArgv: [],\n        token: process.env.DISCORD_TOKEN,\n      },\n      options,\n    );\n\n    /**\n     * Path to the shard script file\n     * @type {string}\n     */\n    this.file = file;\n    if (!file) throw new DiscordjsError(ErrorCodes.ClientInvalidOption, 'File', 'specified.');\n    if (!path.isAbsolute(file)) this.file = path.resolve(process.cwd(), file);\n    const stats = fs.statSync(this.file);\n    if (!stats.isFile()) throw new DiscordjsError(ErrorCodes.ClientInvalidOption, 'File', 'a file');\n\n    /**\n     * List of shards this sharding manager spawns\n     * @type {string|number[]}\n     */\n    this.shardList = options.shardList ?? 'auto';\n    if (this.shardList !== 'auto') {\n      if (!Array.isArray(this.shardList)) {\n        throw new DiscordjsTypeError(ErrorCodes.ClientInvalidOption, 'shardList', 'an array.');\n      }\n      this.shardList = [...new Set(this.shardList)];\n      if (this.shardList.length < 1) {\n        throw new DiscordjsRangeError(ErrorCodes.ClientInvalidOption, 'shardList', 'at least 1 id.');\n      }\n      if (\n        this.shardList.some(\n          shardId => typeof shardId !== 'number' || isNaN(shardId) || !Number.isInteger(shardId) || shardId < 0,\n        )\n      ) {\n        throw new DiscordjsTypeError(ErrorCodes.ClientInvalidOption, 'shardList', 'an array of positive integers.');\n      }\n    }\n\n    /**\n     * Amount of shards that all sharding managers spawn in total\n     * @type {number}\n     */\n    this.totalShards = options.totalShards || 'auto';\n    if (this.totalShards !== 'auto') {\n      if (typeof this.totalShards !== 'number' || isNaN(this.totalShards)) {\n        throw new DiscordjsTypeError(ErrorCodes.ClientInvalidOption, 'Amount of shards', 'a number.');\n      }\n      if (this.totalShards < 1) {\n        throw new DiscordjsRangeError(ErrorCodes.ClientInvalidOption, 'Amount of shards', 'at least 1.');\n      }\n      if (!Number.isInteger(this.totalShards)) {\n        throw new DiscordjsRangeError(ErrorCodes.ClientInvalidOption, 'Amount of shards', 'an integer.');\n      }\n    }\n\n    /**\n     * Mode for shards to spawn with\n     * @type {ShardingManagerMode}\n     */\n    this.mode = options.mode;\n    if (this.mode !== 'process' && this.mode !== 'worker') {\n      throw new DiscordjsRangeError(ErrorCodes.ClientInvalidOption, 'Sharding mode', '\"process\" or \"worker\"');\n    }\n\n    /**\n     * Whether shards should automatically respawn upon exiting\n     * @type {boolean}\n     */\n    this.respawn = options.respawn;\n\n    /**\n     * An array of arguments to pass to shards (only when {@link ShardingManager#mode} is `process`)\n     * @type {string[]}\n     */\n    this.shardArgs = options.shardArgs;\n\n    /**\n     * An array of arguments to pass to the executable (only when {@link ShardingManager#mode} is `process`)\n     * @type {string[]}\n     */\n    this.execArgv = options.execArgv;\n\n    /**\n     * Token to use for obtaining the automatic shard count, and passing to shards\n     * @type {?string}\n     */\n    this.token = options.token?.replace(/^Bot\\s*/i, '') ?? null;\n\n    /**\n     * A collection of shards that this manager has spawned\n     * @type {Collection<number, Shard>}\n     */\n    this.shards = new Collection();\n\n    process.env.SHARDING_MANAGER = true;\n    process.env.SHARDING_MANAGER_MODE = this.mode;\n    process.env.DISCORD_TOKEN = this.token;\n  }\n\n  /**\n   * Creates a single shard.\n   * <warn>Using this method is usually not necessary if you use the spawn method.</warn>\n   * @param {number} [id=this.shards.size] Id of the shard to create\n   * <info>This is usually not necessary to manually specify.</info>\n   * @returns {Shard} Note that the created shard needs to be explicitly spawned using its spawn method.\n   */\n  createShard(id = this.shards.size) {\n    const shard = new Shard(this, id);\n    this.shards.set(id, shard);\n    /**\n     * Emitted upon creating a shard.\n     * @event ShardingManager#shardCreate\n     * @param {Shard} shard Shard that was created\n     */\n    this.emit('shardCreate', shard);\n    return shard;\n  }\n\n  /**\n   * Options used to spawn multiple shards.\n   * @typedef {Object} MultipleShardSpawnOptions\n   * @property {number|string} [amount=this.totalShards] Number of shards to spawn\n   * @property {number} [delay=5500] How long to wait in between spawning each shard (in milliseconds)\n   * @property {number} [timeout=30000] The amount in milliseconds to wait until the {@link Client} has become ready\n   */\n\n  /**\n   * Spawns multiple shards.\n   * @param {MultipleShardSpawnOptions} [options] Options for spawning shards\n   * @returns {Promise<Collection<number, Shard>>}\n   */\n  async spawn({ amount = this.totalShards, delay = 5500, timeout = 30_000 } = {}) {\n    // Obtain/verify the number of shards to spawn\n    if (amount === 'auto') {\n      amount = await fetchRecommendedShardCount(this.token);\n    } else {\n      if (typeof amount !== 'number' || isNaN(amount)) {\n        throw new DiscordjsTypeError(ErrorCodes.ClientInvalidOption, 'Amount of shards', 'a number.');\n      }\n      if (amount < 1) throw new DiscordjsRangeError(ErrorCodes.ClientInvalidOption, 'Amount of shards', 'at least 1.');\n      if (!Number.isInteger(amount)) {\n        throw new DiscordjsTypeError(ErrorCodes.ClientInvalidOption, 'Amount of shards', 'an integer.');\n      }\n    }\n\n    // Make sure this many shards haven't already been spawned\n    if (this.shards.size >= amount) throw new DiscordjsError(ErrorCodes.ShardingAlreadySpawned, this.shards.size);\n    if (this.shardList === 'auto' || this.totalShards === 'auto' || this.totalShards !== amount) {\n      this.shardList = [...Array(amount).keys()];\n    }\n    if (this.totalShards === 'auto' || this.totalShards !== amount) {\n      this.totalShards = amount;\n    }\n\n    if (this.shardList.some(shardId => shardId >= amount)) {\n      throw new DiscordjsRangeError(\n        ErrorCodes.ClientInvalidOption,\n        'Amount of shards',\n        'bigger than the highest shardId in the shardList option.',\n      );\n    }\n\n    // Spawn the shards\n    for (const shardId of this.shardList) {\n      const promises = [];\n      const shard = this.createShard(shardId);\n      promises.push(shard.spawn(timeout));\n      if (delay > 0 && this.shards.size !== this.shardList.length) promises.push(sleep(delay));\n      await Promise.all(promises); // eslint-disable-line no-await-in-loop\n    }\n\n    return this.shards;\n  }\n\n  /**\n   * Sends a message to all shards.\n   * @param {*} message Message to be sent to the shards\n   * @returns {Promise<Shard[]>}\n   */\n  broadcast(message) {\n    const promises = [];\n    for (const shard of this.shards.values()) promises.push(shard.send(message));\n    return Promise.all(promises);\n  }\n\n  /**\n   * Options for {@link ShardingManager#broadcastEval} and {@link ShardClientUtil#broadcastEval}.\n   * @typedef {Object} BroadcastEvalOptions\n   * @property {number} [shard] Shard to run script on, all if undefined\n   * @property {*} [context] The JSON-serializable values to call the script with\n   */\n\n  /**\n   * Evaluates a script on all shards, or a given shard, in the context of the {@link Client}s.\n   * @param {Function} script JavaScript to run on each shard\n   * @param {BroadcastEvalOptions} [options={}] The options for the broadcast\n   * @returns {Promise<*|Array<*>>} Results of the script execution\n   */\n  broadcastEval(script, options = {}) {\n    if (typeof script !== 'function') {\n      return Promise.reject(new DiscordjsTypeError(ErrorCodes.ShardingInvalidEvalBroadcast));\n    }\n    return this._performOnShards('eval', [`(${script})(this, ${JSON.stringify(options.context)})`], options.shard);\n  }\n\n  /**\n   * Fetches a client property value of each shard, or a given shard.\n   * @param {string} prop Name of the client property to get, using periods for nesting\n   * @param {number} [shard] Shard to fetch property from, all if undefined\n   * @returns {Promise<*|Array<*>>}\n   * @example\n   * manager.fetchClientValues('guilds.cache.size')\n   *   .then(results => console.log(`${results.reduce((prev, val) => prev + val, 0)} total guilds`))\n   *   .catch(console.error);\n   */\n  fetchClientValues(prop, shard) {\n    return this._performOnShards('fetchClientValue', [prop], shard);\n  }\n\n  /**\n   * Runs a method with given arguments on all shards, or a given shard.\n   * @param {string} method Method name to run on each shard\n   * @param {Array<*>} args Arguments to pass through to the method call\n   * @param {number} [shard] Shard to run on, all if undefined\n   * @returns {Promise<*|Array<*>>} Results of the method execution\n   * @private\n   */\n  _performOnShards(method, args, shard) {\n    if (this.shards.size === 0) return Promise.reject(new DiscordjsError(ErrorCodes.ShardingNoShards));\n\n    if (typeof shard === 'number') {\n      if (this.shards.has(shard)) return this.shards.get(shard)[method](...args);\n      return Promise.reject(new DiscordjsError(ErrorCodes.ShardingShardNotFound, shard));\n    }\n\n    if (this.shards.size !== this.shardList.length) {\n      return Promise.reject(new DiscordjsError(ErrorCodes.ShardingInProcess));\n    }\n\n    const promises = [];\n    for (const sh of this.shards.values()) promises.push(sh[method](...args));\n    return Promise.all(promises);\n  }\n\n  /**\n   * Options used to respawn all shards.\n   * @typedef {Object} MultipleShardRespawnOptions\n   * @property {number} [shardDelay=5000] How long to wait between shards (in milliseconds)\n   * @property {number} [respawnDelay=500] How long to wait between killing a shard's process and restarting it\n   * (in milliseconds)\n   * @property {number} [timeout=30000] The amount in milliseconds to wait for a shard to become ready before\n   * continuing to another (`-1` or `Infinity` for no wait)\n   */\n\n  /**\n   * Kills all running shards and respawns them.\n   * @param {MultipleShardRespawnOptions} [options] Options for respawning shards\n   * @returns {Promise<Collection<number, Shard>>}\n   */\n  async respawnAll({ shardDelay = 5_000, respawnDelay = 500, timeout = 30_000 } = {}) {\n    let s = 0;\n    for (const shard of this.shards.values()) {\n      const promises = [shard.respawn({ delay: respawnDelay, timeout })];\n      if (++s < this.shards.size && shardDelay > 0) promises.push(sleep(shardDelay));\n      await Promise.all(promises); // eslint-disable-line no-await-in-loop\n    }\n    return this.shards;\n  }\n}\n\nmodule.exports = ShardingManager;\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}