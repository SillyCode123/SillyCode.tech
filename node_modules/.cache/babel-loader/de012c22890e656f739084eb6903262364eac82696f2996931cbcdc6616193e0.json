{"ast":null,"code":"'use strict';\n\nconst Collector = require('./interfaces/Collector');\nconst Events = require('../util/Events');\n\n/**\n * @typedef {CollectorOptions} MessageCollectorOptions\n * @property {number} max The maximum amount of messages to collect\n * @property {number} maxProcessed The maximum amount of messages to process\n */\n\n/**\n * Collects messages on a channel.\n * Will automatically stop if the channel ({@link Client#event:channelDelete channelDelete}),\n * thread ({@link Client#event:threadDelete threadDelete}), or\n * guild ({@link Client#event:guildDelete guildDelete}) is deleted.\n * @extends {Collector}\n */\nclass MessageCollector extends Collector {\n  /**\n   * @param {TextBasedChannels} channel The channel\n   * @param {MessageCollectorOptions} options The options to be applied to this collector\n   * @emits MessageCollector#message\n   */\n  constructor(channel) {\n    let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    super(channel.client, options);\n\n    /**\n     * The channel\n     * @type {TextBasedChannels}\n     */\n    this.channel = channel;\n\n    /**\n     * Total number of messages that were received in the channel during message collection\n     * @type {number}\n     */\n    this.received = 0;\n    const bulkDeleteListener = messages => {\n      for (const message of messages.values()) this.handleDispose(message);\n    };\n    this._handleChannelDeletion = this._handleChannelDeletion.bind(this);\n    this._handleThreadDeletion = this._handleThreadDeletion.bind(this);\n    this._handleGuildDeletion = this._handleGuildDeletion.bind(this);\n    this.client.incrementMaxListeners();\n    this.client.on(Events.MessageCreate, this.handleCollect);\n    this.client.on(Events.MessageDelete, this.handleDispose);\n    this.client.on(Events.MessageBulkDelete, bulkDeleteListener);\n    this.client.on(Events.ChannelDelete, this._handleChannelDeletion);\n    this.client.on(Events.ThreadDelete, this._handleThreadDeletion);\n    this.client.on(Events.GuildDelete, this._handleGuildDeletion);\n    this.once('end', () => {\n      this.client.removeListener(Events.MessageCreate, this.handleCollect);\n      this.client.removeListener(Events.MessageDelete, this.handleDispose);\n      this.client.removeListener(Events.MessageBulkDelete, bulkDeleteListener);\n      this.client.removeListener(Events.ChannelDelete, this._handleChannelDeletion);\n      this.client.removeListener(Events.ThreadDelete, this._handleThreadDeletion);\n      this.client.removeListener(Events.GuildDelete, this._handleGuildDeletion);\n      this.client.decrementMaxListeners();\n    });\n  }\n\n  /**\n   * Handles a message for possible collection.\n   * @param {Message} message The message that could be collected\n   * @returns {?Snowflake}\n   * @private\n   */\n  collect(message) {\n    /**\n     * Emitted whenever a message is collected.\n     * @event MessageCollector#collect\n     * @param {Message} message The message that was collected\n     */\n    if (message.channelId !== this.channel.id) return null;\n    this.received++;\n    return message.id;\n  }\n\n  /**\n   * Handles a message for possible disposal.\n   * @param {Message} message The message that could be disposed of\n   * @returns {?Snowflake}\n   */\n  dispose(message) {\n    /**\n     * Emitted whenever a message is disposed of.\n     * @event MessageCollector#dispose\n     * @param {Message} message The message that was disposed of\n     */\n    return message.channelId === this.channel.id ? message.id : null;\n  }\n\n  /**\n   * The reason this collector has ended with, or null if it hasn't ended yet\n   * @type {?string}\n   * @readonly\n   */\n  get endReason() {\n    if (this.options.max && this.collected.size >= this.options.max) return 'limit';\n    if (this.options.maxProcessed && this.received === this.options.maxProcessed) return 'processedLimit';\n    return super.endReason;\n  }\n\n  /**\n   * Handles checking if the channel has been deleted, and if so, stops the collector with the reason 'channelDelete'.\n   * @private\n   * @param {GuildChannel} channel The channel that was deleted\n   * @returns {void}\n   */\n  _handleChannelDeletion(channel) {\n    if (channel.id === this.channel.id || channel.id === this.channel.parentId) {\n      this.stop('channelDelete');\n    }\n  }\n\n  /**\n   * Handles checking if the thread has been deleted, and if so, stops the collector with the reason 'threadDelete'.\n   * @private\n   * @param {ThreadChannel} thread The thread that was deleted\n   * @returns {void}\n   */\n  _handleThreadDeletion(thread) {\n    if (thread.id === this.channel.id) {\n      this.stop('threadDelete');\n    }\n  }\n\n  /**\n   * Handles checking if the guild has been deleted, and if so, stops the collector with the reason 'guildDelete'.\n   * @private\n   * @param {Guild} guild The guild that was deleted\n   * @returns {void}\n   */\n  _handleGuildDeletion(guild) {\n    if (guild.id === this.channel.guild?.id) {\n      this.stop('guildDelete');\n    }\n  }\n}\nmodule.exports = MessageCollector;","map":{"version":3,"names":["Collector","require","Events","MessageCollector","constructor","channel","options","client","received","bulkDeleteListener","messages","message","values","handleDispose","_handleChannelDeletion","bind","_handleThreadDeletion","_handleGuildDeletion","incrementMaxListeners","on","MessageCreate","handleCollect","MessageDelete","MessageBulkDelete","ChannelDelete","ThreadDelete","GuildDelete","once","removeListener","decrementMaxListeners","collect","channelId","id","dispose","endReason","max","collected","size","maxProcessed","parentId","stop","thread","guild","module","exports"],"sources":["J:/Coding/Projekts/Web/JavaScript/sillcode.tech/node_modules/discord.js/src/structures/MessageCollector.js"],"sourcesContent":["'use strict';\n\nconst Collector = require('./interfaces/Collector');\nconst Events = require('../util/Events');\n\n/**\n * @typedef {CollectorOptions} MessageCollectorOptions\n * @property {number} max The maximum amount of messages to collect\n * @property {number} maxProcessed The maximum amount of messages to process\n */\n\n/**\n * Collects messages on a channel.\n * Will automatically stop if the channel ({@link Client#event:channelDelete channelDelete}),\n * thread ({@link Client#event:threadDelete threadDelete}), or\n * guild ({@link Client#event:guildDelete guildDelete}) is deleted.\n * @extends {Collector}\n */\nclass MessageCollector extends Collector {\n  /**\n   * @param {TextBasedChannels} channel The channel\n   * @param {MessageCollectorOptions} options The options to be applied to this collector\n   * @emits MessageCollector#message\n   */\n  constructor(channel, options = {}) {\n    super(channel.client, options);\n\n    /**\n     * The channel\n     * @type {TextBasedChannels}\n     */\n    this.channel = channel;\n\n    /**\n     * Total number of messages that were received in the channel during message collection\n     * @type {number}\n     */\n    this.received = 0;\n\n    const bulkDeleteListener = messages => {\n      for (const message of messages.values()) this.handleDispose(message);\n    };\n\n    this._handleChannelDeletion = this._handleChannelDeletion.bind(this);\n    this._handleThreadDeletion = this._handleThreadDeletion.bind(this);\n    this._handleGuildDeletion = this._handleGuildDeletion.bind(this);\n\n    this.client.incrementMaxListeners();\n    this.client.on(Events.MessageCreate, this.handleCollect);\n    this.client.on(Events.MessageDelete, this.handleDispose);\n    this.client.on(Events.MessageBulkDelete, bulkDeleteListener);\n    this.client.on(Events.ChannelDelete, this._handleChannelDeletion);\n    this.client.on(Events.ThreadDelete, this._handleThreadDeletion);\n    this.client.on(Events.GuildDelete, this._handleGuildDeletion);\n\n    this.once('end', () => {\n      this.client.removeListener(Events.MessageCreate, this.handleCollect);\n      this.client.removeListener(Events.MessageDelete, this.handleDispose);\n      this.client.removeListener(Events.MessageBulkDelete, bulkDeleteListener);\n      this.client.removeListener(Events.ChannelDelete, this._handleChannelDeletion);\n      this.client.removeListener(Events.ThreadDelete, this._handleThreadDeletion);\n      this.client.removeListener(Events.GuildDelete, this._handleGuildDeletion);\n      this.client.decrementMaxListeners();\n    });\n  }\n\n  /**\n   * Handles a message for possible collection.\n   * @param {Message} message The message that could be collected\n   * @returns {?Snowflake}\n   * @private\n   */\n  collect(message) {\n    /**\n     * Emitted whenever a message is collected.\n     * @event MessageCollector#collect\n     * @param {Message} message The message that was collected\n     */\n    if (message.channelId !== this.channel.id) return null;\n    this.received++;\n    return message.id;\n  }\n\n  /**\n   * Handles a message for possible disposal.\n   * @param {Message} message The message that could be disposed of\n   * @returns {?Snowflake}\n   */\n  dispose(message) {\n    /**\n     * Emitted whenever a message is disposed of.\n     * @event MessageCollector#dispose\n     * @param {Message} message The message that was disposed of\n     */\n    return message.channelId === this.channel.id ? message.id : null;\n  }\n\n  /**\n   * The reason this collector has ended with, or null if it hasn't ended yet\n   * @type {?string}\n   * @readonly\n   */\n  get endReason() {\n    if (this.options.max && this.collected.size >= this.options.max) return 'limit';\n    if (this.options.maxProcessed && this.received === this.options.maxProcessed) return 'processedLimit';\n    return super.endReason;\n  }\n\n  /**\n   * Handles checking if the channel has been deleted, and if so, stops the collector with the reason 'channelDelete'.\n   * @private\n   * @param {GuildChannel} channel The channel that was deleted\n   * @returns {void}\n   */\n  _handleChannelDeletion(channel) {\n    if (channel.id === this.channel.id || channel.id === this.channel.parentId) {\n      this.stop('channelDelete');\n    }\n  }\n\n  /**\n   * Handles checking if the thread has been deleted, and if so, stops the collector with the reason 'threadDelete'.\n   * @private\n   * @param {ThreadChannel} thread The thread that was deleted\n   * @returns {void}\n   */\n  _handleThreadDeletion(thread) {\n    if (thread.id === this.channel.id) {\n      this.stop('threadDelete');\n    }\n  }\n\n  /**\n   * Handles checking if the guild has been deleted, and if so, stops the collector with the reason 'guildDelete'.\n   * @private\n   * @param {Guild} guild The guild that was deleted\n   * @returns {void}\n   */\n  _handleGuildDeletion(guild) {\n    if (guild.id === this.channel.guild?.id) {\n      this.stop('guildDelete');\n    }\n  }\n}\n\nmodule.exports = MessageCollector;\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}