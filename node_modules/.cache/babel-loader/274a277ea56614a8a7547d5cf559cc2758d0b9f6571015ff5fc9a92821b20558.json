{"ast":null,"code":"'use strict';\n\nconst {\n  parse\n} = require('node:path');\nconst {\n  Collection\n} = require('@discordjs/collection');\nconst {\n  ChannelType,\n  RouteBases,\n  Routes\n} = require('discord-api-types/v10');\nconst {\n  fetch\n} = require('undici');\nconst Colors = require('./Colors');\nconst {\n  DiscordjsError,\n  DiscordjsRangeError,\n  DiscordjsTypeError,\n  ErrorCodes\n} = require('../errors');\nconst isObject = d => typeof d === 'object' && d !== null;\n\n/**\n * Flatten an object. Any properties that are collections will get converted to an array of keys.\n * @param {Object} obj The object to flatten.\n * @param {...Object<string, boolean|string>} [props] Specific properties to include/exclude.\n * @returns {Object}\n */\nfunction flatten(obj) {\n  for (var _len = arguments.length, props = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n    props[_key - 1] = arguments[_key];\n  }\n  if (!isObject(obj)) return obj;\n  const objProps = Object.keys(obj).filter(k => !k.startsWith('_')).map(k => ({\n    [k]: true\n  }));\n  props = objProps.length ? Object.assign(...objProps, ...props) : Object.assign({}, ...props);\n  const out = {};\n  for (let [prop, newProp] of Object.entries(props)) {\n    if (!newProp) continue;\n    newProp = newProp === true ? prop : newProp;\n    const element = obj[prop];\n    const elemIsObj = isObject(element);\n    const valueOf = elemIsObj && typeof element.valueOf === 'function' ? element.valueOf() : null;\n    const hasToJSON = elemIsObj && typeof element.toJSON === 'function';\n\n    // If it's a Collection, make the array of keys\n    if (element instanceof Collection) out[newProp] = Array.from(element.keys());\n    // If the valueOf is a Collection, use its array of keys\n    else if (valueOf instanceof Collection) out[newProp] = Array.from(valueOf.keys());\n    // If it's an array, call toJSON function on each element if present, otherwise flatten each element\n    else if (Array.isArray(element)) out[newProp] = element.map(e => e.toJSON?.() ?? flatten(e));\n    // If it's an object with a primitive `valueOf`, use that value\n    else if (typeof valueOf !== 'object') out[newProp] = valueOf;\n    // If it's an object with a toJSON function, use the return value of it\n    else if (hasToJSON) out[newProp] = element.toJSON();\n    // If element is an object, use the flattened version of it\n    else if (typeof element === 'object') out[newProp] = flatten(element);\n    // If it's a primitive\n    else if (!elemIsObj) out[newProp] = element;\n  }\n  return out;\n}\n\n/**\n * Options used to escape markdown.\n * @typedef {Object} EscapeMarkdownOptions\n * @property {boolean} [codeBlock=true] Whether to escape code blocks\n * @property {boolean} [inlineCode=true] Whether to escape inline code\n * @property {boolean} [bold=true] Whether to escape bolds\n * @property {boolean} [italic=true] Whether to escape italics\n * @property {boolean} [underline=true] Whether to escape underlines\n * @property {boolean} [strikethrough=true] Whether to escape strikethroughs\n * @property {boolean} [spoiler=true] Whether to escape spoilers\n * @property {boolean} [codeBlockContent=true] Whether to escape text inside code blocks\n * @property {boolean} [inlineCodeContent=true] Whether to escape text inside inline code\n * @property {boolean} [escape=true] Whether to escape escape characters\n * @property {boolean} [heading=false] Whether to escape headings\n * @property {boolean} [bulletedList=false] Whether to escape bulleted lists\n * @property {boolean} [numberedList=false] Whether to escape numbered lists\n * @property {boolean} [maskedLink=false] Whether to escape masked links\n */\n\n/**\n * Escapes any Discord-flavour markdown in a string.\n * @param {string} text Content to escape\n * @param {EscapeMarkdownOptions} [options={}] Options for escaping the markdown\n * @returns {string}\n */\nfunction escapeMarkdown(text) {\n  let {\n    codeBlock = true,\n    inlineCode = true,\n    bold = true,\n    italic = true,\n    underline = true,\n    strikethrough = true,\n    spoiler = true,\n    codeBlockContent = true,\n    inlineCodeContent = true,\n    escape = true,\n    heading = false,\n    bulletedList = false,\n    numberedList = false,\n    maskedLink = false\n  } = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  if (!codeBlockContent) {\n    return text.split('```').map((subString, index, array) => {\n      if (index % 2 && index !== array.length - 1) return subString;\n      return escapeMarkdown(subString, {\n        inlineCode,\n        bold,\n        italic,\n        underline,\n        strikethrough,\n        spoiler,\n        inlineCodeContent,\n        escape,\n        heading,\n        bulletedList,\n        numberedList,\n        maskedLink\n      });\n    }).join(codeBlock ? '\\\\`\\\\`\\\\`' : '```');\n  }\n  if (!inlineCodeContent) {\n    return text.split(/(?<=^|[^`])`(?=[^`]|$)/g).map((subString, index, array) => {\n      if (index % 2 && index !== array.length - 1) return subString;\n      return escapeMarkdown(subString, {\n        codeBlock,\n        bold,\n        italic,\n        underline,\n        strikethrough,\n        spoiler,\n        escape,\n        heading,\n        bulletedList,\n        numberedList,\n        maskedLink\n      });\n    }).join(inlineCode ? '\\\\`' : '`');\n  }\n  if (escape) text = escapeEscape(text);\n  if (inlineCode) text = escapeInlineCode(text);\n  if (codeBlock) text = escapeCodeBlock(text);\n  if (italic) text = escapeItalic(text);\n  if (bold) text = escapeBold(text);\n  if (underline) text = escapeUnderline(text);\n  if (strikethrough) text = escapeStrikethrough(text);\n  if (spoiler) text = escapeSpoiler(text);\n  if (heading) text = escapeHeading(text);\n  if (bulletedList) text = escapeBulletedList(text);\n  if (numberedList) text = escapeNumberedList(text);\n  if (maskedLink) text = escapeMaskedLink(text);\n  return text;\n}\n\n/**\n * Escapes code block markdown in a string.\n * @param {string} text Content to escape\n * @returns {string}\n */\nfunction escapeCodeBlock(text) {\n  return text.replaceAll('```', '\\\\`\\\\`\\\\`');\n}\n\n/**\n * Escapes inline code markdown in a string.\n * @param {string} text Content to escape\n * @returns {string}\n */\nfunction escapeInlineCode(text) {\n  return text.replace(/(?<=^|[^`])``?(?=[^`]|$)/g, match => match.length === 2 ? '\\\\`\\\\`' : '\\\\`');\n}\n\n/**\n * Escapes italic markdown in a string.\n * @param {string} text Content to escape\n * @returns {string}\n */\nfunction escapeItalic(text) {\n  let i = 0;\n  text = text.replace(/(?<=^|[^*])\\*([^*]|\\*\\*|$)/g, (_, match) => {\n    if (match === '**') return ++i % 2 ? `\\\\*${match}` : `${match}\\\\*`;\n    return `\\\\*${match}`;\n  });\n  i = 0;\n  return text.replace(/(?<=^|[^_])_([^_]|__|$)/g, (_, match) => {\n    if (match === '__') return ++i % 2 ? `\\\\_${match}` : `${match}\\\\_`;\n    return `\\\\_${match}`;\n  });\n}\n\n/**\n * Escapes bold markdown in a string.\n * @param {string} text Content to escape\n * @returns {string}\n */\nfunction escapeBold(text) {\n  let i = 0;\n  return text.replace(/\\*\\*(\\*)?/g, (_, match) => {\n    if (match) return ++i % 2 ? `${match}\\\\*\\\\*` : `\\\\*\\\\*${match}`;\n    return '\\\\*\\\\*';\n  });\n}\n\n/**\n * Escapes underline markdown in a string.\n * @param {string} text Content to escape\n * @returns {string}\n */\nfunction escapeUnderline(text) {\n  let i = 0;\n  return text.replace(/__(_)?/g, (_, match) => {\n    if (match) return ++i % 2 ? `${match}\\\\_\\\\_` : `\\\\_\\\\_${match}`;\n    return '\\\\_\\\\_';\n  });\n}\n\n/**\n * Escapes strikethrough markdown in a string.\n * @param {string} text Content to escape\n * @returns {string}\n */\nfunction escapeStrikethrough(text) {\n  return text.replaceAll('~~', '\\\\~\\\\~');\n}\n\n/**\n * Escapes spoiler markdown in a string.\n * @param {string} text Content to escape\n * @returns {string}\n */\nfunction escapeSpoiler(text) {\n  return text.replaceAll('||', '\\\\|\\\\|');\n}\n\n/**\n * Escapes escape characters in a string.\n * @param {string} text Content to escape\n * @returns {string}\n */\nfunction escapeEscape(text) {\n  return text.replaceAll('\\\\', '\\\\\\\\');\n}\n\n/**\n * Escapes heading characters in a string.\n * @param {string} text Content to escape\n * @returns {string}\n */\nfunction escapeHeading(text) {\n  return text.replaceAll(/^( {0,2}[*-] +)?(#{1,3} )/gm, '$1\\\\$2');\n}\n\n/**\n * Escapes bulleted list characters in a string.\n * @param {string} text Content to escape\n * @returns {string}\n */\nfunction escapeBulletedList(text) {\n  return text.replaceAll(/^( *)[*-]( +)/gm, '$1\\\\-$2');\n}\n\n/**\n * Escapes numbered list characters in a string.\n * @param {string} text Content to escape\n * @returns {string}\n */\nfunction escapeNumberedList(text) {\n  return text.replaceAll(/^( *\\d+)\\./gm, '$1\\\\.');\n}\n\n/**\n * Escapes masked link characters in a string.\n * @param {string} text Content to escape\n * @returns {string}\n */\nfunction escapeMaskedLink(text) {\n  return text.replaceAll(/\\[.+\\]\\(.+\\)/gm, '\\\\$&');\n}\n\n/**\n * @typedef {Object} FetchRecommendedShardCountOptions\n * @property {number} [guildsPerShard=1000] Number of guilds assigned per shard\n * @property {number} [multipleOf=1] The multiple the shard count should round up to. (16 for large bot sharding)\n */\n\n/**\n * Gets the recommended shard count from Discord.\n * @param {string} token Discord auth token\n * @param {FetchRecommendedShardCountOptions} [options] Options for fetching the recommended shard count\n * @returns {Promise<number>} The recommended number of shards\n */\nasync function fetchRecommendedShardCount(token) {\n  let {\n    guildsPerShard = 1_000,\n    multipleOf = 1\n  } = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  if (!token) throw new DiscordjsError(ErrorCodes.TokenMissing);\n  const response = await fetch(RouteBases.api + Routes.gatewayBot(), {\n    method: 'GET',\n    headers: {\n      Authorization: `Bot ${token.replace(/^Bot\\s*/i, '')}`\n    }\n  });\n  if (!response.ok) {\n    if (response.status === 401) throw new DiscordjsError(ErrorCodes.TokenInvalid);\n    throw response;\n  }\n  const {\n    shards\n  } = await response.json();\n  return Math.ceil(shards * (1_000 / guildsPerShard) / multipleOf) * multipleOf;\n}\n\n/**\n * Parses emoji info out of a string. The string must be one of:\n * * A UTF-8 emoji (no id)\n * * A URL-encoded UTF-8 emoji (no id)\n * * A Discord custom emoji (`<:name:id>` or `<a:name:id>`)\n * @param {string} text Emoji string to parse\n * @returns {APIEmoji} Object with `animated`, `name`, and `id` properties\n */\nfunction parseEmoji(text) {\n  if (text.includes('%')) text = decodeURIComponent(text);\n  if (!text.includes(':')) return {\n    animated: false,\n    name: text,\n    id: undefined\n  };\n  const match = text.match(/<?(?:(a):)?(\\w{2,32}):(\\d{17,19})?>?/);\n  return match && {\n    animated: Boolean(match[1]),\n    name: match[2],\n    id: match[3]\n  };\n}\n\n/**\n * Resolves a partial emoji object from an {@link EmojiIdentifierResolvable}, without checking a Client.\n * @param {EmojiIdentifierResolvable} emoji Emoji identifier to resolve\n * @returns {?RawEmoji}\n * @private\n */\nfunction resolvePartialEmoji(emoji) {\n  if (!emoji) return null;\n  if (typeof emoji === 'string') return /^\\d{17,19}$/.test(emoji) ? {\n    id: emoji\n  } : parseEmoji(emoji);\n  const {\n    id,\n    name,\n    animated\n  } = emoji;\n  if (!id && !name) return null;\n  return {\n    id,\n    name,\n    animated: Boolean(animated)\n  };\n}\n\n/**\n * Sets default properties on an object that aren't already specified.\n * @param {Object} def Default properties\n * @param {Object} given Object to assign defaults to\n * @returns {Object}\n * @private\n */\nfunction mergeDefault(def, given) {\n  if (!given) return def;\n  for (const key in def) {\n    if (!Object.hasOwn(given, key) || given[key] === undefined) {\n      given[key] = def[key];\n    } else if (given[key] === Object(given[key])) {\n      given[key] = mergeDefault(def[key], given[key]);\n    }\n  }\n  return given;\n}\n\n/**\n * Options used to make an error object.\n * @typedef {Object} MakeErrorOptions\n * @property {string} name Error type\n * @property {string} message Message for the error\n * @property {string} stack Stack for the error\n */\n\n/**\n * Makes an Error from a plain info object.\n * @param {MakeErrorOptions} obj Error info\n * @returns {Error}\n * @private\n */\nfunction makeError(obj) {\n  const err = new Error(obj.message);\n  err.name = obj.name;\n  err.stack = obj.stack;\n  return err;\n}\n\n/**\n * Makes a plain error info object from an Error.\n * @param {Error} err Error to get info from\n * @returns {MakeErrorOptions}\n * @private\n */\nfunction makePlainError(err) {\n  return {\n    name: err.name,\n    message: err.message,\n    stack: err.stack\n  };\n}\n\n/**\n * Moves an element in an array *in place*.\n * @param {Array<*>} array Array to modify\n * @param {*} element Element to move\n * @param {number} newIndex Index or offset to move the element to\n * @param {boolean} [offset=false] Move the element by an offset amount rather than to a set index\n * @returns {number}\n * @private\n */\nfunction moveElementInArray(array, element, newIndex) {\n  let offset = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;\n  const index = array.indexOf(element);\n  newIndex = (offset ? index : 0) + newIndex;\n  if (newIndex > -1 && newIndex < array.length) {\n    const removedElement = array.splice(index, 1)[0];\n    array.splice(newIndex, 0, removedElement);\n  }\n  return array.indexOf(element);\n}\n\n/**\n * Verifies the provided data is a string, otherwise throws provided error.\n * @param {string} data The string resolvable to resolve\n * @param {Function} [error] The Error constructor to instantiate. Defaults to Error\n * @param {string} [errorMessage] The error message to throw with. Defaults to \"Expected string, got <data> instead.\"\n * @param {boolean} [allowEmpty=true] Whether an empty string should be allowed\n * @returns {string}\n */\nfunction verifyString(data) {\n  let error = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : Error;\n  let errorMessage = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : `Expected a string, got ${data} instead.`;\n  let allowEmpty = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : true;\n  if (typeof data !== 'string') throw new error(errorMessage);\n  if (!allowEmpty && data.length === 0) throw new error(errorMessage);\n  return data;\n}\n\n/**\n * Can be a number, hex string, an RGB array like:\n * ```js\n * [255, 0, 255] // purple\n * ```\n * or one of the following strings:\n * - `Default`\n * - `White`\n * - `Aqua`\n * - `Green`\n * - `Blue`\n * - `Yellow`\n * - `Purple`\n * - `LuminousVividPink`\n * - `Fuchsia`\n * - `Gold`\n * - `Orange`\n * - `Red`\n * - `Grey`\n * - `Navy`\n * - `DarkAqua`\n * - `DarkGreen`\n * - `DarkBlue`\n * - `DarkPurple`\n * - `DarkVividPink`\n * - `DarkGold`\n * - `DarkOrange`\n * - `DarkRed`\n * - `DarkGrey`\n * - `DarkerGrey`\n * - `LightGrey`\n * - `DarkNavy`\n * - `Blurple`\n * - `Greyple`\n * - `DarkButNotBlack`\n * - `NotQuiteBlack`\n * - `Random`\n * @typedef {string|number|number[]} ColorResolvable\n */\n\n/**\n * Resolves a ColorResolvable into a color number.\n * @param {ColorResolvable} color Color to resolve\n * @returns {number} A color\n */\nfunction resolveColor(color) {\n  if (typeof color === 'string') {\n    if (color === 'Random') return Math.floor(Math.random() * (0xffffff + 1));\n    if (color === 'Default') return 0;\n    color = Colors[color] ?? parseInt(color.replace('#', ''), 16);\n  } else if (Array.isArray(color)) {\n    color = (color[0] << 16) + (color[1] << 8) + color[2];\n  }\n  if (color < 0 || color > 0xffffff) throw new DiscordjsRangeError(ErrorCodes.ColorRange);else if (Number.isNaN(color)) throw new DiscordjsTypeError(ErrorCodes.ColorConvert);\n  return color;\n}\n\n/**\n * Sorts by Discord's position and id.\n * @param {Collection} collection Collection of objects to sort\n * @returns {Collection}\n */\nfunction discordSort(collection) {\n  const isGuildChannel = collection.first() instanceof GuildChannel;\n  return collection.sorted(isGuildChannel ? (a, b) => a.rawPosition - b.rawPosition || Number(BigInt(a.id) - BigInt(b.id)) : (a, b) => a.rawPosition - b.rawPosition || Number(BigInt(b.id) - BigInt(a.id)));\n}\n\n/**\n * Sets the position of a Channel or Role.\n * @param {BaseChannel|Role} item Object to set the position of\n * @param {number} position New position for the object\n * @param {boolean} relative Whether `position` is relative to its current position\n * @param {Collection<string, BaseChannel|Role>} sorted A collection of the objects sorted properly\n * @param {Client} client The client to use to patch the data\n * @param {string} route Route to call PATCH on\n * @param {string} [reason] Reason for the change\n * @returns {Promise<BaseChannel[]|Role[]>} Updated item list, with `id` and `position` properties\n * @private\n */\nasync function setPosition(item, position, relative, sorted, client, route, reason) {\n  let updatedItems = [...sorted.values()];\n  moveElementInArray(updatedItems, item, position, relative);\n  updatedItems = updatedItems.map((r, i) => ({\n    id: r.id,\n    position: i\n  }));\n  await client.rest.patch(route, {\n    body: updatedItems,\n    reason\n  });\n  return updatedItems;\n}\n\n/**\n * Alternative to Node's `path.basename`, removing query string after the extension if it exists.\n * @param {string} path Path to get the basename of\n * @param {string} [ext] File extension to remove\n * @returns {string} Basename of the path\n * @private\n */\nfunction basename(path, ext) {\n  const res = parse(path);\n  return ext && res.ext.startsWith(ext) ? res.name : res.base.split('?')[0];\n}\n\n/**\n * The content to have all mentions replaced by the equivalent text.\n * @param {string} str The string to be converted\n * @param {TextBasedChannels} channel The channel the string was sent in\n * @returns {string}\n */\nfunction cleanContent(str, channel) {\n  return str.replaceAll(/<(@[!&]?|#)(\\d{17,19})>/g, (match, type, id) => {\n    switch (type) {\n      case '@':\n      case '@!':\n        {\n          const member = channel.guild?.members.cache.get(id);\n          if (member) {\n            return `@${member.displayName}`;\n          }\n          const user = channel.client.users.cache.get(id);\n          return user ? `@${user.username}` : match;\n        }\n      case '@&':\n        {\n          if (channel.type === ChannelType.DM) return match;\n          const role = channel.guild.roles.cache.get(id);\n          return role ? `@${role.name}` : match;\n        }\n      case '#':\n        {\n          const mentionedChannel = channel.client.channels.cache.get(id);\n          return mentionedChannel ? `#${mentionedChannel.name}` : match;\n        }\n      default:\n        {\n          return match;\n        }\n    }\n  });\n}\n\n/**\n * The content to put in a code block with all code block fences replaced by the equivalent backticks.\n * @param {string} text The string to be converted\n * @returns {string}\n */\nfunction cleanCodeBlockContent(text) {\n  return text.replaceAll('```', '`\\u200b``');\n}\n\n/**\n * Parses a webhook URL for the id and token.\n * @param {string} url The URL to parse\n * @returns {?WebhookClientDataIdWithToken} `null` if the URL is invalid, otherwise the id and the token\n */\nfunction parseWebhookURL(url) {\n  const matches = url.match(/https?:\\/\\/(?:ptb\\.|canary\\.)?discord\\.com\\/api(?:\\/v\\d{1,2})?\\/webhooks\\/(\\d{17,19})\\/([\\w-]{68})/i);\n  if (!matches || matches.length <= 2) return null;\n  const [, id, token] = matches;\n  return {\n    id,\n    token\n  };\n}\nmodule.exports = {\n  flatten,\n  escapeMarkdown,\n  escapeCodeBlock,\n  escapeInlineCode,\n  escapeItalic,\n  escapeBold,\n  escapeUnderline,\n  escapeStrikethrough,\n  escapeSpoiler,\n  fetchRecommendedShardCount,\n  parseEmoji,\n  resolvePartialEmoji,\n  mergeDefault,\n  makeError,\n  makePlainError,\n  moveElementInArray,\n  verifyString,\n  resolveColor,\n  discordSort,\n  setPosition,\n  basename,\n  cleanContent,\n  cleanCodeBlockContent,\n  parseWebhookURL\n};\n\n// Fixes Circular\nconst GuildChannel = require('../structures/GuildChannel');","map":{"version":3,"names":["parse","require","Collection","ChannelType","RouteBases","Routes","fetch","Colors","DiscordjsError","DiscordjsRangeError","DiscordjsTypeError","ErrorCodes","isObject","d","flatten","obj","props","objProps","Object","keys","filter","k","startsWith","map","length","assign","out","prop","newProp","entries","element","elemIsObj","valueOf","hasToJSON","toJSON","Array","from","isArray","e","escapeMarkdown","text","codeBlock","inlineCode","bold","italic","underline","strikethrough","spoiler","codeBlockContent","inlineCodeContent","escape","heading","bulletedList","numberedList","maskedLink","split","subString","index","array","join","escapeEscape","escapeInlineCode","escapeCodeBlock","escapeItalic","escapeBold","escapeUnderline","escapeStrikethrough","escapeSpoiler","escapeHeading","escapeBulletedList","escapeNumberedList","escapeMaskedLink","replaceAll","replace","match","i","_","fetchRecommendedShardCount","token","guildsPerShard","multipleOf","TokenMissing","response","api","gatewayBot","method","headers","Authorization","ok","status","TokenInvalid","shards","json","Math","ceil","parseEmoji","includes","decodeURIComponent","animated","name","id","undefined","Boolean","resolvePartialEmoji","emoji","test","mergeDefault","def","given","key","hasOwn","makeError","err","Error","message","stack","makePlainError","moveElementInArray","newIndex","offset","indexOf","removedElement","splice","verifyString","data","error","errorMessage","allowEmpty","resolveColor","color","floor","random","parseInt","ColorRange","Number","isNaN","ColorConvert","discordSort","collection","isGuildChannel","first","GuildChannel","sorted","a","b","rawPosition","BigInt","setPosition","item","position","relative","client","route","reason","updatedItems","values","r","rest","patch","body","basename","path","ext","res","base","cleanContent","str","channel","type","member","guild","members","cache","get","displayName","user","users","username","DM","role","roles","mentionedChannel","channels","cleanCodeBlockContent","parseWebhookURL","url","matches","module","exports"],"sources":["J:/Coding/Projekts/Web/JavaScript/sillcode.tech/node_modules/discord.js/src/util/Util.js"],"sourcesContent":["'use strict';\n\nconst { parse } = require('node:path');\nconst { Collection } = require('@discordjs/collection');\nconst { ChannelType, RouteBases, Routes } = require('discord-api-types/v10');\nconst { fetch } = require('undici');\nconst Colors = require('./Colors');\nconst { DiscordjsError, DiscordjsRangeError, DiscordjsTypeError, ErrorCodes } = require('../errors');\nconst isObject = d => typeof d === 'object' && d !== null;\n\n/**\n * Flatten an object. Any properties that are collections will get converted to an array of keys.\n * @param {Object} obj The object to flatten.\n * @param {...Object<string, boolean|string>} [props] Specific properties to include/exclude.\n * @returns {Object}\n */\nfunction flatten(obj, ...props) {\n  if (!isObject(obj)) return obj;\n\n  const objProps = Object.keys(obj)\n    .filter(k => !k.startsWith('_'))\n    .map(k => ({ [k]: true }));\n\n  props = objProps.length ? Object.assign(...objProps, ...props) : Object.assign({}, ...props);\n\n  const out = {};\n\n  for (let [prop, newProp] of Object.entries(props)) {\n    if (!newProp) continue;\n    newProp = newProp === true ? prop : newProp;\n\n    const element = obj[prop];\n    const elemIsObj = isObject(element);\n    const valueOf = elemIsObj && typeof element.valueOf === 'function' ? element.valueOf() : null;\n    const hasToJSON = elemIsObj && typeof element.toJSON === 'function';\n\n    // If it's a Collection, make the array of keys\n    if (element instanceof Collection) out[newProp] = Array.from(element.keys());\n    // If the valueOf is a Collection, use its array of keys\n    else if (valueOf instanceof Collection) out[newProp] = Array.from(valueOf.keys());\n    // If it's an array, call toJSON function on each element if present, otherwise flatten each element\n    else if (Array.isArray(element)) out[newProp] = element.map(e => e.toJSON?.() ?? flatten(e));\n    // If it's an object with a primitive `valueOf`, use that value\n    else if (typeof valueOf !== 'object') out[newProp] = valueOf;\n    // If it's an object with a toJSON function, use the return value of it\n    else if (hasToJSON) out[newProp] = element.toJSON();\n    // If element is an object, use the flattened version of it\n    else if (typeof element === 'object') out[newProp] = flatten(element);\n    // If it's a primitive\n    else if (!elemIsObj) out[newProp] = element;\n  }\n\n  return out;\n}\n\n/**\n * Options used to escape markdown.\n * @typedef {Object} EscapeMarkdownOptions\n * @property {boolean} [codeBlock=true] Whether to escape code blocks\n * @property {boolean} [inlineCode=true] Whether to escape inline code\n * @property {boolean} [bold=true] Whether to escape bolds\n * @property {boolean} [italic=true] Whether to escape italics\n * @property {boolean} [underline=true] Whether to escape underlines\n * @property {boolean} [strikethrough=true] Whether to escape strikethroughs\n * @property {boolean} [spoiler=true] Whether to escape spoilers\n * @property {boolean} [codeBlockContent=true] Whether to escape text inside code blocks\n * @property {boolean} [inlineCodeContent=true] Whether to escape text inside inline code\n * @property {boolean} [escape=true] Whether to escape escape characters\n * @property {boolean} [heading=false] Whether to escape headings\n * @property {boolean} [bulletedList=false] Whether to escape bulleted lists\n * @property {boolean} [numberedList=false] Whether to escape numbered lists\n * @property {boolean} [maskedLink=false] Whether to escape masked links\n */\n\n/**\n * Escapes any Discord-flavour markdown in a string.\n * @param {string} text Content to escape\n * @param {EscapeMarkdownOptions} [options={}] Options for escaping the markdown\n * @returns {string}\n */\nfunction escapeMarkdown(\n  text,\n  {\n    codeBlock = true,\n    inlineCode = true,\n    bold = true,\n    italic = true,\n    underline = true,\n    strikethrough = true,\n    spoiler = true,\n    codeBlockContent = true,\n    inlineCodeContent = true,\n    escape = true,\n    heading = false,\n    bulletedList = false,\n    numberedList = false,\n    maskedLink = false,\n  } = {},\n) {\n  if (!codeBlockContent) {\n    return text\n      .split('```')\n      .map((subString, index, array) => {\n        if (index % 2 && index !== array.length - 1) return subString;\n        return escapeMarkdown(subString, {\n          inlineCode,\n          bold,\n          italic,\n          underline,\n          strikethrough,\n          spoiler,\n          inlineCodeContent,\n          escape,\n          heading,\n          bulletedList,\n          numberedList,\n          maskedLink,\n        });\n      })\n      .join(codeBlock ? '\\\\`\\\\`\\\\`' : '```');\n  }\n  if (!inlineCodeContent) {\n    return text\n      .split(/(?<=^|[^`])`(?=[^`]|$)/g)\n      .map((subString, index, array) => {\n        if (index % 2 && index !== array.length - 1) return subString;\n        return escapeMarkdown(subString, {\n          codeBlock,\n          bold,\n          italic,\n          underline,\n          strikethrough,\n          spoiler,\n          escape,\n          heading,\n          bulletedList,\n          numberedList,\n          maskedLink,\n        });\n      })\n      .join(inlineCode ? '\\\\`' : '`');\n  }\n  if (escape) text = escapeEscape(text);\n  if (inlineCode) text = escapeInlineCode(text);\n  if (codeBlock) text = escapeCodeBlock(text);\n  if (italic) text = escapeItalic(text);\n  if (bold) text = escapeBold(text);\n  if (underline) text = escapeUnderline(text);\n  if (strikethrough) text = escapeStrikethrough(text);\n  if (spoiler) text = escapeSpoiler(text);\n  if (heading) text = escapeHeading(text);\n  if (bulletedList) text = escapeBulletedList(text);\n  if (numberedList) text = escapeNumberedList(text);\n  if (maskedLink) text = escapeMaskedLink(text);\n  return text;\n}\n\n/**\n * Escapes code block markdown in a string.\n * @param {string} text Content to escape\n * @returns {string}\n */\nfunction escapeCodeBlock(text) {\n  return text.replaceAll('```', '\\\\`\\\\`\\\\`');\n}\n\n/**\n * Escapes inline code markdown in a string.\n * @param {string} text Content to escape\n * @returns {string}\n */\nfunction escapeInlineCode(text) {\n  return text.replace(/(?<=^|[^`])``?(?=[^`]|$)/g, match => (match.length === 2 ? '\\\\`\\\\`' : '\\\\`'));\n}\n\n/**\n * Escapes italic markdown in a string.\n * @param {string} text Content to escape\n * @returns {string}\n */\nfunction escapeItalic(text) {\n  let i = 0;\n  text = text.replace(/(?<=^|[^*])\\*([^*]|\\*\\*|$)/g, (_, match) => {\n    if (match === '**') return ++i % 2 ? `\\\\*${match}` : `${match}\\\\*`;\n    return `\\\\*${match}`;\n  });\n  i = 0;\n  return text.replace(/(?<=^|[^_])_([^_]|__|$)/g, (_, match) => {\n    if (match === '__') return ++i % 2 ? `\\\\_${match}` : `${match}\\\\_`;\n    return `\\\\_${match}`;\n  });\n}\n\n/**\n * Escapes bold markdown in a string.\n * @param {string} text Content to escape\n * @returns {string}\n */\nfunction escapeBold(text) {\n  let i = 0;\n  return text.replace(/\\*\\*(\\*)?/g, (_, match) => {\n    if (match) return ++i % 2 ? `${match}\\\\*\\\\*` : `\\\\*\\\\*${match}`;\n    return '\\\\*\\\\*';\n  });\n}\n\n/**\n * Escapes underline markdown in a string.\n * @param {string} text Content to escape\n * @returns {string}\n */\nfunction escapeUnderline(text) {\n  let i = 0;\n  return text.replace(/__(_)?/g, (_, match) => {\n    if (match) return ++i % 2 ? `${match}\\\\_\\\\_` : `\\\\_\\\\_${match}`;\n    return '\\\\_\\\\_';\n  });\n}\n\n/**\n * Escapes strikethrough markdown in a string.\n * @param {string} text Content to escape\n * @returns {string}\n */\nfunction escapeStrikethrough(text) {\n  return text.replaceAll('~~', '\\\\~\\\\~');\n}\n\n/**\n * Escapes spoiler markdown in a string.\n * @param {string} text Content to escape\n * @returns {string}\n */\nfunction escapeSpoiler(text) {\n  return text.replaceAll('||', '\\\\|\\\\|');\n}\n\n/**\n * Escapes escape characters in a string.\n * @param {string} text Content to escape\n * @returns {string}\n */\nfunction escapeEscape(text) {\n  return text.replaceAll('\\\\', '\\\\\\\\');\n}\n\n/**\n * Escapes heading characters in a string.\n * @param {string} text Content to escape\n * @returns {string}\n */\nfunction escapeHeading(text) {\n  return text.replaceAll(/^( {0,2}[*-] +)?(#{1,3} )/gm, '$1\\\\$2');\n}\n\n/**\n * Escapes bulleted list characters in a string.\n * @param {string} text Content to escape\n * @returns {string}\n */\nfunction escapeBulletedList(text) {\n  return text.replaceAll(/^( *)[*-]( +)/gm, '$1\\\\-$2');\n}\n\n/**\n * Escapes numbered list characters in a string.\n * @param {string} text Content to escape\n * @returns {string}\n */\nfunction escapeNumberedList(text) {\n  return text.replaceAll(/^( *\\d+)\\./gm, '$1\\\\.');\n}\n\n/**\n * Escapes masked link characters in a string.\n * @param {string} text Content to escape\n * @returns {string}\n */\nfunction escapeMaskedLink(text) {\n  return text.replaceAll(/\\[.+\\]\\(.+\\)/gm, '\\\\$&');\n}\n\n/**\n * @typedef {Object} FetchRecommendedShardCountOptions\n * @property {number} [guildsPerShard=1000] Number of guilds assigned per shard\n * @property {number} [multipleOf=1] The multiple the shard count should round up to. (16 for large bot sharding)\n */\n\n/**\n * Gets the recommended shard count from Discord.\n * @param {string} token Discord auth token\n * @param {FetchRecommendedShardCountOptions} [options] Options for fetching the recommended shard count\n * @returns {Promise<number>} The recommended number of shards\n */\nasync function fetchRecommendedShardCount(token, { guildsPerShard = 1_000, multipleOf = 1 } = {}) {\n  if (!token) throw new DiscordjsError(ErrorCodes.TokenMissing);\n  const response = await fetch(RouteBases.api + Routes.gatewayBot(), {\n    method: 'GET',\n    headers: { Authorization: `Bot ${token.replace(/^Bot\\s*/i, '')}` },\n  });\n  if (!response.ok) {\n    if (response.status === 401) throw new DiscordjsError(ErrorCodes.TokenInvalid);\n    throw response;\n  }\n  const { shards } = await response.json();\n  return Math.ceil((shards * (1_000 / guildsPerShard)) / multipleOf) * multipleOf;\n}\n\n/**\n * Parses emoji info out of a string. The string must be one of:\n * * A UTF-8 emoji (no id)\n * * A URL-encoded UTF-8 emoji (no id)\n * * A Discord custom emoji (`<:name:id>` or `<a:name:id>`)\n * @param {string} text Emoji string to parse\n * @returns {APIEmoji} Object with `animated`, `name`, and `id` properties\n */\nfunction parseEmoji(text) {\n  if (text.includes('%')) text = decodeURIComponent(text);\n  if (!text.includes(':')) return { animated: false, name: text, id: undefined };\n  const match = text.match(/<?(?:(a):)?(\\w{2,32}):(\\d{17,19})?>?/);\n  return match && { animated: Boolean(match[1]), name: match[2], id: match[3] };\n}\n\n/**\n * Resolves a partial emoji object from an {@link EmojiIdentifierResolvable}, without checking a Client.\n * @param {EmojiIdentifierResolvable} emoji Emoji identifier to resolve\n * @returns {?RawEmoji}\n * @private\n */\nfunction resolvePartialEmoji(emoji) {\n  if (!emoji) return null;\n  if (typeof emoji === 'string') return /^\\d{17,19}$/.test(emoji) ? { id: emoji } : parseEmoji(emoji);\n  const { id, name, animated } = emoji;\n  if (!id && !name) return null;\n  return { id, name, animated: Boolean(animated) };\n}\n\n/**\n * Sets default properties on an object that aren't already specified.\n * @param {Object} def Default properties\n * @param {Object} given Object to assign defaults to\n * @returns {Object}\n * @private\n */\nfunction mergeDefault(def, given) {\n  if (!given) return def;\n  for (const key in def) {\n    if (!Object.hasOwn(given, key) || given[key] === undefined) {\n      given[key] = def[key];\n    } else if (given[key] === Object(given[key])) {\n      given[key] = mergeDefault(def[key], given[key]);\n    }\n  }\n\n  return given;\n}\n\n/**\n * Options used to make an error object.\n * @typedef {Object} MakeErrorOptions\n * @property {string} name Error type\n * @property {string} message Message for the error\n * @property {string} stack Stack for the error\n */\n\n/**\n * Makes an Error from a plain info object.\n * @param {MakeErrorOptions} obj Error info\n * @returns {Error}\n * @private\n */\nfunction makeError(obj) {\n  const err = new Error(obj.message);\n  err.name = obj.name;\n  err.stack = obj.stack;\n  return err;\n}\n\n/**\n * Makes a plain error info object from an Error.\n * @param {Error} err Error to get info from\n * @returns {MakeErrorOptions}\n * @private\n */\nfunction makePlainError(err) {\n  return {\n    name: err.name,\n    message: err.message,\n    stack: err.stack,\n  };\n}\n\n/**\n * Moves an element in an array *in place*.\n * @param {Array<*>} array Array to modify\n * @param {*} element Element to move\n * @param {number} newIndex Index or offset to move the element to\n * @param {boolean} [offset=false] Move the element by an offset amount rather than to a set index\n * @returns {number}\n * @private\n */\nfunction moveElementInArray(array, element, newIndex, offset = false) {\n  const index = array.indexOf(element);\n  newIndex = (offset ? index : 0) + newIndex;\n  if (newIndex > -1 && newIndex < array.length) {\n    const removedElement = array.splice(index, 1)[0];\n    array.splice(newIndex, 0, removedElement);\n  }\n  return array.indexOf(element);\n}\n\n/**\n * Verifies the provided data is a string, otherwise throws provided error.\n * @param {string} data The string resolvable to resolve\n * @param {Function} [error] The Error constructor to instantiate. Defaults to Error\n * @param {string} [errorMessage] The error message to throw with. Defaults to \"Expected string, got <data> instead.\"\n * @param {boolean} [allowEmpty=true] Whether an empty string should be allowed\n * @returns {string}\n */\nfunction verifyString(\n  data,\n  error = Error,\n  errorMessage = `Expected a string, got ${data} instead.`,\n  allowEmpty = true,\n) {\n  if (typeof data !== 'string') throw new error(errorMessage);\n  if (!allowEmpty && data.length === 0) throw new error(errorMessage);\n  return data;\n}\n\n/**\n * Can be a number, hex string, an RGB array like:\n * ```js\n * [255, 0, 255] // purple\n * ```\n * or one of the following strings:\n * - `Default`\n * - `White`\n * - `Aqua`\n * - `Green`\n * - `Blue`\n * - `Yellow`\n * - `Purple`\n * - `LuminousVividPink`\n * - `Fuchsia`\n * - `Gold`\n * - `Orange`\n * - `Red`\n * - `Grey`\n * - `Navy`\n * - `DarkAqua`\n * - `DarkGreen`\n * - `DarkBlue`\n * - `DarkPurple`\n * - `DarkVividPink`\n * - `DarkGold`\n * - `DarkOrange`\n * - `DarkRed`\n * - `DarkGrey`\n * - `DarkerGrey`\n * - `LightGrey`\n * - `DarkNavy`\n * - `Blurple`\n * - `Greyple`\n * - `DarkButNotBlack`\n * - `NotQuiteBlack`\n * - `Random`\n * @typedef {string|number|number[]} ColorResolvable\n */\n\n/**\n * Resolves a ColorResolvable into a color number.\n * @param {ColorResolvable} color Color to resolve\n * @returns {number} A color\n */\nfunction resolveColor(color) {\n  if (typeof color === 'string') {\n    if (color === 'Random') return Math.floor(Math.random() * (0xffffff + 1));\n    if (color === 'Default') return 0;\n    color = Colors[color] ?? parseInt(color.replace('#', ''), 16);\n  } else if (Array.isArray(color)) {\n    color = (color[0] << 16) + (color[1] << 8) + color[2];\n  }\n\n  if (color < 0 || color > 0xffffff) throw new DiscordjsRangeError(ErrorCodes.ColorRange);\n  else if (Number.isNaN(color)) throw new DiscordjsTypeError(ErrorCodes.ColorConvert);\n\n  return color;\n}\n\n/**\n * Sorts by Discord's position and id.\n * @param {Collection} collection Collection of objects to sort\n * @returns {Collection}\n */\nfunction discordSort(collection) {\n  const isGuildChannel = collection.first() instanceof GuildChannel;\n  return collection.sorted(\n    isGuildChannel\n      ? (a, b) => a.rawPosition - b.rawPosition || Number(BigInt(a.id) - BigInt(b.id))\n      : (a, b) => a.rawPosition - b.rawPosition || Number(BigInt(b.id) - BigInt(a.id)),\n  );\n}\n\n/**\n * Sets the position of a Channel or Role.\n * @param {BaseChannel|Role} item Object to set the position of\n * @param {number} position New position for the object\n * @param {boolean} relative Whether `position` is relative to its current position\n * @param {Collection<string, BaseChannel|Role>} sorted A collection of the objects sorted properly\n * @param {Client} client The client to use to patch the data\n * @param {string} route Route to call PATCH on\n * @param {string} [reason] Reason for the change\n * @returns {Promise<BaseChannel[]|Role[]>} Updated item list, with `id` and `position` properties\n * @private\n */\nasync function setPosition(item, position, relative, sorted, client, route, reason) {\n  let updatedItems = [...sorted.values()];\n  moveElementInArray(updatedItems, item, position, relative);\n  updatedItems = updatedItems.map((r, i) => ({ id: r.id, position: i }));\n  await client.rest.patch(route, { body: updatedItems, reason });\n  return updatedItems;\n}\n\n/**\n * Alternative to Node's `path.basename`, removing query string after the extension if it exists.\n * @param {string} path Path to get the basename of\n * @param {string} [ext] File extension to remove\n * @returns {string} Basename of the path\n * @private\n */\nfunction basename(path, ext) {\n  const res = parse(path);\n  return ext && res.ext.startsWith(ext) ? res.name : res.base.split('?')[0];\n}\n\n/**\n * The content to have all mentions replaced by the equivalent text.\n * @param {string} str The string to be converted\n * @param {TextBasedChannels} channel The channel the string was sent in\n * @returns {string}\n */\nfunction cleanContent(str, channel) {\n  return str.replaceAll(/<(@[!&]?|#)(\\d{17,19})>/g, (match, type, id) => {\n    switch (type) {\n      case '@':\n      case '@!': {\n        const member = channel.guild?.members.cache.get(id);\n        if (member) {\n          return `@${member.displayName}`;\n        }\n\n        const user = channel.client.users.cache.get(id);\n        return user ? `@${user.username}` : match;\n      }\n      case '@&': {\n        if (channel.type === ChannelType.DM) return match;\n        const role = channel.guild.roles.cache.get(id);\n        return role ? `@${role.name}` : match;\n      }\n      case '#': {\n        const mentionedChannel = channel.client.channels.cache.get(id);\n        return mentionedChannel ? `#${mentionedChannel.name}` : match;\n      }\n      default: {\n        return match;\n      }\n    }\n  });\n}\n\n/**\n * The content to put in a code block with all code block fences replaced by the equivalent backticks.\n * @param {string} text The string to be converted\n * @returns {string}\n */\nfunction cleanCodeBlockContent(text) {\n  return text.replaceAll('```', '`\\u200b``');\n}\n\n/**\n * Parses a webhook URL for the id and token.\n * @param {string} url The URL to parse\n * @returns {?WebhookClientDataIdWithToken} `null` if the URL is invalid, otherwise the id and the token\n */\nfunction parseWebhookURL(url) {\n  const matches = url.match(\n    /https?:\\/\\/(?:ptb\\.|canary\\.)?discord\\.com\\/api(?:\\/v\\d{1,2})?\\/webhooks\\/(\\d{17,19})\\/([\\w-]{68})/i,\n  );\n\n  if (!matches || matches.length <= 2) return null;\n\n  const [, id, token] = matches;\n  return {\n    id,\n    token,\n  };\n}\n\nmodule.exports = {\n  flatten,\n  escapeMarkdown,\n  escapeCodeBlock,\n  escapeInlineCode,\n  escapeItalic,\n  escapeBold,\n  escapeUnderline,\n  escapeStrikethrough,\n  escapeSpoiler,\n  fetchRecommendedShardCount,\n  parseEmoji,\n  resolvePartialEmoji,\n  mergeDefault,\n  makeError,\n  makePlainError,\n  moveElementInArray,\n  verifyString,\n  resolveColor,\n  discordSort,\n  setPosition,\n  basename,\n  cleanContent,\n  cleanCodeBlockContent,\n  parseWebhookURL,\n};\n\n// Fixes Circular\nconst GuildChannel = require('../structures/GuildChannel');\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}