{"ast":null,"code":"'use strict';\n\nconst {\n  ChannelType,\n  PermissionFlagsBits,\n  Routes,\n  ChannelFlags\n} = require('discord-api-types/v10');\nconst {\n  BaseChannel\n} = require('./BaseChannel');\nconst TextBasedChannel = require('./interfaces/TextBasedChannel');\nconst {\n  DiscordjsRangeError,\n  ErrorCodes\n} = require('../errors');\nconst MessageManager = require('../managers/MessageManager');\nconst ThreadMemberManager = require('../managers/ThreadMemberManager');\nconst ChannelFlagsBitField = require('../util/ChannelFlagsBitField');\n\n/**\n * Represents a thread channel on Discord.\n * @extends {BaseChannel}\n * @implements {TextBasedChannel}\n */\nclass ThreadChannel extends BaseChannel {\n  constructor(guild, data, client) {\n    let fromInteraction = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;\n    super(guild?.client ?? client, data, false);\n\n    /**\n     * The guild the thread is in\n     * @type {Guild}\n     */\n    this.guild = guild;\n\n    /**\n     * The id of the guild the channel is in\n     * @type {Snowflake}\n     */\n    this.guildId = guild?.id ?? data.guild_id;\n\n    /**\n     * A manager of the messages sent to this thread\n     * @type {MessageManager}\n     */\n    this.messages = new MessageManager(this);\n\n    /**\n     * A manager of the members that are part of this thread\n     * @type {ThreadMemberManager}\n     */\n    this.members = new ThreadMemberManager(this);\n    if (data) this._patch(data, fromInteraction);\n  }\n  _patch(data) {\n    let partial = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n    super._patch(data);\n    if ('name' in data) {\n      /**\n       * The name of the thread\n       * @type {string}\n       */\n      this.name = data.name;\n    }\n    if ('guild_id' in data) {\n      this.guildId = data.guild_id;\n    }\n    if ('parent_id' in data) {\n      /**\n       * The id of the parent channel of this thread\n       * @type {?Snowflake}\n       */\n      this.parentId = data.parent_id;\n    } else {\n      this.parentId ??= null;\n    }\n    if ('thread_metadata' in data) {\n      /**\n       * Whether the thread is locked\n       * @type {?boolean}\n       */\n      this.locked = data.thread_metadata.locked ?? false;\n\n      /**\n       * Whether members without the {@link PermissionFlagsBits.ManageThreads} permission\n       * can invite other members to this thread.\n       * <info>This property is always `null` in public threads.</info>\n       * @type {?boolean}\n       */\n      this.invitable = this.type === ChannelType.PrivateThread ? data.thread_metadata.invitable ?? false : null;\n\n      /**\n       * Whether the thread is archived\n       * @type {?boolean}\n       */\n      this.archived = data.thread_metadata.archived;\n\n      /**\n       * The amount of time (in minutes) after which the thread will automatically archive in case of no recent activity\n       * @type {?ThreadAutoArchiveDuration}\n       */\n      this.autoArchiveDuration = data.thread_metadata.auto_archive_duration;\n\n      /**\n       * The timestamp when the thread's archive status was last changed\n       * <info>If the thread was never archived or unarchived, this is the timestamp at which the thread was\n       * created</info>\n       * @type {?number}\n       */\n      this.archiveTimestamp = Date.parse(data.thread_metadata.archive_timestamp);\n      if ('create_timestamp' in data.thread_metadata) {\n        // Note: this is needed because we can't assign directly to getters\n        this._createdTimestamp = Date.parse(data.thread_metadata.create_timestamp);\n      }\n    } else {\n      this.locked ??= null;\n      this.archived ??= null;\n      this.autoArchiveDuration ??= null;\n      this.archiveTimestamp ??= null;\n      this.invitable ??= null;\n    }\n    this._createdTimestamp ??= this.type === ChannelType.PrivateThread ? super.createdTimestamp : null;\n    if ('owner_id' in data) {\n      /**\n       * The id of the member who created this thread\n       * @type {?Snowflake}\n       */\n      this.ownerId = data.owner_id;\n    } else {\n      this.ownerId ??= null;\n    }\n    if ('last_message_id' in data) {\n      /**\n       * The last message id sent in this thread, if one was sent\n       * @type {?Snowflake}\n       */\n      this.lastMessageId = data.last_message_id;\n    } else {\n      this.lastMessageId ??= null;\n    }\n    if ('last_pin_timestamp' in data) {\n      /**\n       * The timestamp when the last pinned message was pinned, if there was one\n       * @type {?number}\n       */\n      this.lastPinTimestamp = data.last_pin_timestamp ? Date.parse(data.last_pin_timestamp) : null;\n    } else {\n      this.lastPinTimestamp ??= null;\n    }\n    if ('rate_limit_per_user' in data || !partial) {\n      /**\n       * The rate limit per user (slowmode) for this thread in seconds\n       * @type {?number}\n       */\n      this.rateLimitPerUser = data.rate_limit_per_user ?? 0;\n    } else {\n      this.rateLimitPerUser ??= null;\n    }\n    if ('message_count' in data) {\n      /**\n       * The approximate count of messages in this thread\n       * <info>Threads created before July 1, 2022 may have an inaccurate count.\n       * If you need an approximate value higher than that, use `ThreadChannel#messages.cache.size`</info>\n       * @type {?number}\n       */\n      this.messageCount = data.message_count;\n    } else {\n      this.messageCount ??= null;\n    }\n    if ('member_count' in data) {\n      /**\n       * The approximate count of users in this thread\n       * <info>This stops counting at 50. If you need an approximate value higher than that, use\n       * `ThreadChannel#members.cache.size`</info>\n       * @type {?number}\n       */\n      this.memberCount = data.member_count;\n    } else {\n      this.memberCount ??= null;\n    }\n    if ('total_message_sent' in data) {\n      /**\n       * The number of messages ever sent in a thread, similar to {@link ThreadChannel#messageCount} except it\n       * will not decrement whenever a message is deleted\n       * @type {?number}\n       */\n      this.totalMessageSent = data.total_message_sent;\n    } else {\n      this.totalMessageSent ??= null;\n    }\n    if (data.member && this.client.user) this.members._add({\n      user_id: this.client.user.id,\n      ...data.member\n    });\n    if (data.messages) for (const message of data.messages) this.messages._add(message);\n    if ('applied_tags' in data) {\n      /**\n       * The tags applied to this thread\n       * @type {Snowflake[]}\n       */\n      this.appliedTags = data.applied_tags;\n    } else {\n      this.appliedTags ??= [];\n    }\n  }\n\n  /**\n   * The timestamp when this thread was created. This isn't available for threads\n   * created before 2022-01-09\n   * @type {?number}\n   * @readonly\n   */\n  get createdTimestamp() {\n    return this._createdTimestamp;\n  }\n\n  /**\n   * A collection of associated guild member objects of this thread's members\n   * @type {Collection<Snowflake, GuildMember>}\n   * @readonly\n   */\n  get guildMembers() {\n    return this.members.cache.mapValues(member => member.guildMember);\n  }\n\n  /**\n   * The time at which this thread's archive status was last changed\n   * <info>If the thread was never archived or unarchived, this is the time at which the thread was created</info>\n   * @type {?Date}\n   * @readonly\n   */\n  get archivedAt() {\n    return this.archiveTimestamp && new Date(this.archiveTimestamp);\n  }\n\n  /**\n   * The time the thread was created at\n   * @type {?Date}\n   * @readonly\n   */\n  get createdAt() {\n    return this.createdTimestamp && new Date(this.createdTimestamp);\n  }\n\n  /**\n   * The parent channel of this thread\n   * @type {?(NewsChannel|TextChannel|ForumChannel)}\n   * @readonly\n   */\n  get parent() {\n    return this.guild.channels.resolve(this.parentId);\n  }\n\n  /**\n   * Makes the client user join the thread.\n   * @returns {Promise<ThreadChannel>}\n   */\n  async join() {\n    await this.members.add('@me');\n    return this;\n  }\n\n  /**\n   * Makes the client user leave the thread.\n   * @returns {Promise<ThreadChannel>}\n   */\n  async leave() {\n    await this.members.remove('@me');\n    return this;\n  }\n\n  /**\n   * Gets the overall set of permissions for a member or role in this thread's parent channel, taking overwrites into\n   * account.\n   * @param {GuildMemberResolvable|RoleResolvable} memberOrRole The member or role to obtain the overall permissions for\n   * @param {boolean} [checkAdmin=true] Whether having the {@link PermissionFlagsBits.Administrator} permission\n   * will return all permissions\n   * @returns {?Readonly<PermissionsBitField>}\n   */\n  permissionsFor(memberOrRole, checkAdmin) {\n    return this.parent?.permissionsFor(memberOrRole, checkAdmin) ?? null;\n  }\n\n  /**\n   * Fetches the owner of this thread. If the thread member object isn't needed,\n   * use {@link ThreadChannel#ownerId} instead.\n   * @param {BaseFetchOptions} [options] The options for fetching the member\n   * @returns {Promise<?ThreadMember>}\n   */\n  async fetchOwner() {\n    let {\n      cache = true,\n      force = false\n    } = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    if (!force) {\n      const existing = this.members.cache.get(this.ownerId);\n      if (existing) return existing;\n    }\n\n    // We cannot fetch a single thread member, as of this commit's date, Discord API responds with 405\n    const members = await this.members.fetch({\n      cache\n    });\n    return members.get(this.ownerId) ?? null;\n  }\n\n  /**\n   * Fetches the message that started this thread, if any.\n   * <info>The `Promise` will reject if the original message in a forum post is deleted\n   * or when the original message in the parent channel is deleted.\n   * If you just need the id of that message, use {@link ThreadChannel#id} instead.</info>\n   * @param {BaseFetchOptions} [options] Additional options for this fetch\n   * @returns {Promise<Message<true>|null>}\n   */\n  // eslint-disable-next-line require-await\n  async fetchStarterMessage(options) {\n    const channel = this.parent?.type === ChannelType.GuildForum ? this : this.parent;\n    return channel?.messages.fetch({\n      message: this.id,\n      ...options\n    }) ?? null;\n  }\n\n  /**\n   * The options used to edit a thread channel\n   * @typedef {Object} ThreadEditData\n   * @property {string} [name] The new name for the thread\n   * @property {boolean} [archived] Whether the thread is archived\n   * @property {ThreadAutoArchiveDuration} [autoArchiveDuration] The amount of time after which the thread\n   * should automatically archive in case of no recent activity\n   * @property {number} [rateLimitPerUser] The rate limit per user (slowmode) for the thread in seconds\n   * @property {boolean} [locked] Whether the thread is locked\n   * @property {boolean} [invitable] Whether non-moderators can add other non-moderators to a thread\n   * @property {Snowflake[]} [appliedTags] The tags to apply to the thread\n   * @property {ChannelFlagsResolvable} [flags] The flags to set on the channel\n   * @property {string} [reason] Reason for editing the thread\n   * <info>Can only be edited on {@link ChannelType.PrivateThread}</info>\n   */\n\n  /**\n   * Edits this thread.\n   * @param {ThreadEditData} data The new data for this thread\n   * @returns {Promise<ThreadChannel>}\n   * @example\n   * // Edit a thread\n   * thread.edit({ name: 'new-thread' })\n   *   .then(editedThread => console.log(editedThread))\n   *   .catch(console.error);\n   */\n  async edit(data) {\n    const newData = await this.client.rest.patch(Routes.channel(this.id), {\n      body: {\n        name: (data.name ?? this.name).trim(),\n        archived: data.archived,\n        auto_archive_duration: data.autoArchiveDuration,\n        rate_limit_per_user: data.rateLimitPerUser,\n        locked: data.locked,\n        invitable: this.type === ChannelType.PrivateThread ? data.invitable : undefined,\n        applied_tags: data.appliedTags,\n        flags: 'flags' in data ? ChannelFlagsBitField.resolve(data.flags) : undefined\n      },\n      reason: data.reason\n    });\n    return this.client.actions.ChannelUpdate.handle(newData).updated;\n  }\n\n  /**\n   * Sets whether the thread is archived.\n   * @param {boolean} [archived=true] Whether the thread is archived\n   * @param {string} [reason] Reason for archiving or unarchiving\n   * @returns {Promise<ThreadChannel>}\n   * @example\n   * // Archive the thread\n   * thread.setArchived(true)\n   *   .then(newThread => console.log(`Thread is now ${newThread.archived ? 'archived' : 'active'}`))\n   *   .catch(console.error);\n   */\n  setArchived() {\n    let archived = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;\n    let reason = arguments.length > 1 ? arguments[1] : undefined;\n    return this.edit({\n      archived,\n      reason\n    });\n  }\n\n  /**\n   * Sets the duration after which the thread will automatically archive in case of no recent activity.\n   * @param {ThreadAutoArchiveDuration} autoArchiveDuration The amount of time after which the thread\n   * should automatically archive in case of no recent activity\n   * @param {string} [reason] Reason for changing the auto archive duration\n   * @returns {Promise<ThreadChannel>}\n   * @example\n   * // Set the thread's auto archive time to 1 hour\n   * thread.setAutoArchiveDuration(ThreadAutoArchiveDuration.OneHour)\n   *   .then(newThread => {\n   *     console.log(`Thread will now archive after ${newThread.autoArchiveDuration} minutes of inactivity`);\n   *    });\n   *   .catch(console.error);\n   */\n  setAutoArchiveDuration(autoArchiveDuration, reason) {\n    return this.edit({\n      autoArchiveDuration,\n      reason\n    });\n  }\n\n  /**\n   * Sets whether members without the {@link PermissionFlagsBits.ManageThreads} permission\n   * can invite other members to this thread.\n   * @param {boolean} [invitable=true] Whether non-moderators can invite non-moderators to this thread\n   * @param {string} [reason] Reason for changing invite\n   * @returns {Promise<ThreadChannel>}\n   */\n  setInvitable() {\n    let invitable = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;\n    let reason = arguments.length > 1 ? arguments[1] : undefined;\n    if (this.type !== ChannelType.PrivateThread) {\n      return Promise.reject(new DiscordjsRangeError(ErrorCodes.ThreadInvitableType, this.type));\n    }\n    return this.edit({\n      invitable,\n      reason\n    });\n  }\n\n  /**\n   * Sets whether the thread can be **unarchived** by anyone with the\n   * {@link PermissionFlagsBits.SendMessages} permission. When a thread is locked, only members with the\n   * {@link PermissionFlagsBits.ManageThreads} permission can unarchive it.\n   * @param {boolean} [locked=true] Whether the thread is locked\n   * @param {string} [reason] Reason for locking or unlocking the thread\n   * @returns {Promise<ThreadChannel>}\n   * @example\n   * // Set the thread to locked\n   * thread.setLocked(true)\n   *   .then(newThread => console.log(`Thread is now ${newThread.locked ? 'locked' : 'unlocked'}`))\n   *   .catch(console.error);\n   */\n  setLocked() {\n    let locked = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;\n    let reason = arguments.length > 1 ? arguments[1] : undefined;\n    return this.edit({\n      locked,\n      reason\n    });\n  }\n\n  /**\n   * Sets a new name for this thread.\n   * @param {string} name The new name for the thread\n   * @param {string} [reason] Reason for changing the thread's name\n   * @returns {Promise<ThreadChannel>}\n   * @example\n   * // Change the thread's name\n   * thread.setName('not_general')\n   *   .then(newThread => console.log(`Thread's new name is ${newThread.name}`))\n   *   .catch(console.error);\n   */\n  setName(name, reason) {\n    return this.edit({\n      name,\n      reason\n    });\n  }\n\n  /**\n   * Sets the rate limit per user (slowmode) for this thread.\n   * @param {number} rateLimitPerUser The new rate limit in seconds\n   * @param {string} [reason] Reason for changing the thread's rate limit\n   * @returns {Promise<ThreadChannel>}\n   */\n  setRateLimitPerUser(rateLimitPerUser, reason) {\n    return this.edit({\n      rateLimitPerUser,\n      reason\n    });\n  }\n\n  /**\n   * Set the applied tags for this channel (only applicable to forum threads)\n   * @param {Snowflake[]} appliedTags The tags to set for this channel\n   * @param {string} [reason] Reason for changing the thread's applied tags\n   * @returns {Promise<ThreadChannel>}\n   */\n  setAppliedTags(appliedTags, reason) {\n    return this.edit({\n      appliedTags,\n      reason\n    });\n  }\n\n  /**\n   * Pins this thread from the forum channel (only applicable to forum threads).\n   * @param {string} [reason] Reason for pinning\n   * @returns {Promise<ThreadChannel>}\n   */\n  pin(reason) {\n    return this.edit({\n      flags: this.flags.add(ChannelFlags.Pinned),\n      reason\n    });\n  }\n\n  /**\n   * Unpins this thread from the forum channel (only applicable to forum threads).\n   * @param {string} [reason] Reason for unpinning\n   * @returns {Promise<ThreadChannel>}\n   */\n  unpin(reason) {\n    return this.edit({\n      flags: this.flags.remove(ChannelFlags.Pinned),\n      reason\n    });\n  }\n\n  /**\n   * Whether the client user is a member of the thread.\n   * @type {boolean}\n   * @readonly\n   */\n  get joined() {\n    return this.members.cache.has(this.client.user?.id);\n  }\n\n  /**\n   * Whether the thread is editable by the client user (name, archived, autoArchiveDuration)\n   * @type {boolean}\n   * @readonly\n   */\n  get editable() {\n    return this.ownerId === this.client.user.id && (this.type !== ChannelType.PrivateThread || this.joined) || this.manageable;\n  }\n\n  /**\n   * Whether the thread is joinable by the client user\n   * @type {boolean}\n   * @readonly\n   */\n  get joinable() {\n    return !this.archived && !this.joined && this.permissionsFor(this.client.user)?.has(this.type === ChannelType.PrivateThread ? PermissionFlagsBits.ManageThreads : PermissionFlagsBits.ViewChannel, false);\n  }\n\n  /**\n   * Whether the thread is manageable by the client user, for deleting or editing rateLimitPerUser or locked.\n   * @type {boolean}\n   * @readonly\n   */\n  get manageable() {\n    const permissions = this.permissionsFor(this.client.user);\n    if (!permissions) return false;\n    // This flag allows managing even if timed out\n    if (permissions.has(PermissionFlagsBits.Administrator, false)) return true;\n    return this.guild.members.me.communicationDisabledUntilTimestamp < Date.now() && permissions.has(PermissionFlagsBits.ManageThreads, false);\n  }\n\n  /**\n   * Whether the thread is viewable by the client user\n   * @type {boolean}\n   * @readonly\n   */\n  get viewable() {\n    if (this.client.user.id === this.guild.ownerId) return true;\n    const permissions = this.permissionsFor(this.client.user);\n    if (!permissions) return false;\n    return permissions.has(PermissionFlagsBits.ViewChannel, false);\n  }\n\n  /**\n   * Whether the client user can send messages in this thread\n   * @type {boolean}\n   * @readonly\n   */\n  get sendable() {\n    const permissions = this.permissionsFor(this.client.user);\n    if (!permissions) return false;\n    // This flag allows sending even if timed out\n    if (permissions.has(PermissionFlagsBits.Administrator, false)) return true;\n    return !(this.archived && this.locked && !this.manageable) && (this.type !== ChannelType.PrivateThread || this.joined || this.manageable) && permissions.has(PermissionFlagsBits.SendMessagesInThreads, false) && this.guild.members.me.communicationDisabledUntilTimestamp < Date.now();\n  }\n\n  /**\n   * Whether the thread is unarchivable by the client user\n   * @type {boolean}\n   * @readonly\n   */\n  get unarchivable() {\n    return this.archived && this.sendable && (!this.locked || this.manageable);\n  }\n\n  /**\n   * Deletes this thread.\n   * @param {string} [reason] Reason for deleting this thread\n   * @returns {Promise<ThreadChannel>}\n   * @example\n   * // Delete the thread\n   * thread.delete('cleaning out old threads')\n   *   .then(deletedThread => console.log(deletedThread))\n   *   .catch(console.error);\n   */\n  async delete(reason) {\n    await this.guild.channels.delete(this.id, reason);\n    return this;\n  }\n\n  // These are here only for documentation purposes - they are implemented by TextBasedChannel\n  /* eslint-disable no-empty-function */\n  get lastMessage() {}\n  get lastPinAt() {}\n  send() {}\n  sendTyping() {}\n  createMessageCollector() {}\n  awaitMessages() {}\n  createMessageComponentCollector() {}\n  awaitMessageComponent() {}\n  bulkDelete() {}\n  // Doesn't work on Thread channels; setRateLimitPerUser() {}\n  // Doesn't work on Thread channels; setNSFW() {}\n}\n\nTextBasedChannel.applyToClass(ThreadChannel, true, ['fetchWebhooks', 'setRateLimitPerUser', 'setNSFW']);\nmodule.exports = ThreadChannel;","map":{"version":3,"names":["ChannelType","PermissionFlagsBits","Routes","ChannelFlags","require","BaseChannel","TextBasedChannel","DiscordjsRangeError","ErrorCodes","MessageManager","ThreadMemberManager","ChannelFlagsBitField","ThreadChannel","constructor","guild","data","client","fromInteraction","guildId","id","guild_id","messages","members","_patch","partial","name","parentId","parent_id","locked","thread_metadata","invitable","type","PrivateThread","archived","autoArchiveDuration","auto_archive_duration","archiveTimestamp","Date","parse","archive_timestamp","_createdTimestamp","create_timestamp","createdTimestamp","ownerId","owner_id","lastMessageId","last_message_id","lastPinTimestamp","last_pin_timestamp","rateLimitPerUser","rate_limit_per_user","messageCount","message_count","memberCount","member_count","totalMessageSent","total_message_sent","member","user","_add","user_id","message","appliedTags","applied_tags","guildMembers","cache","mapValues","guildMember","archivedAt","createdAt","parent","channels","resolve","join","add","leave","remove","permissionsFor","memberOrRole","checkAdmin","fetchOwner","force","existing","get","fetch","fetchStarterMessage","options","channel","GuildForum","edit","newData","rest","patch","body","trim","undefined","flags","reason","actions","ChannelUpdate","handle","updated","setArchived","setAutoArchiveDuration","setInvitable","Promise","reject","ThreadInvitableType","setLocked","setName","setRateLimitPerUser","setAppliedTags","pin","Pinned","unpin","joined","has","editable","manageable","joinable","ManageThreads","ViewChannel","permissions","Administrator","me","communicationDisabledUntilTimestamp","now","viewable","sendable","SendMessagesInThreads","unarchivable","delete","lastMessage","lastPinAt","send","sendTyping","createMessageCollector","awaitMessages","createMessageComponentCollector","awaitMessageComponent","bulkDelete","applyToClass","module","exports"],"sources":["J:/Coding/Projekts/Web/JavaScript/sillcode.tech/node_modules/discord.js/src/structures/ThreadChannel.js"],"sourcesContent":["'use strict';\n\nconst { ChannelType, PermissionFlagsBits, Routes, ChannelFlags } = require('discord-api-types/v10');\nconst { BaseChannel } = require('./BaseChannel');\nconst TextBasedChannel = require('./interfaces/TextBasedChannel');\nconst { DiscordjsRangeError, ErrorCodes } = require('../errors');\nconst MessageManager = require('../managers/MessageManager');\nconst ThreadMemberManager = require('../managers/ThreadMemberManager');\nconst ChannelFlagsBitField = require('../util/ChannelFlagsBitField');\n\n/**\n * Represents a thread channel on Discord.\n * @extends {BaseChannel}\n * @implements {TextBasedChannel}\n */\nclass ThreadChannel extends BaseChannel {\n  constructor(guild, data, client, fromInteraction = false) {\n    super(guild?.client ?? client, data, false);\n\n    /**\n     * The guild the thread is in\n     * @type {Guild}\n     */\n    this.guild = guild;\n\n    /**\n     * The id of the guild the channel is in\n     * @type {Snowflake}\n     */\n    this.guildId = guild?.id ?? data.guild_id;\n\n    /**\n     * A manager of the messages sent to this thread\n     * @type {MessageManager}\n     */\n    this.messages = new MessageManager(this);\n\n    /**\n     * A manager of the members that are part of this thread\n     * @type {ThreadMemberManager}\n     */\n    this.members = new ThreadMemberManager(this);\n    if (data) this._patch(data, fromInteraction);\n  }\n\n  _patch(data, partial = false) {\n    super._patch(data);\n\n    if ('name' in data) {\n      /**\n       * The name of the thread\n       * @type {string}\n       */\n      this.name = data.name;\n    }\n\n    if ('guild_id' in data) {\n      this.guildId = data.guild_id;\n    }\n\n    if ('parent_id' in data) {\n      /**\n       * The id of the parent channel of this thread\n       * @type {?Snowflake}\n       */\n      this.parentId = data.parent_id;\n    } else {\n      this.parentId ??= null;\n    }\n\n    if ('thread_metadata' in data) {\n      /**\n       * Whether the thread is locked\n       * @type {?boolean}\n       */\n      this.locked = data.thread_metadata.locked ?? false;\n\n      /**\n       * Whether members without the {@link PermissionFlagsBits.ManageThreads} permission\n       * can invite other members to this thread.\n       * <info>This property is always `null` in public threads.</info>\n       * @type {?boolean}\n       */\n      this.invitable = this.type === ChannelType.PrivateThread ? data.thread_metadata.invitable ?? false : null;\n\n      /**\n       * Whether the thread is archived\n       * @type {?boolean}\n       */\n      this.archived = data.thread_metadata.archived;\n\n      /**\n       * The amount of time (in minutes) after which the thread will automatically archive in case of no recent activity\n       * @type {?ThreadAutoArchiveDuration}\n       */\n      this.autoArchiveDuration = data.thread_metadata.auto_archive_duration;\n\n      /**\n       * The timestamp when the thread's archive status was last changed\n       * <info>If the thread was never archived or unarchived, this is the timestamp at which the thread was\n       * created</info>\n       * @type {?number}\n       */\n      this.archiveTimestamp = Date.parse(data.thread_metadata.archive_timestamp);\n\n      if ('create_timestamp' in data.thread_metadata) {\n        // Note: this is needed because we can't assign directly to getters\n        this._createdTimestamp = Date.parse(data.thread_metadata.create_timestamp);\n      }\n    } else {\n      this.locked ??= null;\n      this.archived ??= null;\n      this.autoArchiveDuration ??= null;\n      this.archiveTimestamp ??= null;\n      this.invitable ??= null;\n    }\n\n    this._createdTimestamp ??= this.type === ChannelType.PrivateThread ? super.createdTimestamp : null;\n\n    if ('owner_id' in data) {\n      /**\n       * The id of the member who created this thread\n       * @type {?Snowflake}\n       */\n      this.ownerId = data.owner_id;\n    } else {\n      this.ownerId ??= null;\n    }\n\n    if ('last_message_id' in data) {\n      /**\n       * The last message id sent in this thread, if one was sent\n       * @type {?Snowflake}\n       */\n      this.lastMessageId = data.last_message_id;\n    } else {\n      this.lastMessageId ??= null;\n    }\n\n    if ('last_pin_timestamp' in data) {\n      /**\n       * The timestamp when the last pinned message was pinned, if there was one\n       * @type {?number}\n       */\n      this.lastPinTimestamp = data.last_pin_timestamp ? Date.parse(data.last_pin_timestamp) : null;\n    } else {\n      this.lastPinTimestamp ??= null;\n    }\n\n    if ('rate_limit_per_user' in data || !partial) {\n      /**\n       * The rate limit per user (slowmode) for this thread in seconds\n       * @type {?number}\n       */\n      this.rateLimitPerUser = data.rate_limit_per_user ?? 0;\n    } else {\n      this.rateLimitPerUser ??= null;\n    }\n\n    if ('message_count' in data) {\n      /**\n       * The approximate count of messages in this thread\n       * <info>Threads created before July 1, 2022 may have an inaccurate count.\n       * If you need an approximate value higher than that, use `ThreadChannel#messages.cache.size`</info>\n       * @type {?number}\n       */\n      this.messageCount = data.message_count;\n    } else {\n      this.messageCount ??= null;\n    }\n\n    if ('member_count' in data) {\n      /**\n       * The approximate count of users in this thread\n       * <info>This stops counting at 50. If you need an approximate value higher than that, use\n       * `ThreadChannel#members.cache.size`</info>\n       * @type {?number}\n       */\n      this.memberCount = data.member_count;\n    } else {\n      this.memberCount ??= null;\n    }\n\n    if ('total_message_sent' in data) {\n      /**\n       * The number of messages ever sent in a thread, similar to {@link ThreadChannel#messageCount} except it\n       * will not decrement whenever a message is deleted\n       * @type {?number}\n       */\n      this.totalMessageSent = data.total_message_sent;\n    } else {\n      this.totalMessageSent ??= null;\n    }\n\n    if (data.member && this.client.user) this.members._add({ user_id: this.client.user.id, ...data.member });\n    if (data.messages) for (const message of data.messages) this.messages._add(message);\n\n    if ('applied_tags' in data) {\n      /**\n       * The tags applied to this thread\n       * @type {Snowflake[]}\n       */\n      this.appliedTags = data.applied_tags;\n    } else {\n      this.appliedTags ??= [];\n    }\n  }\n\n  /**\n   * The timestamp when this thread was created. This isn't available for threads\n   * created before 2022-01-09\n   * @type {?number}\n   * @readonly\n   */\n  get createdTimestamp() {\n    return this._createdTimestamp;\n  }\n\n  /**\n   * A collection of associated guild member objects of this thread's members\n   * @type {Collection<Snowflake, GuildMember>}\n   * @readonly\n   */\n  get guildMembers() {\n    return this.members.cache.mapValues(member => member.guildMember);\n  }\n\n  /**\n   * The time at which this thread's archive status was last changed\n   * <info>If the thread was never archived or unarchived, this is the time at which the thread was created</info>\n   * @type {?Date}\n   * @readonly\n   */\n  get archivedAt() {\n    return this.archiveTimestamp && new Date(this.archiveTimestamp);\n  }\n\n  /**\n   * The time the thread was created at\n   * @type {?Date}\n   * @readonly\n   */\n  get createdAt() {\n    return this.createdTimestamp && new Date(this.createdTimestamp);\n  }\n\n  /**\n   * The parent channel of this thread\n   * @type {?(NewsChannel|TextChannel|ForumChannel)}\n   * @readonly\n   */\n  get parent() {\n    return this.guild.channels.resolve(this.parentId);\n  }\n\n  /**\n   * Makes the client user join the thread.\n   * @returns {Promise<ThreadChannel>}\n   */\n  async join() {\n    await this.members.add('@me');\n    return this;\n  }\n\n  /**\n   * Makes the client user leave the thread.\n   * @returns {Promise<ThreadChannel>}\n   */\n  async leave() {\n    await this.members.remove('@me');\n    return this;\n  }\n\n  /**\n   * Gets the overall set of permissions for a member or role in this thread's parent channel, taking overwrites into\n   * account.\n   * @param {GuildMemberResolvable|RoleResolvable} memberOrRole The member or role to obtain the overall permissions for\n   * @param {boolean} [checkAdmin=true] Whether having the {@link PermissionFlagsBits.Administrator} permission\n   * will return all permissions\n   * @returns {?Readonly<PermissionsBitField>}\n   */\n  permissionsFor(memberOrRole, checkAdmin) {\n    return this.parent?.permissionsFor(memberOrRole, checkAdmin) ?? null;\n  }\n\n  /**\n   * Fetches the owner of this thread. If the thread member object isn't needed,\n   * use {@link ThreadChannel#ownerId} instead.\n   * @param {BaseFetchOptions} [options] The options for fetching the member\n   * @returns {Promise<?ThreadMember>}\n   */\n  async fetchOwner({ cache = true, force = false } = {}) {\n    if (!force) {\n      const existing = this.members.cache.get(this.ownerId);\n      if (existing) return existing;\n    }\n\n    // We cannot fetch a single thread member, as of this commit's date, Discord API responds with 405\n    const members = await this.members.fetch({ cache });\n    return members.get(this.ownerId) ?? null;\n  }\n\n  /**\n   * Fetches the message that started this thread, if any.\n   * <info>The `Promise` will reject if the original message in a forum post is deleted\n   * or when the original message in the parent channel is deleted.\n   * If you just need the id of that message, use {@link ThreadChannel#id} instead.</info>\n   * @param {BaseFetchOptions} [options] Additional options for this fetch\n   * @returns {Promise<Message<true>|null>}\n   */\n  // eslint-disable-next-line require-await\n  async fetchStarterMessage(options) {\n    const channel = this.parent?.type === ChannelType.GuildForum ? this : this.parent;\n    return channel?.messages.fetch({ message: this.id, ...options }) ?? null;\n  }\n\n  /**\n   * The options used to edit a thread channel\n   * @typedef {Object} ThreadEditData\n   * @property {string} [name] The new name for the thread\n   * @property {boolean} [archived] Whether the thread is archived\n   * @property {ThreadAutoArchiveDuration} [autoArchiveDuration] The amount of time after which the thread\n   * should automatically archive in case of no recent activity\n   * @property {number} [rateLimitPerUser] The rate limit per user (slowmode) for the thread in seconds\n   * @property {boolean} [locked] Whether the thread is locked\n   * @property {boolean} [invitable] Whether non-moderators can add other non-moderators to a thread\n   * @property {Snowflake[]} [appliedTags] The tags to apply to the thread\n   * @property {ChannelFlagsResolvable} [flags] The flags to set on the channel\n   * @property {string} [reason] Reason for editing the thread\n   * <info>Can only be edited on {@link ChannelType.PrivateThread}</info>\n   */\n\n  /**\n   * Edits this thread.\n   * @param {ThreadEditData} data The new data for this thread\n   * @returns {Promise<ThreadChannel>}\n   * @example\n   * // Edit a thread\n   * thread.edit({ name: 'new-thread' })\n   *   .then(editedThread => console.log(editedThread))\n   *   .catch(console.error);\n   */\n  async edit(data) {\n    const newData = await this.client.rest.patch(Routes.channel(this.id), {\n      body: {\n        name: (data.name ?? this.name).trim(),\n        archived: data.archived,\n        auto_archive_duration: data.autoArchiveDuration,\n        rate_limit_per_user: data.rateLimitPerUser,\n        locked: data.locked,\n        invitable: this.type === ChannelType.PrivateThread ? data.invitable : undefined,\n        applied_tags: data.appliedTags,\n        flags: 'flags' in data ? ChannelFlagsBitField.resolve(data.flags) : undefined,\n      },\n      reason: data.reason,\n    });\n\n    return this.client.actions.ChannelUpdate.handle(newData).updated;\n  }\n\n  /**\n   * Sets whether the thread is archived.\n   * @param {boolean} [archived=true] Whether the thread is archived\n   * @param {string} [reason] Reason for archiving or unarchiving\n   * @returns {Promise<ThreadChannel>}\n   * @example\n   * // Archive the thread\n   * thread.setArchived(true)\n   *   .then(newThread => console.log(`Thread is now ${newThread.archived ? 'archived' : 'active'}`))\n   *   .catch(console.error);\n   */\n  setArchived(archived = true, reason) {\n    return this.edit({ archived, reason });\n  }\n\n  /**\n   * Sets the duration after which the thread will automatically archive in case of no recent activity.\n   * @param {ThreadAutoArchiveDuration} autoArchiveDuration The amount of time after which the thread\n   * should automatically archive in case of no recent activity\n   * @param {string} [reason] Reason for changing the auto archive duration\n   * @returns {Promise<ThreadChannel>}\n   * @example\n   * // Set the thread's auto archive time to 1 hour\n   * thread.setAutoArchiveDuration(ThreadAutoArchiveDuration.OneHour)\n   *   .then(newThread => {\n   *     console.log(`Thread will now archive after ${newThread.autoArchiveDuration} minutes of inactivity`);\n   *    });\n   *   .catch(console.error);\n   */\n  setAutoArchiveDuration(autoArchiveDuration, reason) {\n    return this.edit({ autoArchiveDuration, reason });\n  }\n\n  /**\n   * Sets whether members without the {@link PermissionFlagsBits.ManageThreads} permission\n   * can invite other members to this thread.\n   * @param {boolean} [invitable=true] Whether non-moderators can invite non-moderators to this thread\n   * @param {string} [reason] Reason for changing invite\n   * @returns {Promise<ThreadChannel>}\n   */\n  setInvitable(invitable = true, reason) {\n    if (this.type !== ChannelType.PrivateThread) {\n      return Promise.reject(new DiscordjsRangeError(ErrorCodes.ThreadInvitableType, this.type));\n    }\n    return this.edit({ invitable, reason });\n  }\n\n  /**\n   * Sets whether the thread can be **unarchived** by anyone with the\n   * {@link PermissionFlagsBits.SendMessages} permission. When a thread is locked, only members with the\n   * {@link PermissionFlagsBits.ManageThreads} permission can unarchive it.\n   * @param {boolean} [locked=true] Whether the thread is locked\n   * @param {string} [reason] Reason for locking or unlocking the thread\n   * @returns {Promise<ThreadChannel>}\n   * @example\n   * // Set the thread to locked\n   * thread.setLocked(true)\n   *   .then(newThread => console.log(`Thread is now ${newThread.locked ? 'locked' : 'unlocked'}`))\n   *   .catch(console.error);\n   */\n  setLocked(locked = true, reason) {\n    return this.edit({ locked, reason });\n  }\n\n  /**\n   * Sets a new name for this thread.\n   * @param {string} name The new name for the thread\n   * @param {string} [reason] Reason for changing the thread's name\n   * @returns {Promise<ThreadChannel>}\n   * @example\n   * // Change the thread's name\n   * thread.setName('not_general')\n   *   .then(newThread => console.log(`Thread's new name is ${newThread.name}`))\n   *   .catch(console.error);\n   */\n  setName(name, reason) {\n    return this.edit({ name, reason });\n  }\n\n  /**\n   * Sets the rate limit per user (slowmode) for this thread.\n   * @param {number} rateLimitPerUser The new rate limit in seconds\n   * @param {string} [reason] Reason for changing the thread's rate limit\n   * @returns {Promise<ThreadChannel>}\n   */\n  setRateLimitPerUser(rateLimitPerUser, reason) {\n    return this.edit({ rateLimitPerUser, reason });\n  }\n\n  /**\n   * Set the applied tags for this channel (only applicable to forum threads)\n   * @param {Snowflake[]} appliedTags The tags to set for this channel\n   * @param {string} [reason] Reason for changing the thread's applied tags\n   * @returns {Promise<ThreadChannel>}\n   */\n  setAppliedTags(appliedTags, reason) {\n    return this.edit({ appliedTags, reason });\n  }\n\n  /**\n   * Pins this thread from the forum channel (only applicable to forum threads).\n   * @param {string} [reason] Reason for pinning\n   * @returns {Promise<ThreadChannel>}\n   */\n  pin(reason) {\n    return this.edit({ flags: this.flags.add(ChannelFlags.Pinned), reason });\n  }\n\n  /**\n   * Unpins this thread from the forum channel (only applicable to forum threads).\n   * @param {string} [reason] Reason for unpinning\n   * @returns {Promise<ThreadChannel>}\n   */\n  unpin(reason) {\n    return this.edit({ flags: this.flags.remove(ChannelFlags.Pinned), reason });\n  }\n\n  /**\n   * Whether the client user is a member of the thread.\n   * @type {boolean}\n   * @readonly\n   */\n  get joined() {\n    return this.members.cache.has(this.client.user?.id);\n  }\n\n  /**\n   * Whether the thread is editable by the client user (name, archived, autoArchiveDuration)\n   * @type {boolean}\n   * @readonly\n   */\n  get editable() {\n    return (\n      (this.ownerId === this.client.user.id && (this.type !== ChannelType.PrivateThread || this.joined)) ||\n      this.manageable\n    );\n  }\n\n  /**\n   * Whether the thread is joinable by the client user\n   * @type {boolean}\n   * @readonly\n   */\n  get joinable() {\n    return (\n      !this.archived &&\n      !this.joined &&\n      this.permissionsFor(this.client.user)?.has(\n        this.type === ChannelType.PrivateThread ? PermissionFlagsBits.ManageThreads : PermissionFlagsBits.ViewChannel,\n        false,\n      )\n    );\n  }\n\n  /**\n   * Whether the thread is manageable by the client user, for deleting or editing rateLimitPerUser or locked.\n   * @type {boolean}\n   * @readonly\n   */\n  get manageable() {\n    const permissions = this.permissionsFor(this.client.user);\n    if (!permissions) return false;\n    // This flag allows managing even if timed out\n    if (permissions.has(PermissionFlagsBits.Administrator, false)) return true;\n\n    return (\n      this.guild.members.me.communicationDisabledUntilTimestamp < Date.now() &&\n      permissions.has(PermissionFlagsBits.ManageThreads, false)\n    );\n  }\n\n  /**\n   * Whether the thread is viewable by the client user\n   * @type {boolean}\n   * @readonly\n   */\n  get viewable() {\n    if (this.client.user.id === this.guild.ownerId) return true;\n    const permissions = this.permissionsFor(this.client.user);\n    if (!permissions) return false;\n    return permissions.has(PermissionFlagsBits.ViewChannel, false);\n  }\n\n  /**\n   * Whether the client user can send messages in this thread\n   * @type {boolean}\n   * @readonly\n   */\n  get sendable() {\n    const permissions = this.permissionsFor(this.client.user);\n    if (!permissions) return false;\n    // This flag allows sending even if timed out\n    if (permissions.has(PermissionFlagsBits.Administrator, false)) return true;\n\n    return (\n      !(this.archived && this.locked && !this.manageable) &&\n      (this.type !== ChannelType.PrivateThread || this.joined || this.manageable) &&\n      permissions.has(PermissionFlagsBits.SendMessagesInThreads, false) &&\n      this.guild.members.me.communicationDisabledUntilTimestamp < Date.now()\n    );\n  }\n\n  /**\n   * Whether the thread is unarchivable by the client user\n   * @type {boolean}\n   * @readonly\n   */\n  get unarchivable() {\n    return this.archived && this.sendable && (!this.locked || this.manageable);\n  }\n\n  /**\n   * Deletes this thread.\n   * @param {string} [reason] Reason for deleting this thread\n   * @returns {Promise<ThreadChannel>}\n   * @example\n   * // Delete the thread\n   * thread.delete('cleaning out old threads')\n   *   .then(deletedThread => console.log(deletedThread))\n   *   .catch(console.error);\n   */\n  async delete(reason) {\n    await this.guild.channels.delete(this.id, reason);\n    return this;\n  }\n\n  // These are here only for documentation purposes - they are implemented by TextBasedChannel\n  /* eslint-disable no-empty-function */\n  get lastMessage() {}\n  get lastPinAt() {}\n  send() {}\n  sendTyping() {}\n  createMessageCollector() {}\n  awaitMessages() {}\n  createMessageComponentCollector() {}\n  awaitMessageComponent() {}\n  bulkDelete() {}\n  // Doesn't work on Thread channels; setRateLimitPerUser() {}\n  // Doesn't work on Thread channels; setNSFW() {}\n}\n\nTextBasedChannel.applyToClass(ThreadChannel, true, ['fetchWebhooks', 'setRateLimitPerUser', 'setNSFW']);\n\nmodule.exports = ThreadChannel;\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}